package clang;

import com.sun.jna.*;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;

import java.nio.IntBuffer;

/**
 * JNA Wrapper for library <b>Clang</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface ClangLibrary extends Library {
    public static final String JNA_LIBRARY_NAME = "Clang";
    public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(ClangLibrary.JNA_LIBRARY_NAME);
    public static final ClangLibrary INSTANCE = (ClangLibrary) Native.loadLibrary(ClangLibrary.JNA_LIBRARY_NAME, ClangLibrary.class);
    /**
     * \brief Describes the availability of a particular entity, which indicates<br>
     * whether the use of this entity will result in a warning or error due to<br>
     * it being deprecated or unavailable.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:101</i><br>
     * enum values
     */
    public static interface CXAvailabilityKind {
        /**
         * \brief The entity is available.<br>
         * \brief The entity is available.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:105</i>
         */
        public static final int CXAvailability_Available = (int) 0;
        /**
         * \brief The entity is available, but has been deprecated (and its use is<br>
         * not recommended).<br>
         * \brief The entity is available, but has been deprecated (and its use is<br>
         * not recommended).<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:110</i>
         */
        public static final int CXAvailability_Deprecated = (int) 1;
        /**
         * \brief The entity is not available; any use of it will be an error.<br>
         * \brief The entity is not available; any use of it will be an error.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:114</i>
         */
        public static final int CXAvailability_NotAvailable = (int) 2;
        /**
         * \brief The entity is available, but not accessible; any use of it will be<br>
         * an error.<br>
         * \brief The entity is available, but not accessible; any use of it will be<br>
         * an error.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:119</i>
         */
        public static final int CXAvailability_NotAccessible = (int) 3;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    public static interface CXGlobalOptFlags {
        /**
         * \brief Used to indicate that no special CXIndex options are needed.<br>
         * \brief Used to indicate that no special CXIndex options are needed.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:200</i>
         */
        public static final int CXGlobalOpt_None = (int) 0;
        /**
         * \brief Used to indicate that threads that libclang creates for indexing<br>
         * purposes should use background priority.<br>
         * * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,<br>
         * #clang_parseTranslationUnit, #clang_saveTranslationUnit.<br>
         * \brief Used to indicate that threads that libclang creates for indexing<br>
         * purposes should use background priority.<br>
         * * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,<br>
         * #clang_parseTranslationUnit, #clang_saveTranslationUnit.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:209</i>
         */
        public static final int CXGlobalOpt_ThreadBackgroundPriorityForIndexing = (int) 1;
        /**
         * \brief Used to indicate that threads that libclang creates for editing<br>
         * purposes should use background priority.<br>
         * * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,<br>
         * #clang_annotateTokens<br>
         * \brief Used to indicate that threads that libclang creates for editing<br>
         * purposes should use background priority.<br>
         * * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,<br>
         * #clang_annotateTokens<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:218</i>
         */
        public static final int CXGlobalOpt_ThreadBackgroundPriorityForEditing = (int) 2;
        /**
         * \brief Used to indicate that all threads that libclang creates should use<br>
         * background priority.<br>
         * \brief Used to indicate that all threads that libclang creates should use<br>
         * background priority.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:224</i>
         */
        public static final int CXGlobalOpt_ThreadBackgroundPriorityForAll = (int) (CXGlobalOptFlags.CXGlobalOpt_ThreadBackgroundPriorityForIndexing | CXGlobalOptFlags.CXGlobalOpt_ThreadBackgroundPriorityForEditing);
    }
    /**
     * \brief Describes the severity of a particular diagnostic.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:534</i><br>
     * enum values
     */
    /**
     * \brief Describes the severity of a particular diagnostic.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:534</i><br>
     * enum values
     */
    public static interface CXDiagnosticSeverity {
        /**
         * \brief A diagnostic that has been suppressed, e.g., by a command-line<br>
         * option.<br>
         * \brief A diagnostic that has been suppressed, e.g., by a command-line<br>
         * option.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:539</i>
         */
        public static final int CXDiagnostic_Ignored = (int) 0;
        /**
         * \brief This diagnostic is a note that should be attached to the<br>
         * previous (non-note) diagnostic.<br>
         * \brief This diagnostic is a note that should be attached to the<br>
         * previous (non-note) diagnostic.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:545</i>
         */
        public static final int CXDiagnostic_Note = (int) 1;
        /**
         * \brief This diagnostic indicates suspicious code that may not be<br>
         * wrong.<br>
         * \brief This diagnostic indicates suspicious code that may not be<br>
         * wrong.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:551</i>
         */
        public static final int CXDiagnostic_Warning = (int) 2;
        /**
         * \brief This diagnostic indicates that the code is ill-formed.<br>
         * \brief This diagnostic indicates that the code is ill-formed.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:556</i>
         */
        public static final int CXDiagnostic_Error = (int) 3;
        /**
         * \brief This diagnostic indicates that the code is ill-formed such<br>
         * that future parser recovery is unlikely to produce useful<br>
         * results.<br>
         * \brief This diagnostic indicates that the code is ill-formed such<br>
         * that future parser recovery is unlikely to produce useful<br>
         * results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:563</i>
         */
        public static final int CXDiagnostic_Fatal = (int) 4;
    }
    /**
     * \brief Describes the kind of error that occurred (if any) in a call to<br>
     * \c clang_loadDiagnostics.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:599</i><br>
     * enum values
     */
    /**
     * \brief Describes the kind of error that occurred (if any) in a call to<br>
     * \c clang_loadDiagnostics.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:599</i><br>
     * enum values
     */
    public static interface CXLoadDiag_Error {
        /**
         * \brief Indicates that no error occurred.<br>
         * \brief Indicates that no error occurred.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:603</i>
         */
        public static final int CXLoadDiag_None = (int) 0;
        /**
         * \brief Indicates that an unknown error occurred while attempting to<br>
         * deserialize diagnostics.<br>
         * \brief Indicates that an unknown error occurred while attempting to<br>
         * deserialize diagnostics.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:609</i>
         */
        public static final int CXLoadDiag_Unknown = (int) 1;
        /**
         * \brief Indicates that the file containing the serialized diagnostics<br>
         * could not be opened.<br>
         * \brief Indicates that the file containing the serialized diagnostics<br>
         * could not be opened.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:615</i>
         */
        public static final int CXLoadDiag_CannotLoad = (int) 2;
        /**
         * \brief Indicates that the serialized diagnostics file is invalid or<br>
         * corrupt.<br>
         * \brief Indicates that the serialized diagnostics file is invalid or<br>
         * corrupt.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:621</i>
         */
        public static final int CXLoadDiag_InvalidFile = (int) 3;
    }
    /**
     * \brief Options to control the display of diagnostics.<br>
     * * The values in this enum are meant to be combined to customize the<br>
     * behavior of \c clang_displayDiagnostic().<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:692</i><br>
     * enum values
     */
    /**
     * \brief Options to control the display of diagnostics.<br>
     * * The values in this enum are meant to be combined to customize the<br>
     * behavior of \c clang_displayDiagnostic().<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:692</i><br>
     * enum values
     */
    public static interface CXDiagnosticDisplayOptions {
        /**
         * \brief Display the source-location information where the<br>
         * diagnostic was located.<br>
         * * When set, diagnostics will be prefixed by the file, line, and<br>
         * (optionally) column to which the diagnostic refers. For example,<br>
         * * \code<br>
         * test.c:28: warning: extra tokens at end of #endif directive<br>
         * \endcode<br>
         * * This option corresponds to the clang flag \c -fshow-source-location.<br>
         * \brief Display the source-location information where the<br>
         * diagnostic was located.<br>
         * * When set, diagnostics will be prefixed by the file, line, and<br>
         * (optionally) column to which the diagnostic refers. For example,<br>
         * * \code<br>
         * test.c:28: warning: extra tokens at end of #endif directive<br>
         * \endcode<br>
         * * This option corresponds to the clang flag \c -fshow-source-location.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:706</i>
         */
        public static final int CXDiagnostic_DisplaySourceLocation = (int) 1;
        /**
         * \brief If displaying the source-location information of the<br>
         * diagnostic, also include the column number.<br>
         * * This option corresponds to the clang flag \c -fshow-column.<br>
         * \brief If displaying the source-location information of the<br>
         * diagnostic, also include the column number.<br>
         * * This option corresponds to the clang flag \c -fshow-column.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:714</i>
         */
        public static final int CXDiagnostic_DisplayColumn = (int) 2;
        /**
         * \brief If displaying the source-location information of the<br>
         * diagnostic, also include information about source ranges in a<br>
         * machine-parsable format.<br>
         * * This option corresponds to the clang flag<br>
         * \c -fdiagnostics-print-source-range-info.<br>
         * \brief If displaying the source-location information of the<br>
         * diagnostic, also include information about source ranges in a<br>
         * machine-parsable format.<br>
         * * This option corresponds to the clang flag<br>
         * \c -fdiagnostics-print-source-range-info.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:724</i>
         */
        public static final int CXDiagnostic_DisplaySourceRanges = (int) 4;
        /**
         * \brief Display the option name associated with this diagnostic, if any.<br>
         * * The option name displayed (e.g., -Wconversion) will be placed in brackets<br>
         * after the diagnostic text. This option corresponds to the clang flag<br>
         * \c -fdiagnostics-show-option.<br>
         * \brief Display the option name associated with this diagnostic, if any.<br>
         * * The option name displayed (e.g., -Wconversion) will be placed in brackets<br>
         * after the diagnostic text. This option corresponds to the clang flag<br>
         * \c -fdiagnostics-show-option.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:733</i>
         */
        public static final int CXDiagnostic_DisplayOption = (int) 8;
        /**
         * \brief Display the category number associated with this diagnostic, if any.<br>
         * * The category number is displayed within brackets after the diagnostic text.<br>
         * This option corresponds to the clang flag <br>
         * \c -fdiagnostics-show-category=id.<br>
         * \brief Display the category number associated with this diagnostic, if any.<br>
         * * The category number is displayed within brackets after the diagnostic text.<br>
         * This option corresponds to the clang flag <br>
         * \c -fdiagnostics-show-category=id.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:742</i>
         */
        public static final int CXDiagnostic_DisplayCategoryId = (int) 16;
        /**
         * \brief Display the category name associated with this diagnostic, if any.<br>
         * * The category name is displayed within brackets after the diagnostic text.<br>
         * This option corresponds to the clang flag <br>
         * \c -fdiagnostics-show-category=name.<br>
         * \brief Display the category name associated with this diagnostic, if any.<br>
         * * The category name is displayed within brackets after the diagnostic text.<br>
         * This option corresponds to the clang flag <br>
         * \c -fdiagnostics-show-category=name.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:751</i>
         */
        public static final int CXDiagnostic_DisplayCategoryName = (int) 32;
    }
    /**
     * \brief Flags that control the creation of translation units.<br>
     * * The enumerators in this enumeration type are meant to be bitwise<br>
     * ORed together to specify which options should be used when<br>
     * constructing the translation unit.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:985</i><br>
     * enum values
     */
    /**
     * \brief Flags that control the creation of translation units.<br>
     * * The enumerators in this enumeration type are meant to be bitwise<br>
     * ORed together to specify which options should be used when<br>
     * constructing the translation unit.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:985</i><br>
     * enum values
     */
    public static interface CXTranslationUnit_Flags {
        /**
         * \brief Used to indicate that no special translation-unit options are<br>
         * needed.<br>
         * \brief Used to indicate that no special translation-unit options are<br>
         * needed.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:990</i>
         */
        public static final int CXTranslationUnit_None = (int) 0;
        /**
         * \brief Used to indicate that the parser should construct a "detailed"<br>
         * preprocessing record, including all macro definitions and instantiations.<br>
         * * Constructing a detailed preprocessing record requires more memory<br>
         * and time to parse, since the information contained in the record<br>
         * is usually not retained. However, it can be useful for<br>
         * applications that require more detailed information about the<br>
         * behavior of the preprocessor.<br>
         * \brief Used to indicate that the parser should construct a "detailed"<br>
         * preprocessing record, including all macro definitions and instantiations.<br>
         * * Constructing a detailed preprocessing record requires more memory<br>
         * and time to parse, since the information contained in the record<br>
         * is usually not retained. However, it can be useful for<br>
         * applications that require more detailed information about the<br>
         * behavior of the preprocessor.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1002</i>
         */
        public static final int CXTranslationUnit_DetailedPreprocessingRecord = (int) 1;
        /**
         * \brief Used to indicate that the translation unit is incomplete.<br>
         * * When a translation unit is considered "incomplete", semantic<br>
         * analysis that is typically performed at the end of the<br>
         * translation unit will be suppressed. For example, this suppresses<br>
         * the completion of tentative declarations in C and of<br>
         * instantiation of implicitly-instantiation function templates in<br>
         * C++. This option is typically used when parsing a header with the<br>
         * intent of producing a precompiled header.<br>
         * \brief Used to indicate that the translation unit is incomplete.<br>
         * * When a translation unit is considered "incomplete", semantic<br>
         * analysis that is typically performed at the end of the<br>
         * translation unit will be suppressed. For example, this suppresses<br>
         * the completion of tentative declarations in C and of<br>
         * instantiation of implicitly-instantiation function templates in<br>
         * C++. This option is typically used when parsing a header with the<br>
         * intent of producing a precompiled header.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1015</i>
         */
        public static final int CXTranslationUnit_Incomplete = (int) 2;
        /**
         * \brief Used to indicate that the translation unit should be built with an <br>
         * implicit precompiled header for the preamble.<br>
         * * An implicit precompiled header is used as an optimization when a<br>
         * particular translation unit is likely to be reparsed many times<br>
         * when the sources aren't changing that often. In this case, an<br>
         * implicit precompiled header will be built containing all of the<br>
         * initial includes at the top of the main file (what we refer to as<br>
         * the "preamble" of the file). In subsequent parses, if the<br>
         * preamble or the files in it have not changed, \c<br>
         * clang_reparseTranslationUnit() will re-use the implicit<br>
         * precompiled header to improve parsing performance.<br>
         * \brief Used to indicate that the translation unit should be built with an <br>
         * implicit precompiled header for the preamble.<br>
         * * An implicit precompiled header is used as an optimization when a<br>
         * particular translation unit is likely to be reparsed many times<br>
         * when the sources aren't changing that often. In this case, an<br>
         * implicit precompiled header will be built containing all of the<br>
         * initial includes at the top of the main file (what we refer to as<br>
         * the "preamble" of the file). In subsequent parses, if the<br>
         * preamble or the files in it have not changed, \c<br>
         * clang_reparseTranslationUnit() will re-use the implicit<br>
         * precompiled header to improve parsing performance.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1031</i>
         */
        public static final int CXTranslationUnit_PrecompiledPreamble = (int) 4;
        /**
         * \brief Used to indicate that the translation unit should cache some<br>
         * code-completion results with each reparse of the source file.<br>
         * * Caching of code-completion results is a performance optimization that<br>
         * introduces some overhead to reparsing but improves the performance of<br>
         * code-completion operations.<br>
         * \brief Used to indicate that the translation unit should cache some<br>
         * code-completion results with each reparse of the source file.<br>
         * * Caching of code-completion results is a performance optimization that<br>
         * introduces some overhead to reparsing but improves the performance of<br>
         * code-completion operations.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1041</i>
         */
        public static final int CXTranslationUnit_CacheCompletionResults = (int) 8;
        /**
         * \brief Used to indicate that the translation unit will be serialized with<br>
         * \c clang_saveTranslationUnit.<br>
         * * This option is typically used when parsing a header with the intent of<br>
         * producing a precompiled header.<br>
         * \brief Used to indicate that the translation unit will be serialized with<br>
         * \c clang_saveTranslationUnit.<br>
         * * This option is typically used when parsing a header with the intent of<br>
         * producing a precompiled header.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1050</i>
         */
        public static final int CXTranslationUnit_ForSerialization = (int) 16;
        /**
         * \brief DEPRECATED: Enabled chained precompiled preambles in C++.<br>
         * * Note: this is a *temporary* option that is available only while<br>
         * we are testing C++ precompiled preamble support. It is deprecated.<br>
         * \brief DEPRECATED: Enabled chained precompiled preambles in C++.<br>
         * * Note: this is a *temporary* option that is available only while<br>
         * we are testing C++ precompiled preamble support. It is deprecated.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1058</i>
         */
        public static final int CXTranslationUnit_CXXChainedPCH = (int) 32;
        /**
         * \brief Used to indicate that function/method bodies should be skipped while<br>
         * parsing.<br>
         * * This option can be used to search for declarations/definitions while<br>
         * ignoring the usages.<br>
         * \brief Used to indicate that function/method bodies should be skipped while<br>
         * parsing.<br>
         * * This option can be used to search for declarations/definitions while<br>
         * ignoring the usages.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1067</i>
         */
        public static final int CXTranslationUnit_SkipFunctionBodies = (int) 64;
        /**
         * \brief Used to indicate that brief documentation comments should be<br>
         * included into the set of code completions returned from this translation<br>
         * unit.<br>
         * \brief Used to indicate that brief documentation comments should be<br>
         * included into the set of code completions returned from this translation<br>
         * unit.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1074</i>
         */
        public static final int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = (int) 128;
    }
    /**
     * \brief Flags that control how translation units are saved.<br>
     * * The enumerators in this enumeration type are meant to be bitwise<br>
     * ORed together to specify which options should be used when<br>
     * saving the translation unit.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1148</i><br>
     * enum values
     */
    /**
     * \brief Flags that control how translation units are saved.<br>
     * * The enumerators in this enumeration type are meant to be bitwise<br>
     * ORed together to specify which options should be used when<br>
     * saving the translation unit.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1148</i><br>
     * enum values
     */
    public static interface CXSaveTranslationUnit_Flags {
        /**
         * \brief Used to indicate that no special saving options are needed.<br>
         * \brief Used to indicate that no special saving options are needed.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1152</i>
         */
        public static final int CXSaveTranslationUnit_None = (int) 0;
    }
    /**
     * \brief Describes the kind of error that occurred (if any) in a call to<br>
     * \c clang_saveTranslationUnit().<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1170</i><br>
     * enum values
     */
    /**
     * \brief Describes the kind of error that occurred (if any) in a call to<br>
     * \c clang_saveTranslationUnit().<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1170</i><br>
     * enum values
     */
    public static interface CXSaveError {
        /**
         * \brief Indicates that no error occurred while saving a translation unit.<br>
         * \brief Indicates that no error occurred while saving a translation unit.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1174</i>
         */
        public static final int CXSaveError_None = (int) 0;
        /**
         * \brief Indicates that an unknown error occurred while attempting to save<br>
         * the file.<br>
         * * This error typically indicates that file I/O failed when attempting to <br>
         * write the file.<br>
         * \brief Indicates that an unknown error occurred while attempting to save<br>
         * the file.<br>
         * * This error typically indicates that file I/O failed when attempting to <br>
         * write the file.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1183</i>
         */
        public static final int CXSaveError_Unknown = (int) 1;
        /**
         * \brief Indicates that errors during translation prevented this attempt<br>
         * to save the translation unit.<br>
         * <br>
         * Errors that prevent the translation unit from being saved can be<br>
         * extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().<br>
         * \brief Indicates that errors during translation prevented this attempt<br>
         * to save the translation unit.<br>
         * <br>
         * Errors that prevent the translation unit from being saved can be<br>
         * extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1192</i>
         */
        public static final int CXSaveError_TranslationErrors = (int) 2;
        /**
         * \brief Indicates that the translation unit to be saved was somehow<br>
         * invalid (e.g., NULL).<br>
         * \brief Indicates that the translation unit to be saved was somehow<br>
         * invalid (e.g., NULL).<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1198</i>
         */
        public static final int CXSaveError_InvalidTU = (int) 3;
    }
    /**
     * \brief Flags that control the reparsing of translation units.<br>
     * * The enumerators in this enumeration type are meant to be bitwise<br>
     * ORed together to specify which options should be used when<br>
     * reparsing the translation unit.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1240</i><br>
     * enum values
     */
    /**
     * \brief Flags that control the reparsing of translation units.<br>
     * * The enumerators in this enumeration type are meant to be bitwise<br>
     * ORed together to specify which options should be used when<br>
     * reparsing the translation unit.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1240</i><br>
     * enum values
     */
    public static interface CXReparse_Flags {
        /**
         * \brief Used to indicate that no special reparsing options are needed.<br>
         * \brief Used to indicate that no special reparsing options are needed.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1244</i>
         */
        public static final int CXReparse_None = (int) 0;
    }
    /**
     * \brief Categorizes how memory is being used by a translation unit.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1305</i><br>
     * enum values
     */
    /**
     * \brief Categorizes how memory is being used by a translation unit.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1305</i><br>
     * enum values
     */
    public static interface CXTUResourceUsageKind {
        /// <i>native declaration : src/main/c/clang-c/Index.h:1306</i>
        public static final int CXTUResourceUsage_AST = (int) 1;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1307</i>
        public static final int CXTUResourceUsage_Identifiers = (int) 2;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1308</i>
        public static final int CXTUResourceUsage_Selectors = (int) 3;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1309</i>
        public static final int CXTUResourceUsage_GlobalCompletionResults = (int) 4;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1310</i>
        public static final int CXTUResourceUsage_SourceManagerContentCache = (int) 5;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1311</i>
        public static final int CXTUResourceUsage_AST_SideTables = (int) 6;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1312</i>
        public static final int CXTUResourceUsage_SourceManager_Membuffer_Malloc = (int) 7;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1313</i>
        public static final int CXTUResourceUsage_SourceManager_Membuffer_MMap = (int) 8;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1314</i>
        public static final int CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = (int) 9;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1315</i>
        public static final int CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = (int) 10;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1316</i>
        public static final int CXTUResourceUsage_Preprocessor = (int) 11;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1317</i>
        public static final int CXTUResourceUsage_PreprocessingRecord = (int) 12;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1318</i>
        public static final int CXTUResourceUsage_SourceManager_DataStructures = (int) 13;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1319</i>
        public static final int CXTUResourceUsage_Preprocessor_HeaderSearch = (int) 14;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1320</i>
        public static final int CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = (int) ((int) ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_AST);
        /// <i>native declaration : src/main/c/clang-c/Index.h:1321</i>
        public static final int CXTUResourceUsage_MEMORY_IN_BYTES_END = (int) ((int) ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_Preprocessor_HeaderSearch);
        /// <i>native declaration : src/main/c/clang-c/Index.h:1324</i>
        public static final int CXTUResourceUsage_First = (int) ((int) ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_AST);
        /// <i>native declaration : src/main/c/clang-c/Index.h:1325</i>
        public static final int CXTUResourceUsage_Last = (int) ((int) ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_Preprocessor_HeaderSearch);
    }
    /**
     * \brief Describes the kind of entity that a cursor refers to.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1374</i><br>
     * enum values
     */
    /**
     * \brief Describes the kind of entity that a cursor refers to.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1374</i><br>
     * enum values
     */
    public static interface CXCursorKind {
        /**
         * \brief A declaration whose specific kind is not exposed via this<br>
         * interface.<br>
         * * Unexposed declarations have the same operations as any other kind<br>
         * of declaration; one can extract their location information,<br>
         * spelling, find their definitions, etc. However, the specific kind<br>
         * of the declaration is not reported.<br>
         * \brief A declaration whose specific kind is not exposed via this<br>
         * interface.<br>
         * * Unexposed declarations have the same operations as any other kind<br>
         * of declaration; one can extract their location information,<br>
         * spelling, find their definitions, etc. However, the specific kind<br>
         * of the declaration is not reported.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1385</i>
         */
        public static final int CXCursor_UnexposedDecl = (int) 1;
        /**
         * \brief A C or C++ struct.<br>
         * \brief A C or C++ struct.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1387</i>
         */
        public static final int CXCursor_StructDecl = (int) 2;
        /**
         * \brief A C or C++ union.<br>
         * \brief A C or C++ union.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1389</i>
         */
        public static final int CXCursor_UnionDecl = (int) 3;
        /**
         * \brief A C++ class.<br>
         * \brief A C++ class.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1391</i>
         */
        public static final int CXCursor_ClassDecl = (int) 4;
        /**
         * \brief An enumeration.<br>
         * \brief An enumeration.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1393</i>
         */
        public static final int CXCursor_EnumDecl = (int) 5;
        /**
         * \brief A field (in C) or non-static data member (in C++) in a<br>
         * struct, union, or C++ class.<br>
         * \brief A field (in C) or non-static data member (in C++) in a<br>
         * struct, union, or C++ class.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1398</i>
         */
        public static final int CXCursor_FieldDecl = (int) 6;
        /**
         * \brief An enumerator constant.<br>
         * \brief An enumerator constant.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1400</i>
         */
        public static final int CXCursor_EnumConstantDecl = (int) 7;
        /**
         * \brief A function.<br>
         * \brief A function.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1402</i>
         */
        public static final int CXCursor_FunctionDecl = (int) 8;
        /**
         * \brief A variable.<br>
         * \brief A variable.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1404</i>
         */
        public static final int CXCursor_VarDecl = (int) 9;
        /**
         * \brief A function or method parameter.<br>
         * \brief A function or method parameter.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1406</i>
         */
        public static final int CXCursor_ParmDecl = (int) 10;
        /**
         * \brief An Objective-C \@interface.<br>
         * \brief An Objective-C \@interface.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1408</i>
         */
        public static final int CXCursor_ObjCInterfaceDecl = (int) 11;
        /**
         * \brief An Objective-C \@interface for a category.<br>
         * \brief An Objective-C \@interface for a category.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1410</i>
         */
        public static final int CXCursor_ObjCCategoryDecl = (int) 12;
        /**
         * \brief An Objective-C \@protocol declaration.<br>
         * \brief An Objective-C \@protocol declaration.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1412</i>
         */
        public static final int CXCursor_ObjCProtocolDecl = (int) 13;
        /**
         * \brief An Objective-C \@property declaration.<br>
         * \brief An Objective-C \@property declaration.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1414</i>
         */
        public static final int CXCursor_ObjCPropertyDecl = (int) 14;
        /**
         * \brief An Objective-C instance variable.<br>
         * \brief An Objective-C instance variable.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1416</i>
         */
        public static final int CXCursor_ObjCIvarDecl = (int) 15;
        /**
         * \brief An Objective-C instance method.<br>
         * \brief An Objective-C instance method.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1418</i>
         */
        public static final int CXCursor_ObjCInstanceMethodDecl = (int) 16;
        /**
         * \brief An Objective-C class method.<br>
         * \brief An Objective-C class method.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1420</i>
         */
        public static final int CXCursor_ObjCClassMethodDecl = (int) 17;
        /**
         * \brief An Objective-C \@implementation.<br>
         * \brief An Objective-C \@implementation.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1422</i>
         */
        public static final int CXCursor_ObjCImplementationDecl = (int) 18;
        /**
         * \brief An Objective-C \@implementation for a category.<br>
         * \brief An Objective-C \@implementation for a category.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1424</i>
         */
        public static final int CXCursor_ObjCCategoryImplDecl = (int) 19;
        /**
         * \brief A typedef<br>
         * \brief A typedef<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1426</i>
         */
        public static final int CXCursor_TypedefDecl = (int) 20;
        /**
         * \brief A C++ class method.<br>
         * \brief A C++ class method.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1428</i>
         */
        public static final int CXCursor_CXXMethod = (int) 21;
        /**
         * \brief A C++ namespace.<br>
         * \brief A C++ namespace.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1430</i>
         */
        public static final int CXCursor_Namespace = (int) 22;
        /**
         * \brief A linkage specification, e.g. 'extern "C"'.<br>
         * \brief A linkage specification, e.g. 'extern "C"'.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1432</i>
         */
        public static final int CXCursor_LinkageSpec = (int) 23;
        /**
         * \brief A C++ constructor.<br>
         * \brief A C++ constructor.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1434</i>
         */
        public static final int CXCursor_Constructor = (int) 24;
        /**
         * \brief A C++ destructor.<br>
         * \brief A C++ destructor.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1436</i>
         */
        public static final int CXCursor_Destructor = (int) 25;
        /**
         * \brief A C++ conversion function.<br>
         * \brief A C++ conversion function.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1438</i>
         */
        public static final int CXCursor_ConversionFunction = (int) 26;
        /**
         * \brief A C++ template type parameter.<br>
         * \brief A C++ template type parameter.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1440</i>
         */
        public static final int CXCursor_TemplateTypeParameter = (int) 27;
        /**
         * \brief A C++ non-type template parameter.<br>
         * \brief A C++ non-type template parameter.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1442</i>
         */
        public static final int CXCursor_NonTypeTemplateParameter = (int) 28;
        /**
         * \brief A C++ template template parameter.<br>
         * \brief A C++ template template parameter.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1444</i>
         */
        public static final int CXCursor_TemplateTemplateParameter = (int) 29;
        /**
         * \brief A C++ function template.<br>
         * \brief A C++ function template.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1446</i>
         */
        public static final int CXCursor_FunctionTemplate = (int) 30;
        /**
         * \brief A C++ class template.<br>
         * \brief A C++ class template.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1448</i>
         */
        public static final int CXCursor_ClassTemplate = (int) 31;
        /**
         * \brief A C++ class template partial specialization.<br>
         * \brief A C++ class template partial specialization.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1450</i>
         */
        public static final int CXCursor_ClassTemplatePartialSpecialization = (int) 32;
        /**
         * \brief A C++ namespace alias declaration.<br>
         * \brief A C++ namespace alias declaration.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1452</i>
         */
        public static final int CXCursor_NamespaceAlias = (int) 33;
        /**
         * \brief A C++ using directive.<br>
         * \brief A C++ using directive.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1454</i>
         */
        public static final int CXCursor_UsingDirective = (int) 34;
        /**
         * \brief A C++ using declaration.<br>
         * \brief A C++ using declaration.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1456</i>
         */
        public static final int CXCursor_UsingDeclaration = (int) 35;
        /**
         * \brief A C++ alias declaration<br>
         * \brief A C++ alias declaration<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1458</i>
         */
        public static final int CXCursor_TypeAliasDecl = (int) 36;
        /**
         * \brief An Objective-C \@synthesize definition.<br>
         * \brief An Objective-C \@synthesize definition.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1460</i>
         */
        public static final int CXCursor_ObjCSynthesizeDecl = (int) 37;
        /**
         * \brief An Objective-C \@dynamic definition.<br>
         * \brief An Objective-C \@dynamic definition.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1462</i>
         */
        public static final int CXCursor_ObjCDynamicDecl = (int) 38;
        /**
         * \brief An access specifier.<br>
         * \brief An access specifier.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1464</i>
         */
        public static final int CXCursor_CXXAccessSpecifier = (int) 39;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1466</i>
        public static final int CXCursor_FirstDecl = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_UnexposedDecl);
        /// <i>native declaration : src/main/c/clang-c/Index.h:1467</i>
        public static final int CXCursor_LastDecl = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_CXXAccessSpecifier);
        /**
         * References<br>
         * References<br>
         * Decl references<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1470</i>
         */
        public static final int CXCursor_FirstRef = (int) 40;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1471</i>
        public static final int CXCursor_ObjCSuperClassRef = (int) 40;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1472</i>
        public static final int CXCursor_ObjCProtocolRef = (int) 41;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1473</i>
        public static final int CXCursor_ObjCClassRef = (int) 42;
        /**
         * \brief A reference to a type declaration.<br>
         * * A type reference occurs anywhere where a type is named but not<br>
         * declared. For example, given:<br>
         * * \code<br>
         * typedef unsigned size_type;<br>
         * size_type size;<br>
         * \endcode<br>
         * * The typedef is a declaration of size_type (CXCursor_TypedefDecl),<br>
         * while the type of the variable "size" is referenced. The cursor<br>
         * referenced by the type of size is the typedef for size_type.<br>
         * \brief A reference to a type declaration.<br>
         * * A type reference occurs anywhere where a type is named but not<br>
         * declared. For example, given:<br>
         * * \code<br>
         * typedef unsigned size_type;<br>
         * size_type size;<br>
         * \endcode<br>
         * * The typedef is a declaration of size_type (CXCursor_TypedefDecl),<br>
         * while the type of the variable "size" is referenced. The cursor<br>
         * referenced by the type of size is the typedef for size_type.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1489</i>
         */
        public static final int CXCursor_TypeRef = (int) 43;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1490</i>
        public static final int CXCursor_CXXBaseSpecifier = (int) 44;
        /**
         * \brief A reference to a class template, function template, template<br>
         * template parameter, or class template partial specialization.<br>
         * \brief A reference to a class template, function template, template<br>
         * template parameter, or class template partial specialization.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1495</i>
         */
        public static final int CXCursor_TemplateRef = (int) 45;
        /**
         * \brief A reference to a namespace or namespace alias.<br>
         * \brief A reference to a namespace or namespace alias.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1499</i>
         */
        public static final int CXCursor_NamespaceRef = (int) 46;
        /**
         * \brief A reference to a member of a struct, union, or class that occurs in <br>
         * some non-expression context, e.g., a designated initializer.<br>
         * \brief A reference to a member of a struct, union, or class that occurs in <br>
         * some non-expression context, e.g., a designated initializer.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1504</i>
         */
        public static final int CXCursor_MemberRef = (int) 47;
        /**
         * \brief A reference to a labeled statement.<br>
         * * This cursor kind is used to describe the jump to "start_over" in the <br>
         * goto statement in the following example:<br>
         * * \code<br>
         * start_over:<br>
         * ++counter;<br>
         * *     goto start_over;<br>
         * \endcode<br>
         * * A label reference cursor refers to a label statement.<br>
         * \brief A reference to a labeled statement.<br>
         * * This cursor kind is used to describe the jump to "start_over" in the <br>
         * goto statement in the following example:<br>
         * * \code<br>
         * start_over:<br>
         * ++counter;<br>
         * *     goto start_over;<br>
         * \endcode<br>
         * * A label reference cursor refers to a label statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1520</i>
         */
        public static final int CXCursor_LabelRef = (int) 48;
        /**
         * \brief A reference to a set of overloaded functions or function templates<br>
         * that has not yet been resolved to a specific function or function template.<br>
         * * An overloaded declaration reference cursor occurs in C++ templates where<br>
         * a dependent name refers to a function. For example:<br>
         * * \code<br>
         * template<typename T> void swap(T&, T&);<br>
         * * struct X { ... };<br>
         * void swap(X&, X&);<br>
         * * template<typename T><br>
         * void reverse(T* first, T* last) {<br>
         * while (first < last - 1) {<br>
         * swap(*first, *--last);<br>
         * ++first;<br>
         * }<br>
         * }<br>
         * * struct Y { };<br>
         * void swap(Y&, Y&);<br>
         * \endcode<br>
         * * Here, the identifier "swap" is associated with an overloaded declaration<br>
         * reference. In the template definition, "swap" refers to either of the two<br>
         * "swap" functions declared above, so both results will be available. At<br>
         * instantiation time, "swap" may also refer to other functions found via<br>
         * argument-dependent lookup (e.g., the "swap" function at the end of the<br>
         * example).<br>
         * * The functions \c clang_getNumOverloadedDecls() and <br>
         * \c clang_getOverloadedDecl() can be used to retrieve the definitions<br>
         * referenced by this cursor.<br>
         * \brief A reference to a set of overloaded functions or function templates<br>
         * that has not yet been resolved to a specific function or function template.<br>
         * * An overloaded declaration reference cursor occurs in C++ templates where<br>
         * a dependent name refers to a function. For example:<br>
         * * \code<br>
         * template<typename T> void swap(T&, T&);<br>
         * * struct X { ... };<br>
         * void swap(X&, X&);<br>
         * * template<typename T><br>
         * void reverse(T* first, T* last) {<br>
         * while (first < last - 1) {<br>
         * swap(*first, *--last);<br>
         * ++first;<br>
         * }<br>
         * }<br>
         * * struct Y { };<br>
         * void swap(Y&, Y&);<br>
         * \endcode<br>
         * * Here, the identifier "swap" is associated with an overloaded declaration<br>
         * reference. In the template definition, "swap" refers to either of the two<br>
         * "swap" functions declared above, so both results will be available. At<br>
         * instantiation time, "swap" may also refer to other functions found via<br>
         * argument-dependent lookup (e.g., the "swap" function at the end of the<br>
         * example).<br>
         * * The functions \c clang_getNumOverloadedDecls() and <br>
         * \c clang_getOverloadedDecl() can be used to retrieve the definitions<br>
         * referenced by this cursor.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1558</i>
         */
        public static final int CXCursor_OverloadedDeclRef = (int) 49;
        /**
         * \brief A reference to a variable that occurs in some non-expression <br>
         * context, e.g., a C++ lambda capture list.<br>
         * \brief A reference to a variable that occurs in some non-expression <br>
         * context, e.g., a C++ lambda capture list.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1564</i>
         */
        public static final int CXCursor_VariableRef = (int) 50;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1566</i>
        public static final int CXCursor_LastRef = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_VariableRef);
        /**
         * Error conditions<br>
         * Error conditions<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1569</i>
         */
        public static final int CXCursor_FirstInvalid = (int) 70;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1570</i>
        public static final int CXCursor_InvalidFile = (int) 70;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1571</i>
        public static final int CXCursor_NoDeclFound = (int) 71;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1572</i>
        public static final int CXCursor_NotImplemented = (int) 72;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1573</i>
        public static final int CXCursor_InvalidCode = (int) 73;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1574</i>
        public static final int CXCursor_LastInvalid = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_InvalidCode);
        /**
         * Expressions<br>
         * Expressions<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1577</i>
         */
        public static final int CXCursor_FirstExpr = (int) 100;
        /**
         * \brief An expression whose specific kind is not exposed via this<br>
         * interface.<br>
         * * Unexposed expressions have the same operations as any other kind<br>
         * of expression; one can extract their location information,<br>
         * spelling, children, etc. However, the specific kind of the<br>
         * expression is not reported.<br>
         * \brief An expression whose specific kind is not exposed via this<br>
         * interface.<br>
         * * Unexposed expressions have the same operations as any other kind<br>
         * of expression; one can extract their location information,<br>
         * spelling, children, etc. However, the specific kind of the<br>
         * expression is not reported.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1588</i>
         */
        public static final int CXCursor_UnexposedExpr = (int) 100;
        /**
         * \brief An expression that refers to some value declaration, such<br>
         * as a function, varible, or enumerator.<br>
         * \brief An expression that refers to some value declaration, such<br>
         * as a function, varible, or enumerator.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1594</i>
         */
        public static final int CXCursor_DeclRefExpr = (int) 101;
        /**
         * \brief An expression that refers to a member of a struct, union,<br>
         * class, Objective-C class, etc.<br>
         * \brief An expression that refers to a member of a struct, union,<br>
         * class, Objective-C class, etc.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1600</i>
         */
        public static final int CXCursor_MemberRefExpr = (int) 102;
        /**
         * \brief An expression that calls a function.<br>
         * \brief An expression that calls a function.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1603</i>
         */
        public static final int CXCursor_CallExpr = (int) 103;
        /**
         * \brief An expression that sends a message to an Objective-C<br>
         * object or class.<br>
         * \brief An expression that sends a message to an Objective-C<br>
         * object or class.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1607</i>
         */
        public static final int CXCursor_ObjCMessageExpr = (int) 104;
        /**
         * \brief An expression that represents a block literal.<br>
         * \brief An expression that represents a block literal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1610</i>
         */
        public static final int CXCursor_BlockExpr = (int) 105;
        /**
         * \brief An integer literal.<br>
         * \brief An integer literal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1614</i>
         */
        public static final int CXCursor_IntegerLiteral = (int) 106;
        /**
         * \brief A floating point number literal.<br>
         * \brief A floating point number literal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1618</i>
         */
        public static final int CXCursor_FloatingLiteral = (int) 107;
        /**
         * \brief An imaginary number literal.<br>
         * \brief An imaginary number literal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1622</i>
         */
        public static final int CXCursor_ImaginaryLiteral = (int) 108;
        /**
         * \brief A string literal.<br>
         * \brief A string literal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1626</i>
         */
        public static final int CXCursor_StringLiteral = (int) 109;
        /**
         * \brief A character literal.<br>
         * \brief A character literal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1630</i>
         */
        public static final int CXCursor_CharacterLiteral = (int) 110;
        /**
         * \brief A parenthesized expression, e.g. "(1)".<br>
         * * This AST node is only formed if full location information is requested.<br>
         * \brief A parenthesized expression, e.g. "(1)".<br>
         * * This AST node is only formed if full location information is requested.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1636</i>
         */
        public static final int CXCursor_ParenExpr = (int) 111;
        /**
         * \brief This represents the unary-expression's (except sizeof and<br>
         * alignof).<br>
         * \brief This represents the unary-expression's (except sizeof and<br>
         * alignof).<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1641</i>
         */
        public static final int CXCursor_UnaryOperator = (int) 112;
        /**
         * \brief [C99 6.5.2.1] Array Subscripting.<br>
         * \brief [C99 6.5.2.1] Array Subscripting.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1645</i>
         */
        public static final int CXCursor_ArraySubscriptExpr = (int) 113;
        /**
         * \brief A builtin binary operation expression such as "x + y" or<br>
         * "x <= y".<br>
         * \brief A builtin binary operation expression such as "x + y" or<br>
         * "x <= y".<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1650</i>
         */
        public static final int CXCursor_BinaryOperator = (int) 114;
        /**
         * \brief Compound assignment such as "+=".<br>
         * \brief Compound assignment such as "+=".<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1654</i>
         */
        public static final int CXCursor_CompoundAssignOperator = (int) 115;
        /**
         * \brief The ?: ternary operator.<br>
         * \brief The ?: ternary operator.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1658</i>
         */
        public static final int CXCursor_ConditionalOperator = (int) 116;
        /**
         * \brief An explicit cast in C (C99 6.5.4) or a C-style cast in C++<br>
         * (C++ [expr.cast]), which uses the syntax (Type)expr.<br>
         * * For example: (int)f.<br>
         * \brief An explicit cast in C (C99 6.5.4) or a C-style cast in C++<br>
         * (C++ [expr.cast]), which uses the syntax (Type)expr.<br>
         * * For example: (int)f.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1665</i>
         */
        public static final int CXCursor_CStyleCastExpr = (int) 117;
        /**
         * \brief [C99 6.5.2.5]<br>
         * \brief [C99 6.5.2.5]<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1669</i>
         */
        public static final int CXCursor_CompoundLiteralExpr = (int) 118;
        /**
         * \brief Describes an C or C++ initializer list.<br>
         * \brief Describes an C or C++ initializer list.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1673</i>
         */
        public static final int CXCursor_InitListExpr = (int) 119;
        /**
         * \brief The GNU address of label extension, representing &&label.<br>
         * \brief The GNU address of label extension, representing &&label.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1677</i>
         */
        public static final int CXCursor_AddrLabelExpr = (int) 120;
        /**
         * \brief This is the GNU Statement Expression extension: ({int X=4; X;})<br>
         * \brief This is the GNU Statement Expression extension: ({int X=4; X;})<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1681</i>
         */
        public static final int CXCursor_StmtExpr = (int) 121;
        /**
         * \brief Represents a C11 generic selection.<br>
         * \brief Represents a C11 generic selection.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1685</i>
         */
        public static final int CXCursor_GenericSelectionExpr = (int) 122;
        /**
         * \brief Implements the GNU __null extension, which is a name for a null<br>
         * pointer constant that has integral type (e.g., int or long) and is the same<br>
         * size and alignment as a pointer.<br>
         * * The __null extension is typically only used by system headers, which define<br>
         * NULL as __null in C++ rather than using 0 (which is an integer that may not<br>
         * match the size of a pointer).<br>
         * \brief Implements the GNU __null extension, which is a name for a null<br>
         * pointer constant that has integral type (e.g., int or long) and is the same<br>
         * size and alignment as a pointer.<br>
         * * The __null extension is typically only used by system headers, which define<br>
         * NULL as __null in C++ rather than using 0 (which is an integer that may not<br>
         * match the size of a pointer).<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1695</i>
         */
        public static final int CXCursor_GNUNullExpr = (int) 123;
        /**
         * \brief C++'s static_cast<> expression.<br>
         * \brief C++'s static_cast<> expression.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1699</i>
         */
        public static final int CXCursor_CXXStaticCastExpr = (int) 124;
        /**
         * \brief C++'s dynamic_cast<> expression.<br>
         * \brief C++'s dynamic_cast<> expression.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1703</i>
         */
        public static final int CXCursor_CXXDynamicCastExpr = (int) 125;
        /**
         * \brief C++'s reinterpret_cast<> expression.<br>
         * \brief C++'s reinterpret_cast<> expression.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1707</i>
         */
        public static final int CXCursor_CXXReinterpretCastExpr = (int) 126;
        /**
         * \brief C++'s const_cast<> expression.<br>
         * \brief C++'s const_cast<> expression.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1711</i>
         */
        public static final int CXCursor_CXXConstCastExpr = (int) 127;
        /**
         * \brief Represents an explicit C++ type conversion that uses "functional"<br>
         * notion (C++ [expr.type.conv]).<br>
         * * Example:<br>
         * \code<br>
         * x = int(0.5);<br>
         * \endcode<br>
         * \brief Represents an explicit C++ type conversion that uses "functional"<br>
         * notion (C++ [expr.type.conv]).<br>
         * * Example:<br>
         * \code<br>
         * x = int(0.5);<br>
         * \endcode<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1721</i>
         */
        public static final int CXCursor_CXXFunctionalCastExpr = (int) 128;
        /**
         * \brief A C++ typeid expression (C++ [expr.typeid]).<br>
         * \brief A C++ typeid expression (C++ [expr.typeid]).<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1725</i>
         */
        public static final int CXCursor_CXXTypeidExpr = (int) 129;
        /**
         * \brief [C++ 2.13.5] C++ Boolean Literal.<br>
         * \brief [C++ 2.13.5] C++ Boolean Literal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1729</i>
         */
        public static final int CXCursor_CXXBoolLiteralExpr = (int) 130;
        /**
         * \brief [C++0x 2.14.7] C++ Pointer Literal.<br>
         * \brief [C++0x 2.14.7] C++ Pointer Literal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1733</i>
         */
        public static final int CXCursor_CXXNullPtrLiteralExpr = (int) 131;
        /**
         * \brief Represents the "this" expression in C++<br>
         * \brief Represents the "this" expression in C++<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1737</i>
         */
        public static final int CXCursor_CXXThisExpr = (int) 132;
        /**
         * \brief [C++ 15] C++ Throw Expression.<br>
         * * This handles 'throw' and 'throw' assignment-expression. When<br>
         * assignment-expression isn't present, Op will be null.<br>
         * \brief [C++ 15] C++ Throw Expression.<br>
         * * This handles 'throw' and 'throw' assignment-expression. When<br>
         * assignment-expression isn't present, Op will be null.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1744</i>
         */
        public static final int CXCursor_CXXThrowExpr = (int) 133;
        /**
         * \brief A new expression for memory allocation and constructor calls, e.g:<br>
         * "new CXXNewExpr(foo)".<br>
         * \brief A new expression for memory allocation and constructor calls, e.g:<br>
         * "new CXXNewExpr(foo)".<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1749</i>
         */
        public static final int CXCursor_CXXNewExpr = (int) 134;
        /**
         * \brief A delete expression for memory deallocation and destructor calls,<br>
         * e.g. "delete[] pArray".<br>
         * \brief A delete expression for memory deallocation and destructor calls,<br>
         * e.g. "delete[] pArray".<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1754</i>
         */
        public static final int CXCursor_CXXDeleteExpr = (int) 135;
        /**
         * \brief A unary expression.<br>
         * \brief A unary expression.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1758</i>
         */
        public static final int CXCursor_UnaryExpr = (int) 136;
        /**
         * \brief An Objective-C string literal i.e. @"foo".<br>
         * \brief An Objective-C string literal i.e. @"foo".<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1762</i>
         */
        public static final int CXCursor_ObjCStringLiteral = (int) 137;
        /**
         * \brief An Objective-C \@encode expression.<br>
         * \brief An Objective-C \@encode expression.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1766</i>
         */
        public static final int CXCursor_ObjCEncodeExpr = (int) 138;
        /**
         * \brief An Objective-C \@selector expression.<br>
         * \brief An Objective-C \@selector expression.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1770</i>
         */
        public static final int CXCursor_ObjCSelectorExpr = (int) 139;
        /**
         * \brief An Objective-C \@protocol expression.<br>
         * \brief An Objective-C \@protocol expression.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1774</i>
         */
        public static final int CXCursor_ObjCProtocolExpr = (int) 140;
        /**
         * \brief An Objective-C "bridged" cast expression, which casts between<br>
         * Objective-C pointers and C pointers, transferring ownership in the process.<br>
         * * \code<br>
         * NSString *str = (__bridge_transfer NSString *)CFCreateString();<br>
         * \endcode<br>
         * \brief An Objective-C "bridged" cast expression, which casts between<br>
         * Objective-C pointers and C pointers, transferring ownership in the process.<br>
         * * \code<br>
         * NSString *str = (__bridge_transfer NSString *)CFCreateString();<br>
         * \endcode<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1783</i>
         */
        public static final int CXCursor_ObjCBridgedCastExpr = (int) 141;
        /**
         * \brief Represents a C++0x pack expansion that produces a sequence of<br>
         * expressions.<br>
         * * A pack expansion expression contains a pattern (which itself is an<br>
         * expression) followed by an ellipsis. For example:<br>
         * * \code<br>
         * template<typename F, typename ...Types><br>
         * void forward(F f, Types &&...args) {<br>
         * f(static_cast<Types&&>(args)...);<br>
         * }<br>
         * \endcode<br>
         * \brief Represents a C++0x pack expansion that produces a sequence of<br>
         * expressions.<br>
         * * A pack expansion expression contains a pattern (which itself is an<br>
         * expression) followed by an ellipsis. For example:<br>
         * * \code<br>
         * template<typename F, typename ...Types><br>
         * void forward(F f, Types &&...args) {<br>
         * f(static_cast<Types&&>(args)...);<br>
         * }<br>
         * \endcode<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1798</i>
         */
        public static final int CXCursor_PackExpansionExpr = (int) 142;
        /**
         * \brief Represents an expression that computes the length of a parameter<br>
         * pack.<br>
         * * \code<br>
         * template<typename ...Types><br>
         * struct count {<br>
         * static const unsigned value = sizeof...(Types);<br>
         * };<br>
         * \endcode<br>
         * \brief Represents an expression that computes the length of a parameter<br>
         * pack.<br>
         * * \code<br>
         * template<typename ...Types><br>
         * struct count {<br>
         * static const unsigned value = sizeof...(Types);<br>
         * };<br>
         * \endcode<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1810</i>
         */
        public static final int CXCursor_SizeOfPackExpr = (int) 143;
        /**
         * \brief Represents a C++ lambda expression that produces a local function<br>
         * object.<br>
         * * \code<br>
         * void abssort(float *x, unsigned N) {<br>
         * std::sort(x, x + N,<br>
         * [](float a, float b) {<br>
         * return std::abs(a) < std::abs(b);<br>
         * });<br>
         * }<br>
         * \endcode<br>
         * \brief Represents a C++ lambda expression that produces a local function<br>
         * object.<br>
         * * \code<br>
         * void abssort(float *x, unsigned N) {<br>
         * std::sort(x, x + N,<br>
         * [](float a, float b) {<br>
         * return std::abs(a) < std::abs(b);<br>
         * });<br>
         * }<br>
         * \endcode<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1824</i>
         */
        public static final int CXCursor_LambdaExpr = (int) 144;
        /**
         * \brief Objective-c Boolean Literal.<br>
         * \brief Objective-c Boolean Literal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1828</i>
         */
        public static final int CXCursor_ObjCBoolLiteralExpr = (int) 145;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1830</i>
        public static final int CXCursor_LastExpr = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_ObjCBoolLiteralExpr);
        /**
         * Statements<br>
         * Statements<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1833</i>
         */
        public static final int CXCursor_FirstStmt = (int) 200;
        /**
         * \brief A statement whose specific kind is not exposed via this<br>
         * interface.<br>
         * * Unexposed statements have the same operations as any other kind of<br>
         * statement; one can extract their location information, spelling,<br>
         * children, etc. However, the specific kind of the statement is not<br>
         * reported.<br>
         * \brief A statement whose specific kind is not exposed via this<br>
         * interface.<br>
         * * Unexposed statements have the same operations as any other kind of<br>
         * statement; one can extract their location information, spelling,<br>
         * children, etc. However, the specific kind of the statement is not<br>
         * reported.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1843</i>
         */
        public static final int CXCursor_UnexposedStmt = (int) 200;
        /**
         * \brief A labelled statement in a function. <br>
         * * This cursor kind is used to describe the "start_over:" label statement in <br>
         * the following example:<br>
         * * \code<br>
         * start_over:<br>
         * ++counter;<br>
         * \endcode<br>
         * \brief A labelled statement in a function. <br>
         * * This cursor kind is used to describe the "start_over:" label statement in <br>
         * the following example:<br>
         * * \code<br>
         * start_over:<br>
         * ++counter;<br>
         * \endcode<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1856</i>
         */
        public static final int CXCursor_LabelStmt = (int) 201;
        /**
         * \brief A group of statements like { stmt stmt }.<br>
         * * This cursor kind is used to describe compound statements, e.g. function<br>
         * bodies.<br>
         * \brief A group of statements like { stmt stmt }.<br>
         * * This cursor kind is used to describe compound statements, e.g. function<br>
         * bodies.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1863</i>
         */
        public static final int CXCursor_CompoundStmt = (int) 202;
        /**
         * \brief A case statment.<br>
         * \brief A case statment.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1867</i>
         */
        public static final int CXCursor_CaseStmt = (int) 203;
        /**
         * \brief A default statement.<br>
         * \brief A default statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1871</i>
         */
        public static final int CXCursor_DefaultStmt = (int) 204;
        /**
         * \brief An if statement<br>
         * \brief An if statement<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1875</i>
         */
        public static final int CXCursor_IfStmt = (int) 205;
        /**
         * \brief A switch statement.<br>
         * \brief A switch statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1879</i>
         */
        public static final int CXCursor_SwitchStmt = (int) 206;
        /**
         * \brief A while statement.<br>
         * \brief A while statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1883</i>
         */
        public static final int CXCursor_WhileStmt = (int) 207;
        /**
         * \brief A do statement.<br>
         * \brief A do statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1887</i>
         */
        public static final int CXCursor_DoStmt = (int) 208;
        /**
         * \brief A for statement.<br>
         * \brief A for statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1891</i>
         */
        public static final int CXCursor_ForStmt = (int) 209;
        /**
         * \brief A goto statement.<br>
         * \brief A goto statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1895</i>
         */
        public static final int CXCursor_GotoStmt = (int) 210;
        /**
         * \brief An indirect goto statement.<br>
         * \brief An indirect goto statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1899</i>
         */
        public static final int CXCursor_IndirectGotoStmt = (int) 211;
        /**
         * \brief A continue statement.<br>
         * \brief A continue statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1903</i>
         */
        public static final int CXCursor_ContinueStmt = (int) 212;
        /**
         * \brief A break statement.<br>
         * \brief A break statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1907</i>
         */
        public static final int CXCursor_BreakStmt = (int) 213;
        /**
         * \brief A return statement.<br>
         * \brief A return statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1911</i>
         */
        public static final int CXCursor_ReturnStmt = (int) 214;
        /**
         * \brief A GCC inline assembly statement extension.<br>
         * \brief A GCC inline assembly statement extension.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1915</i>
         */
        public static final int CXCursor_GCCAsmStmt = (int) 215;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1916</i>
        public static final int CXCursor_AsmStmt = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_GCCAsmStmt);
        /**
         * \brief Objective-C's overall \@try-\@catch-\@finally statement.<br>
         * \brief Objective-C's overall \@try-\@catch-\@finally statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1920</i>
         */
        public static final int CXCursor_ObjCAtTryStmt = (int) 216;
        /**
         * \brief Objective-C's \@catch statement.<br>
         * \brief Objective-C's \@catch statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1924</i>
         */
        public static final int CXCursor_ObjCAtCatchStmt = (int) 217;
        /**
         * \brief Objective-C's \@finally statement.<br>
         * \brief Objective-C's \@finally statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1928</i>
         */
        public static final int CXCursor_ObjCAtFinallyStmt = (int) 218;
        /**
         * \brief Objective-C's \@throw statement.<br>
         * \brief Objective-C's \@throw statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1932</i>
         */
        public static final int CXCursor_ObjCAtThrowStmt = (int) 219;
        /**
         * \brief Objective-C's \@synchronized statement.<br>
         * \brief Objective-C's \@synchronized statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1936</i>
         */
        public static final int CXCursor_ObjCAtSynchronizedStmt = (int) 220;
        /**
         * \brief Objective-C's autorelease pool statement.<br>
         * \brief Objective-C's autorelease pool statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1940</i>
         */
        public static final int CXCursor_ObjCAutoreleasePoolStmt = (int) 221;
        /**
         * \brief Objective-C's collection statement.<br>
         * \brief Objective-C's collection statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1944</i>
         */
        public static final int CXCursor_ObjCForCollectionStmt = (int) 222;
        /**
         * \brief C++'s catch statement.<br>
         * \brief C++'s catch statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1948</i>
         */
        public static final int CXCursor_CXXCatchStmt = (int) 223;
        /**
         * \brief C++'s try statement.<br>
         * \brief C++'s try statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1952</i>
         */
        public static final int CXCursor_CXXTryStmt = (int) 224;
        /**
         * \brief C++'s for (* : *) statement.<br>
         * \brief C++'s for (* : *) statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1956</i>
         */
        public static final int CXCursor_CXXForRangeStmt = (int) 225;
        /**
         * \brief Windows Structured Exception Handling's try statement.<br>
         * \brief Windows Structured Exception Handling's try statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1960</i>
         */
        public static final int CXCursor_SEHTryStmt = (int) 226;
        /**
         * \brief Windows Structured Exception Handling's except statement.<br>
         * \brief Windows Structured Exception Handling's except statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1964</i>
         */
        public static final int CXCursor_SEHExceptStmt = (int) 227;
        /**
         * \brief Windows Structured Exception Handling's finally statement.<br>
         * \brief Windows Structured Exception Handling's finally statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1968</i>
         */
        public static final int CXCursor_SEHFinallyStmt = (int) 228;
        /**
         * \brief A MS inline assembly statement extension.<br>
         * \brief A MS inline assembly statement extension.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1972</i>
         */
        public static final int CXCursor_MSAsmStmt = (int) 229;
        /**
         * \brief The null satement ";": C99 6.8.3p3.<br>
         * * This cursor kind is used to describe the null statement.<br>
         * \brief The null satement ";": C99 6.8.3p3.<br>
         * * This cursor kind is used to describe the null statement.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1978</i>
         */
        public static final int CXCursor_NullStmt = (int) 230;
        /**
         * \brief Adaptor class for mixing declarations with statements and<br>
         * expressions.<br>
         * \brief Adaptor class for mixing declarations with statements and<br>
         * expressions.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1983</i>
         */
        public static final int CXCursor_DeclStmt = (int) 231;
        /// <i>native declaration : src/main/c/clang-c/Index.h:1985</i>
        public static final int CXCursor_LastStmt = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_DeclStmt);
        /**
         * \brief Cursor that represents the translation unit itself.<br>
         * * The translation unit cursor exists primarily to act as the root<br>
         * cursor for traversing the contents of a translation unit.<br>
         * \brief Cursor that represents the translation unit itself.<br>
         * * The translation unit cursor exists primarily to act as the root<br>
         * cursor for traversing the contents of a translation unit.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1993</i>
         */
        public static final int CXCursor_TranslationUnit = (int) 300;
        /**
         * Attribute<br>
         * Attribute<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:1996</i>
         */
        public static final int CXCursor_FirstAttr = (int) 400;
        /**
         * \brief An attribute whose specific kind is not exposed via this<br>
         * interface.<br>
         * \brief An attribute whose specific kind is not exposed via this<br>
         * interface.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2001</i>
         */
        public static final int CXCursor_UnexposedAttr = (int) 400;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2003</i>
        public static final int CXCursor_IBActionAttr = (int) 401;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2004</i>
        public static final int CXCursor_IBOutletAttr = (int) 402;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2005</i>
        public static final int CXCursor_IBOutletCollectionAttr = (int) 403;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2006</i>
        public static final int CXCursor_CXXFinalAttr = (int) 404;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2007</i>
        public static final int CXCursor_CXXOverrideAttr = (int) 405;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2008</i>
        public static final int CXCursor_AnnotateAttr = (int) 406;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2009</i>
        public static final int CXCursor_AsmLabelAttr = (int) 407;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2010</i>
        public static final int CXCursor_LastAttr = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_AsmLabelAttr);
        /**
         * Preprocessing<br>
         * Preprocessing<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2013</i>
         */
        public static final int CXCursor_PreprocessingDirective = (int) 500;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2014</i>
        public static final int CXCursor_MacroDefinition = (int) 501;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2015</i>
        public static final int CXCursor_MacroExpansion = (int) 502;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2016</i>
        public static final int CXCursor_MacroInstantiation = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_MacroExpansion);
        /// <i>native declaration : src/main/c/clang-c/Index.h:2017</i>
        public static final int CXCursor_InclusionDirective = (int) 503;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2018</i>
        public static final int CXCursor_FirstPreprocessing = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_PreprocessingDirective);
        /// <i>native declaration : src/main/c/clang-c/Index.h:2019</i>
        public static final int CXCursor_LastPreprocessing = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_InclusionDirective);
        /**
         * \brief A module import declaration.<br>
         * \brief A module import declaration.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2025</i>
         */
        public static final int CXCursor_ModuleImportDecl = (int) 600;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2026</i>
        public static final int CXCursor_FirstExtraDecl = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_ModuleImportDecl);
        /// <i>native declaration : src/main/c/clang-c/Index.h:2027</i>
        public static final int CXCursor_LastExtraDecl = (int) ((int) ClangLibrary.CXCursorKind.CXCursor_ModuleImportDecl);
    }
    /**
     * \brief Describe the linkage of the entity referred to by a cursor.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2158</i><br>
     * enum values
     */
    /**
     * \brief Describe the linkage of the entity referred to by a cursor.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2158</i><br>
     * enum values
     */
    public static interface CXLinkageKind {
        /**
         * \brief This value indicates that no linkage information is available<br>
         * for a provided CXCursor.<br>
         * \brief This value indicates that no linkage information is available<br>
         * for a provided CXCursor.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2161</i>
         */
        public static final int CXLinkage_Invalid = (int) 0;
        /**
         * \brief This is the linkage for variables, parameters, and so on that<br>
         * have automatic storage.  This covers normal (non-extern) local variables.<br>
         * \brief This is the linkage for variables, parameters, and so on that<br>
         * have automatic storage.  This covers normal (non-extern) local variables.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2166</i>
         */
        public static final int CXLinkage_NoLinkage = (int) 1;
        /**
         * \brief This is the linkage for static variables and static functions.<br>
         * \brief This is the linkage for static variables and static functions.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2168</i>
         */
        public static final int CXLinkage_Internal = (int) 2;
        /**
         * \brief This is the linkage for entities with external linkage that live<br>
         * in C++ anonymous namespaces.<br>
         * \brief This is the linkage for entities with external linkage that live<br>
         * in C++ anonymous namespaces.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2171</i>
         */
        public static final int CXLinkage_UniqueExternal = (int) 3;
        /**
         * \brief This is the linkage for entities with true, external linkage.<br>
         * \brief This is the linkage for entities with true, external linkage.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2173</i>
         */
        public static final int CXLinkage_External = (int) 4;
    }
    /**
     * \brief Describe the "language" of the entity referred to by a cursor.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2283</i><br>
     * enum values
     */
    /**
     * \brief Describe the "language" of the entity referred to by a cursor.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2283</i><br>
     * enum values
     */
    public static interface CXLanguageKind {
        /// <i>native declaration : src/main/c/clang-c/Index.h:2284</i>
        public static final int CXLanguage_Invalid = (int) 0;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2285</i>
        public static final int CXLanguage_C = (int) 1;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2286</i>
        public static final int CXLanguage_ObjC = (int) 2;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2287</i>
        public static final int CXLanguage_CPlusPlus = (int) 3;
    }
    /**
     * \brief Describes the kind of type<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2532</i><br>
     * enum values
     */
    /**
     * \brief Describes the kind of type<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2532</i><br>
     * enum values
     */
    public static interface CXTypeKind {
        /**
         * \brief Reprents an invalid type (e.g., where no type is available).<br>
         * \brief Reprents an invalid type (e.g., where no type is available).<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2536</i>
         */
        public static final int CXType_Invalid = (int) 0;
        /**
         * \brief A type whose specific kind is not exposed via this<br>
         * interface.<br>
         * \brief A type whose specific kind is not exposed via this<br>
         * interface.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2542</i>
         */
        public static final int CXType_Unexposed = (int) 1;
        /**
         * Builtin types<br>
         * Builtin types<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2545</i>
         */
        public static final int CXType_Void = (int) 2;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2546</i>
        public static final int CXType_Bool = (int) 3;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2547</i>
        public static final int CXType_Char_U = (int) 4;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2548</i>
        public static final int CXType_UChar = (int) 5;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2549</i>
        public static final int CXType_Char16 = (int) 6;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2550</i>
        public static final int CXType_Char32 = (int) 7;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2551</i>
        public static final int CXType_UShort = (int) 8;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2552</i>
        public static final int CXType_UInt = (int) 9;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2553</i>
        public static final int CXType_ULong = (int) 10;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2554</i>
        public static final int CXType_ULongLong = (int) 11;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2555</i>
        public static final int CXType_UInt128 = (int) 12;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2556</i>
        public static final int CXType_Char_S = (int) 13;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2557</i>
        public static final int CXType_SChar = (int) 14;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2558</i>
        public static final int CXType_WChar = (int) 15;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2559</i>
        public static final int CXType_Short = (int) 16;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2560</i>
        public static final int CXType_Int = (int) 17;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2561</i>
        public static final int CXType_Long = (int) 18;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2562</i>
        public static final int CXType_LongLong = (int) 19;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2563</i>
        public static final int CXType_Int128 = (int) 20;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2564</i>
        public static final int CXType_Float = (int) 21;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2565</i>
        public static final int CXType_Double = (int) 22;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2566</i>
        public static final int CXType_LongDouble = (int) 23;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2567</i>
        public static final int CXType_NullPtr = (int) 24;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2568</i>
        public static final int CXType_Overload = (int) 25;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2569</i>
        public static final int CXType_Dependent = (int) 26;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2570</i>
        public static final int CXType_ObjCId = (int) 27;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2571</i>
        public static final int CXType_ObjCClass = (int) 28;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2572</i>
        public static final int CXType_ObjCSel = (int) 29;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2573</i>
        public static final int CXType_FirstBuiltin = (int) ((int) ClangLibrary.CXTypeKind.CXType_Void);
        /// <i>native declaration : src/main/c/clang-c/Index.h:2574</i>
        public static final int CXType_LastBuiltin = (int) ((int) ClangLibrary.CXTypeKind.CXType_ObjCSel);
        /// <i>native declaration : src/main/c/clang-c/Index.h:2576</i>
        public static final int CXType_Complex = (int) 100;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2577</i>
        public static final int CXType_Pointer = (int) 101;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2578</i>
        public static final int CXType_BlockPointer = (int) 102;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2579</i>
        public static final int CXType_LValueReference = (int) 103;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2580</i>
        public static final int CXType_RValueReference = (int) 104;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2581</i>
        public static final int CXType_Record = (int) 105;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2582</i>
        public static final int CXType_Enum = (int) 106;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2583</i>
        public static final int CXType_Typedef = (int) 107;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2584</i>
        public static final int CXType_ObjCInterface = (int) 108;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2585</i>
        public static final int CXType_ObjCObjectPointer = (int) 109;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2586</i>
        public static final int CXType_FunctionNoProto = (int) 110;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2587</i>
        public static final int CXType_FunctionProto = (int) 111;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2588</i>
        public static final int CXType_ConstantArray = (int) 112;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2589</i>
        public static final int CXType_Vector = (int) 113;
    }
    /**
     * \brief Describes the calling convention of a function type<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2595</i><br>
     * enum values
     */
    /**
     * \brief Describes the calling convention of a function type<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2595</i><br>
     * enum values
     */
    public static interface CXCallingConv {
        /// <i>native declaration : src/main/c/clang-c/Index.h:2596</i>
        public static final int CXCallingConv_Default = (int) 0;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2597</i>
        public static final int CXCallingConv_C = (int) 1;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2598</i>
        public static final int CXCallingConv_X86StdCall = (int) 2;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2599</i>
        public static final int CXCallingConv_X86FastCall = (int) 3;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2600</i>
        public static final int CXCallingConv_X86ThisCall = (int) 4;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2601</i>
        public static final int CXCallingConv_X86Pascal = (int) 5;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2602</i>
        public static final int CXCallingConv_AAPCS = (int) 6;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2603</i>
        public static final int CXCallingConv_AAPCS_VFP = (int) 7;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2604</i>
        public static final int CXCallingConv_PnaclCall = (int) 8;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2606</i>
        public static final int CXCallingConv_Invalid = (int) 100;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2607</i>
        public static final int CXCallingConv_Unexposed = (int) 200;
    }
    /**
     * \brief Represents the C++ access control level to a base class for a<br>
     * cursor with kind CX_CXXBaseSpecifier.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2831</i><br>
     * enum values
     */
    /**
     * \brief Represents the C++ access control level to a base class for a<br>
     * cursor with kind CX_CXXBaseSpecifier.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2831</i><br>
     * enum values
     */
    public static interface CX_CXXAccessSpecifier {
        /// <i>native declaration : src/main/c/clang-c/Index.h:2832</i>
        public static final int CX_CXXInvalidAccessSpecifier = (int) 0;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2833</i>
        public static final int CX_CXXPublic = (int) 1;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2834</i>
        public static final int CX_CXXProtected = (int) 2;
        /// <i>native declaration : src/main/c/clang-c/Index.h:2835</i>
        public static final int CX_CXXPrivate = (int) 3;
    }
    /**
     * \brief Describes how the traversal of the children of a particular<br>
     * cursor should proceed after visiting a particular child cursor.<br>
     * * A value of this enumeration type should be returned by each<br>
     * \c CXCursorVisitor to indicate how clang_visitChildren() proceed.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2911</i><br>
     * enum values
     */
    /**
     * \brief Describes how the traversal of the children of a particular<br>
     * cursor should proceed after visiting a particular child cursor.<br>
     * * A value of this enumeration type should be returned by each<br>
     * \c CXCursorVisitor to indicate how clang_visitChildren() proceed.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2911</i><br>
     * enum values
     */
    public static interface CXChildVisitResult {
        /**
         * \brief Terminates the cursor traversal.<br>
         * \brief Terminates the cursor traversal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2915</i>
         */
        public static final int CXChildVisit_Break = (int) 0;
        /**
         * \brief Continues the cursor traversal with the next sibling of<br>
         * the cursor just visited, without visiting its children.<br>
         * \brief Continues the cursor traversal with the next sibling of<br>
         * the cursor just visited, without visiting its children.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2920</i>
         */
        public static final int CXChildVisit_Continue = (int) 1;
        /**
         * \brief Recursively traverse the children of this cursor, using<br>
         * the same visitor and client data.<br>
         * \brief Recursively traverse the children of this cursor, using<br>
         * the same visitor and client data.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:2925</i>
         */
        public static final int CXChildVisit_Recurse = (int) 2;
    }
    /**
     * \brief Describes the type of the comment AST node (\c CXComment).  A comment<br>
     * node can be considered block content (e. g., paragraph), inline content<br>
     * (plain text) or neither (the root AST node).<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3300</i><br>
     * enum values
     */
    /**
     * \brief Describes the type of the comment AST node (\c CXComment).  A comment<br>
     * node can be considered block content (e. g., paragraph), inline content<br>
     * (plain text) or neither (the root AST node).<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3300</i><br>
     * enum values
     */
    public static interface CXCommentKind {
        /**
         * \brief Null comment.  No AST node is constructed at the requested location<br>
         * because there is no text or a syntax error.<br>
         * \brief Null comment.  No AST node is constructed at the requested location<br>
         * because there is no text or a syntax error.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3305</i>
         */
        public static final int CXComment_Null = (int) 0;
        /**
         * \brief Plain text.  Inline content.<br>
         * \brief Plain text.  Inline content.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3310</i>
         */
        public static final int CXComment_Text = (int) 1;
        /**
         * \brief A command with word-like arguments that is considered inline content.<br>
         * * For example: \\c command.<br>
         * \brief A command with word-like arguments that is considered inline content.<br>
         * * For example: \\c command.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3317</i>
         */
        public static final int CXComment_InlineCommand = (int) 2;
        /**
         * \brief HTML start tag with attributes (name-value pairs).  Considered<br>
         * inline content.<br>
         * * For example:<br>
         * \verbatim<br>
         * <br> <br /> <a href="http://example.org/"><br>
         * \endverbatim<br>
         * \brief HTML start tag with attributes (name-value pairs).  Considered<br>
         * inline content.<br>
         * * For example:<br>
         * \verbatim<br>
         * <br> <br /> <a href="http://example.org/"><br>
         * \endverbatim<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3328</i>
         */
        public static final int CXComment_HTMLStartTag = (int) 3;
        /**
         * \brief HTML end tag.  Considered inline content.<br>
         * * For example:<br>
         * \verbatim<br>
         * </a><br>
         * \endverbatim<br>
         * \brief HTML end tag.  Considered inline content.<br>
         * * For example:<br>
         * \verbatim<br>
         * </a><br>
         * \endverbatim<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3338</i>
         */
        public static final int CXComment_HTMLEndTag = (int) 4;
        /**
         * \brief A paragraph, contains inline comment.  The paragraph itself is<br>
         * block content.<br>
         * \brief A paragraph, contains inline comment.  The paragraph itself is<br>
         * block content.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3344</i>
         */
        public static final int CXComment_Paragraph = (int) 5;
        /**
         * \brief A command that has zero or more word-like arguments (number of<br>
         * word-like arguments depends on command name) and a paragraph as an<br>
         * argument.  Block command is block content.<br>
         * * Paragraph argument is also a child of the block command.<br>
         * * For example: \\brief has 0 word-like arguments and a paragraph argument.<br>
         * * AST nodes of special kinds that parser knows about (e. g., \\param<br>
         * command) have their own node kinds.<br>
         * \brief A command that has zero or more word-like arguments (number of<br>
         * word-like arguments depends on command name) and a paragraph as an<br>
         * argument.  Block command is block content.<br>
         * * Paragraph argument is also a child of the block command.<br>
         * * For example: \\brief has 0 word-like arguments and a paragraph argument.<br>
         * * AST nodes of special kinds that parser knows about (e. g., \\param<br>
         * command) have their own node kinds.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3358</i>
         */
        public static final int CXComment_BlockCommand = (int) 6;
        /**
         * \brief A \\param or \\arg command that describes the function parameter<br>
         * (name, passing direction, description).<br>
         * * For example: \\param [in] ParamName description.<br>
         * \brief A \\param or \\arg command that describes the function parameter<br>
         * (name, passing direction, description).<br>
         * * For example: \\param [in] ParamName description.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3366</i>
         */
        public static final int CXComment_ParamCommand = (int) 7;
        /**
         * \brief A \\tparam command that describes a template parameter (name and<br>
         * description).<br>
         * * For example: \\tparam T description.<br>
         * \brief A \\tparam command that describes a template parameter (name and<br>
         * description).<br>
         * * For example: \\tparam T description.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3374</i>
         */
        public static final int CXComment_TParamCommand = (int) 8;
        /**
         * \brief A verbatim block command (e. g., preformatted code).  Verbatim<br>
         * block has an opening and a closing command and contains multiple lines of<br>
         * text (\c CXComment_VerbatimBlockLine child nodes).<br>
         * * For example:<br>
         * \\verbatim<br>
         * aaa<br>
         * \\endverbatim<br>
         * \brief A verbatim block command (e. g., preformatted code).  Verbatim<br>
         * block has an opening and a closing command and contains multiple lines of<br>
         * text (\c CXComment_VerbatimBlockLine child nodes).<br>
         * * For example:<br>
         * \\verbatim<br>
         * aaa<br>
         * \\endverbatim<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3386</i>
         */
        public static final int CXComment_VerbatimBlockCommand = (int) 9;
        /**
         * \brief A line of text that is contained within a<br>
         * CXComment_VerbatimBlockCommand node.<br>
         * \brief A line of text that is contained within a<br>
         * CXComment_VerbatimBlockCommand node.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3392</i>
         */
        public static final int CXComment_VerbatimBlockLine = (int) 10;
        /**
         * \brief A verbatim line command.  Verbatim line has an opening command,<br>
         * a single line of text (up to the newline after the opening command) and<br>
         * has no closing command.<br>
         * \brief A verbatim line command.  Verbatim line has an opening command,<br>
         * a single line of text (up to the newline after the opening command) and<br>
         * has no closing command.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3399</i>
         */
        public static final int CXComment_VerbatimLine = (int) 11;
        /**
         * \brief A full comment attached to a declaration, contains block content.<br>
         * \brief A full comment attached to a declaration, contains block content.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3404</i>
         */
        public static final int CXComment_FullComment = (int) 12;
    }
    /**
     * \brief The most appropriate rendering mode for an inline command, chosen on<br>
     * command semantics in Doxygen.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3411</i><br>
     * enum values
     */
    /**
     * \brief The most appropriate rendering mode for an inline command, chosen on<br>
     * command semantics in Doxygen.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3411</i><br>
     * enum values
     */
    public static interface CXCommentInlineCommandRenderKind {
        /**
         * \brief Command argument should be rendered in a normal font.<br>
         * \brief Command argument should be rendered in a normal font.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3415</i>
         */
        public static final int CXCommentInlineCommandRenderKind_Normal = (int) 0;
        /**
         * \brief Command argument should be rendered in a bold font.<br>
         * \brief Command argument should be rendered in a bold font.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3420</i>
         */
        public static final int CXCommentInlineCommandRenderKind_Bold = (int) 1;
        /**
         * \brief Command argument should be rendered in a monospaced font.<br>
         * \brief Command argument should be rendered in a monospaced font.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3425</i>
         */
        public static final int CXCommentInlineCommandRenderKind_Monospaced = (int) 2;
        /**
         * \brief Command argument should be rendered emphasized (typically italic<br>
         * font).<br>
         * \brief Command argument should be rendered emphasized (typically italic<br>
         * font).<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3431</i>
         */
        public static final int CXCommentInlineCommandRenderKind_Emphasized = (int) 3;
    }
    /**
     * \brief Describes parameter passing direction for \\param or \\arg command.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3437</i><br>
     * enum values
     */
    /**
     * \brief Describes parameter passing direction for \\param or \\arg command.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3437</i><br>
     * enum values
     */
    public static interface CXCommentParamPassDirection {
        /**
         * \brief The parameter is an input parameter.<br>
         * \brief The parameter is an input parameter.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3441</i>
         */
        public static final int CXCommentParamPassDirection_In = (int) 0;
        /**
         * \brief The parameter is an output parameter.<br>
         * \brief The parameter is an output parameter.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3446</i>
         */
        public static final int CXCommentParamPassDirection_Out = (int) 1;
        /**
         * \brief The parameter is an input and output parameter.<br>
         * \brief The parameter is an input and output parameter.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3451</i>
         */
        public static final int CXCommentParamPassDirection_InOut = (int) 2;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h:3887</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h:3887</i><br>
     * enum values
     */
    public static interface CXNameRefFlags {
        /**
         * \brief Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the<br>
         * range.<br>
         * \brief Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the<br>
         * range.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3892</i>
         */
        public static final int CXNameRange_WantQualifier = (int) 1;
        /**
         * \brief Include the explicit template arguments, e.g. \<int> in x.f<int>,<br>
         * in the range.<br>
         * \brief Include the explicit template arguments, e.g. \<int> in x.f<int>,<br>
         * in the range.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3898</i>
         */
        public static final int CXNameRange_WantTemplateArgs = (int) 2;
        /**
         * \brief If the name is non-contiguous, return the full spanning range.<br>
         * * Non-contiguous names occur in Objective-C when a selector with two or more<br>
         * parameters is used, or in C++ when using an operator:<br>
         * \code<br>
         * [object doSomething:here withValue:there]; // ObjC<br>
         * return some_vector[1]; // C++<br>
         * \endcode<br>
         * \brief If the name is non-contiguous, return the full spanning range.<br>
         * * Non-contiguous names occur in Objective-C when a selector with two or more<br>
         * parameters is used, or in C++ when using an operator:<br>
         * \code<br>
         * [object doSomething:here withValue:there]; // ObjC<br>
         * return some_vector[1]; // C++<br>
         * \endcode<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3910</i>
         */
        public static final int CXNameRange_WantSinglePiece = (int) 4;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    public static interface CXTokenKind {
        /**
         * \brief A token that contains some kind of punctuation.<br>
         * \brief A token that contains some kind of punctuation.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3934</i>
         */
        public static final int CXToken_Punctuation = (int) 0;
        /**
         * \brief A language keyword.<br>
         * \brief A language keyword.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3939</i>
         */
        public static final int CXToken_Keyword = (int) 1;
        /**
         * \brief An identifier (that is not a keyword).<br>
         * \brief An identifier (that is not a keyword).<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3944</i>
         */
        public static final int CXToken_Identifier = (int) 2;
        /**
         * \brief A numeric, string, or character literal.<br>
         * \brief A numeric, string, or character literal.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3949</i>
         */
        public static final int CXToken_Literal = (int) 3;
        /**
         * \brief A comment.<br>
         * \brief A comment.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:3954</i>
         */
        public static final int CXToken_Comment = (int) 4;
    }
    /**
     * \brief Describes a single piece of text within a code-completion string.<br>
     * * Each "chunk" within a code-completion string (\c CXCompletionString) is<br>
     * either a piece of text with a specific "kind" that describes how that text<br>
     * should be interpreted by the client or is another completion string.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4136</i><br>
     * enum values
     */
    /**
     * \brief Describes a single piece of text within a code-completion string.<br>
     * * Each "chunk" within a code-completion string (\c CXCompletionString) is<br>
     * either a piece of text with a specific "kind" that describes how that text<br>
     * should be interpreted by the client or is another completion string.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4136</i><br>
     * enum values
     */
    public static interface CXCompletionChunkKind {
        /**
         * \brief A code-completion string that describes "optional" text that<br>
         * could be a part of the template (but is not required).<br>
         * * The Optional chunk is the only kind of chunk that has a code-completion<br>
         * string for its representation, which is accessible via<br>
         * \c clang_getCompletionChunkCompletionString(). The code-completion string<br>
         * describes an additional part of the template that is completely optional.<br>
         * For example, optional chunks can be used to describe the placeholders for<br>
         * arguments that match up with defaulted function parameters, e.g. given:<br>
         * * \code<br>
         * void f(int x, float y = 3.14, double z = 2.71828);<br>
         * \endcode<br>
         * * The code-completion string for this function would contain:<br>
         * - a TypedText chunk for "f".<br>
         * - a LeftParen chunk for "(".<br>
         * - a Placeholder chunk for "int x"<br>
         * - an Optional chunk containing the remaining defaulted arguments, e.g.,<br>
         * - a Comma chunk for ","<br>
         * - a Placeholder chunk for "float y"<br>
         * - an Optional chunk containing the last defaulted argument:<br>
         * - a Comma chunk for ","<br>
         * - a Placeholder chunk for "double z"<br>
         * - a RightParen chunk for ")"<br>
         * * There are many ways to handle Optional chunks. Two simple approaches are:<br>
         * - Completely ignore optional chunks, in which case the template for the<br>
         * function "f" would only include the first parameter ("int x").<br>
         * - Fully expand all optional chunks, in which case the template for the<br>
         * function "f" would have all of the parameters.<br>
         * \brief A code-completion string that describes "optional" text that<br>
         * could be a part of the template (but is not required).<br>
         * * The Optional chunk is the only kind of chunk that has a code-completion<br>
         * string for its representation, which is accessible via<br>
         * \c clang_getCompletionChunkCompletionString(). The code-completion string<br>
         * describes an additional part of the template that is completely optional.<br>
         * For example, optional chunks can be used to describe the placeholders for<br>
         * arguments that match up with defaulted function parameters, e.g. given:<br>
         * * \code<br>
         * void f(int x, float y = 3.14, double z = 2.71828);<br>
         * \endcode<br>
         * * The code-completion string for this function would contain:<br>
         * - a TypedText chunk for "f".<br>
         * - a LeftParen chunk for "(".<br>
         * - a Placeholder chunk for "int x"<br>
         * - an Optional chunk containing the remaining defaulted arguments, e.g.,<br>
         * - a Comma chunk for ","<br>
         * - a Placeholder chunk for "float y"<br>
         * - an Optional chunk containing the last defaulted argument:<br>
         * - a Comma chunk for ","<br>
         * - a Placeholder chunk for "double z"<br>
         * - a RightParen chunk for ")"<br>
         * * There are many ways to handle Optional chunks. Two simple approaches are:<br>
         * - Completely ignore optional chunks, in which case the template for the<br>
         * function "f" would only include the first parameter ("int x").<br>
         * - Fully expand all optional chunks, in which case the template for the<br>
         * function "f" would have all of the parameters.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4170</i>
         */
        public static final int CXCompletionChunk_Optional = (int) 0;
        /**
         * \brief Text that a user would be expected to type to get this<br>
         * code-completion result.<br>
         * * There will be exactly one "typed text" chunk in a semantic string, which<br>
         * will typically provide the spelling of a keyword or the name of a<br>
         * declaration that could be used at the current code point. Clients are<br>
         * expected to filter the code-completion results based on the text in this<br>
         * chunk.<br>
         * \brief Text that a user would be expected to type to get this<br>
         * code-completion result.<br>
         * * There will be exactly one "typed text" chunk in a semantic string, which<br>
         * will typically provide the spelling of a keyword or the name of a<br>
         * declaration that could be used at the current code point. Clients are<br>
         * expected to filter the code-completion results based on the text in this<br>
         * chunk.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4181</i>
         */
        public static final int CXCompletionChunk_TypedText = (int) 1;
        /**
         * \brief Text that should be inserted as part of a code-completion result.<br>
         * * A "text" chunk represents text that is part of the template to be<br>
         * inserted into user code should this particular code-completion result<br>
         * be selected.<br>
         * \brief Text that should be inserted as part of a code-completion result.<br>
         * * A "text" chunk represents text that is part of the template to be<br>
         * inserted into user code should this particular code-completion result<br>
         * be selected.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4189</i>
         */
        public static final int CXCompletionChunk_Text = (int) 2;
        /**
         * \brief Placeholder text that should be replaced by the user.<br>
         * * A "placeholder" chunk marks a place where the user should insert text<br>
         * into the code-completion template. For example, placeholders might mark<br>
         * the function parameters for a function declaration, to indicate that the<br>
         * user should provide arguments for each of those parameters. The actual<br>
         * text in a placeholder is a suggestion for the text to display before<br>
         * the user replaces the placeholder with real code.<br>
         * \brief Placeholder text that should be replaced by the user.<br>
         * * A "placeholder" chunk marks a place where the user should insert text<br>
         * into the code-completion template. For example, placeholders might mark<br>
         * the function parameters for a function declaration, to indicate that the<br>
         * user should provide arguments for each of those parameters. The actual<br>
         * text in a placeholder is a suggestion for the text to display before<br>
         * the user replaces the placeholder with real code.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4200</i>
         */
        public static final int CXCompletionChunk_Placeholder = (int) 3;
        /**
         * \brief Informative text that should be displayed but never inserted as<br>
         * part of the template.<br>
         * * An "informative" chunk contains annotations that can be displayed to<br>
         * help the user decide whether a particular code-completion result is the<br>
         * right option, but which is not part of the actual template to be inserted<br>
         * by code completion.<br>
         * \brief Informative text that should be displayed but never inserted as<br>
         * part of the template.<br>
         * * An "informative" chunk contains annotations that can be displayed to<br>
         * help the user decide whether a particular code-completion result is the<br>
         * right option, but which is not part of the actual template to be inserted<br>
         * by code completion.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4210</i>
         */
        public static final int CXCompletionChunk_Informative = (int) 4;
        /**
         * \brief Text that describes the current parameter when code-completion is<br>
         * referring to function call, message send, or template specialization.<br>
         * * A "current parameter" chunk occurs when code-completion is providing<br>
         * information about a parameter corresponding to the argument at the<br>
         * code-completion point. For example, given a function<br>
         * * \code<br>
         * int add(int x, int y);<br>
         * \endcode<br>
         * * and the source code \c add(, where the code-completion point is after the<br>
         * "(", the code-completion string will contain a "current parameter" chunk<br>
         * for "int x", indicating that the current argument will initialize that<br>
         * parameter. After typing further, to \c add(17, (where the code-completion<br>
         * point is after the ","), the code-completion string will contain a<br>
         * "current paremeter" chunk to "int y".<br>
         * \brief Text that describes the current parameter when code-completion is<br>
         * referring to function call, message send, or template specialization.<br>
         * * A "current parameter" chunk occurs when code-completion is providing<br>
         * information about a parameter corresponding to the argument at the<br>
         * code-completion point. For example, given a function<br>
         * * \code<br>
         * int add(int x, int y);<br>
         * \endcode<br>
         * * and the source code \c add(, where the code-completion point is after the<br>
         * "(", the code-completion string will contain a "current parameter" chunk<br>
         * for "int x", indicating that the current argument will initialize that<br>
         * parameter. After typing further, to \c add(17, (where the code-completion<br>
         * point is after the ","), the code-completion string will contain a<br>
         * "current paremeter" chunk to "int y".<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4230</i>
         */
        public static final int CXCompletionChunk_CurrentParameter = (int) 5;
        /**
         * \brief A left parenthesis ('('), used to initiate a function call or<br>
         * signal the beginning of a function parameter list.<br>
         * \brief A left parenthesis ('('), used to initiate a function call or<br>
         * signal the beginning of a function parameter list.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4235</i>
         */
        public static final int CXCompletionChunk_LeftParen = (int) 6;
        /**
         * \brief A right parenthesis (')'), used to finish a function call or<br>
         * signal the end of a function parameter list.<br>
         * \brief A right parenthesis (')'), used to finish a function call or<br>
         * signal the end of a function parameter list.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4240</i>
         */
        public static final int CXCompletionChunk_RightParen = (int) 7;
        /**
         * \brief A left bracket ('[').<br>
         * \brief A left bracket ('[').<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4244</i>
         */
        public static final int CXCompletionChunk_LeftBracket = (int) 8;
        /**
         * \brief A right bracket (']').<br>
         * \brief A right bracket (']').<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4248</i>
         */
        public static final int CXCompletionChunk_RightBracket = (int) 9;
        /**
         * \brief A left brace ('{').<br>
         * \brief A left brace ('{').<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4252</i>
         */
        public static final int CXCompletionChunk_LeftBrace = (int) 10;
        /**
         * \brief A right brace ('}').<br>
         * \brief A right brace ('}').<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4256</i>
         */
        public static final int CXCompletionChunk_RightBrace = (int) 11;
        /**
         * \brief A left angle bracket ('<').<br>
         * \brief A left angle bracket ('<').<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4260</i>
         */
        public static final int CXCompletionChunk_LeftAngle = (int) 12;
        /**
         * \brief A right angle bracket ('>').<br>
         * \brief A right angle bracket ('>').<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4264</i>
         */
        public static final int CXCompletionChunk_RightAngle = (int) 13;
        /**
         * \brief A comma separator (',').<br>
         * \brief A comma separator (',').<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4268</i>
         */
        public static final int CXCompletionChunk_Comma = (int) 14;
        /**
         * \brief Text that specifies the result type of a given result.<br>
         * * This special kind of informative chunk is not meant to be inserted into<br>
         * the text buffer. Rather, it is meant to illustrate the type that an<br>
         * expression using the given completion string would have.<br>
         * \brief Text that specifies the result type of a given result.<br>
         * * This special kind of informative chunk is not meant to be inserted into<br>
         * the text buffer. Rather, it is meant to illustrate the type that an<br>
         * expression using the given completion string would have.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4276</i>
         */
        public static final int CXCompletionChunk_ResultType = (int) 15;
        /**
         * \brief A colon (':').<br>
         * \brief A colon (':').<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4280</i>
         */
        public static final int CXCompletionChunk_Colon = (int) 16;
        /**
         * \brief A semicolon (';').<br>
         * \brief A semicolon (';').<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4284</i>
         */
        public static final int CXCompletionChunk_SemiColon = (int) 17;
        /**
         * \brief An '=' sign.<br>
         * \brief An '=' sign.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4288</i>
         */
        public static final int CXCompletionChunk_Equal = (int) 18;
        /**
         * Horizontal space (' ').<br>
         * Horizontal space (' ').<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4292</i>
         */
        public static final int CXCompletionChunk_HorizontalSpace = (int) 19;
        /**
         * Vertical space ('\n'), after which it is generally a good idea to<br>
         * perform indentation.<br>
         * Vertical space ('\n'), after which it is generally a good idea to<br>
         * perform indentation.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4297</i>
         */
        public static final int CXCompletionChunk_VerticalSpace = (int) 20;
    }
    /**
     * \brief Flags that can be passed to \c clang_codeCompleteAt() to<br>
     * modify its behavior.<br>
     * * The enumerators in this enumeration can be bitwise-OR'd together to<br>
     * provide multiple options to \c clang_codeCompleteAt().<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4467</i><br>
     * enum values
     */
    /**
     * \brief Flags that can be passed to \c clang_codeCompleteAt() to<br>
     * modify its behavior.<br>
     * * The enumerators in this enumeration can be bitwise-OR'd together to<br>
     * provide multiple options to \c clang_codeCompleteAt().<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4467</i><br>
     * enum values
     */
    public static interface CXCodeComplete_Flags {
        /**
         * \brief Whether to include macros within the set of code<br>
         * completions returned.<br>
         * \brief Whether to include macros within the set of code<br>
         * completions returned.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4472</i>
         */
        public static final int CXCodeComplete_IncludeMacros = (int) 1;
        /**
         * \brief Whether to include code patterns for language constructs<br>
         * within the set of code completions, e.g., for loops.<br>
         * \brief Whether to include code patterns for language constructs<br>
         * within the set of code completions, e.g., for loops.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4478</i>
         */
        public static final int CXCodeComplete_IncludeCodePatterns = (int) 2;
        /**
         * \brief Whether to include brief documentation within the set of code<br>
         * completions returned.<br>
         * \brief Whether to include brief documentation within the set of code<br>
         * completions returned.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4484</i>
         */
        public static final int CXCodeComplete_IncludeBriefComments = (int) 4;
    }
    /**
     * \brief Bits that represent the context under which completion is occurring.<br>
     * * The enumerators in this enumeration may be bitwise-OR'd together if multiple<br>
     * contexts are occurring simultaneously.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4493</i><br>
     * enum values
     */
    /**
     * \brief Bits that represent the context under which completion is occurring.<br>
     * * The enumerators in this enumeration may be bitwise-OR'd together if multiple<br>
     * contexts are occurring simultaneously.<br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4493</i><br>
     * enum values
     */
    public static interface CXCompletionContext {
        /**
         * \brief The context for completions is unexposed, as only Clang results<br>
         * should be included. (This is equivalent to having no context bits set.)<br>
         * \brief The context for completions is unexposed, as only Clang results<br>
         * should be included. (This is equivalent to having no context bits set.)<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4498</i>
         */
        public static final int CXCompletionContext_Unexposed = (int) 0;
        /**
         * \brief Completions for any possible type should be included in the results.<br>
         * \brief Completions for any possible type should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4503</i>
         */
        public static final int CXCompletionContext_AnyType = (int) (1 << 0);
        /**
         * \brief Completions for any possible value (variables, function calls, etc.)<br>
         * should be included in the results.<br>
         * \brief Completions for any possible value (variables, function calls, etc.)<br>
         * should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4509</i>
         */
        public static final int CXCompletionContext_AnyValue = (int) (1 << 1);
        /**
         * \brief Completions for values that resolve to an Objective-C object should<br>
         * be included in the results.<br>
         * \brief Completions for values that resolve to an Objective-C object should<br>
         * be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4514</i>
         */
        public static final int CXCompletionContext_ObjCObjectValue = (int) (1 << 2);
        /**
         * \brief Completions for values that resolve to an Objective-C selector<br>
         * should be included in the results.<br>
         * \brief Completions for values that resolve to an Objective-C selector<br>
         * should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4519</i>
         */
        public static final int CXCompletionContext_ObjCSelectorValue = (int) (1 << 3);
        /**
         * \brief Completions for values that resolve to a C++ class type should be<br>
         * included in the results.<br>
         * \brief Completions for values that resolve to a C++ class type should be<br>
         * included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4524</i>
         */
        public static final int CXCompletionContext_CXXClassTypeValue = (int) (1 << 4);
        /**
         * \brief Completions for fields of the member being accessed using the dot<br>
         * operator should be included in the results.<br>
         * \brief Completions for fields of the member being accessed using the dot<br>
         * operator should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4530</i>
         */
        public static final int CXCompletionContext_DotMemberAccess = (int) (1 << 5);
        /**
         * \brief Completions for fields of the member being accessed using the arrow<br>
         * operator should be included in the results.<br>
         * \brief Completions for fields of the member being accessed using the arrow<br>
         * operator should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4535</i>
         */
        public static final int CXCompletionContext_ArrowMemberAccess = (int) (1 << 6);
        /**
         * \brief Completions for properties of the Objective-C object being accessed<br>
         * using the dot operator should be included in the results.<br>
         * \brief Completions for properties of the Objective-C object being accessed<br>
         * using the dot operator should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4540</i>
         */
        public static final int CXCompletionContext_ObjCPropertyAccess = (int) (1 << 7);
        /**
         * \brief Completions for enum tags should be included in the results.<br>
         * \brief Completions for enum tags should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4545</i>
         */
        public static final int CXCompletionContext_EnumTag = (int) (1 << 8);
        /**
         * \brief Completions for union tags should be included in the results.<br>
         * \brief Completions for union tags should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4549</i>
         */
        public static final int CXCompletionContext_UnionTag = (int) (1 << 9);
        /**
         * \brief Completions for struct tags should be included in the results.<br>
         * \brief Completions for struct tags should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4553</i>
         */
        public static final int CXCompletionContext_StructTag = (int) (1 << 10);
        /**
         * \brief Completions for C++ class names should be included in the results.<br>
         * \brief Completions for C++ class names should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4558</i>
         */
        public static final int CXCompletionContext_ClassTag = (int) (1 << 11);
        /**
         * \brief Completions for C++ namespaces and namespace aliases should be<br>
         * included in the results.<br>
         * \brief Completions for C++ namespaces and namespace aliases should be<br>
         * included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4563</i>
         */
        public static final int CXCompletionContext_Namespace = (int) (1 << 12);
        /**
         * \brief Completions for C++ nested name specifiers should be included in<br>
         * the results.<br>
         * \brief Completions for C++ nested name specifiers should be included in<br>
         * the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4568</i>
         */
        public static final int CXCompletionContext_NestedNameSpecifier = (int) (1 << 13);
        /**
         * \brief Completions for Objective-C interfaces (classes) should be included<br>
         * in the results.<br>
         * \brief Completions for Objective-C interfaces (classes) should be included<br>
         * in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4574</i>
         */
        public static final int CXCompletionContext_ObjCInterface = (int) (1 << 14);
        /**
         * \brief Completions for Objective-C protocols should be included in<br>
         * the results.<br>
         * \brief Completions for Objective-C protocols should be included in<br>
         * the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4579</i>
         */
        public static final int CXCompletionContext_ObjCProtocol = (int) (1 << 15);
        /**
         * \brief Completions for Objective-C categories should be included in<br>
         * the results.<br>
         * \brief Completions for Objective-C categories should be included in<br>
         * the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4584</i>
         */
        public static final int CXCompletionContext_ObjCCategory = (int) (1 << 16);
        /**
         * \brief Completions for Objective-C instance messages should be included<br>
         * in the results.<br>
         * \brief Completions for Objective-C instance messages should be included<br>
         * in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4589</i>
         */
        public static final int CXCompletionContext_ObjCInstanceMessage = (int) (1 << 17);
        /**
         * \brief Completions for Objective-C class messages should be included in<br>
         * the results.<br>
         * \brief Completions for Objective-C class messages should be included in<br>
         * the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4594</i>
         */
        public static final int CXCompletionContext_ObjCClassMessage = (int) (1 << 18);
        /**
         * \brief Completions for Objective-C selector names should be included in<br>
         * the results.<br>
         * \brief Completions for Objective-C selector names should be included in<br>
         * the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4599</i>
         */
        public static final int CXCompletionContext_ObjCSelectorName = (int) (1 << 19);
        /**
         * \brief Completions for preprocessor macro names should be included in<br>
         * the results.<br>
         * \brief Completions for preprocessor macro names should be included in<br>
         * the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4605</i>
         */
        public static final int CXCompletionContext_MacroName = (int) (1 << 20);
        /**
         * \brief Natural language completions should be included in the results.<br>
         * \brief Natural language completions should be included in the results.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4610</i>
         */
        public static final int CXCompletionContext_NaturalLanguage = (int) (1 << 21);
        /**
         * \brief The current context is unknown, so set all contexts.<br>
         * \brief The current context is unknown, so set all contexts.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:4615</i>
         */
        public static final int CXCompletionContext_Unknown = (int) ((1 << 22) - 1);
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h:4919</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h:4919</i><br>
     * enum values
     */
    public static interface CXVisitorResult {
        /// <i>native declaration : src/main/c/clang-c/Index.h:4920</i>
        public static final int CXVisit_Break = (int) 0;
        /// <i>native declaration : src/main/c/clang-c/Index.h:4921</i>
        public static final int CXVisit_Continue = (int) 1;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    public static interface CXIdxEntityKind {
        /// <i>native declaration : src/main/c/clang-c/Index.h:5037</i>
        public static final int CXIdxEntity_Unexposed = (int) 0;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5038</i>
        public static final int CXIdxEntity_Typedef = (int) 1;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5039</i>
        public static final int CXIdxEntity_Function = (int) 2;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5040</i>
        public static final int CXIdxEntity_Variable = (int) 3;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5041</i>
        public static final int CXIdxEntity_Field = (int) 4;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5042</i>
        public static final int CXIdxEntity_EnumConstant = (int) 5;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5044</i>
        public static final int CXIdxEntity_ObjCClass = (int) 6;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5045</i>
        public static final int CXIdxEntity_ObjCProtocol = (int) 7;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5046</i>
        public static final int CXIdxEntity_ObjCCategory = (int) 8;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5048</i>
        public static final int CXIdxEntity_ObjCInstanceMethod = (int) 9;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5049</i>
        public static final int CXIdxEntity_ObjCClassMethod = (int) 10;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5050</i>
        public static final int CXIdxEntity_ObjCProperty = (int) 11;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5051</i>
        public static final int CXIdxEntity_ObjCIvar = (int) 12;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5053</i>
        public static final int CXIdxEntity_Enum = (int) 13;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5054</i>
        public static final int CXIdxEntity_Struct = (int) 14;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5055</i>
        public static final int CXIdxEntity_Union = (int) 15;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5057</i>
        public static final int CXIdxEntity_CXXClass = (int) 16;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5058</i>
        public static final int CXIdxEntity_CXXNamespace = (int) 17;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5059</i>
        public static final int CXIdxEntity_CXXNamespaceAlias = (int) 18;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5060</i>
        public static final int CXIdxEntity_CXXStaticVariable = (int) 19;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5061</i>
        public static final int CXIdxEntity_CXXStaticMethod = (int) 20;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5062</i>
        public static final int CXIdxEntity_CXXInstanceMethod = (int) 21;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5063</i>
        public static final int CXIdxEntity_CXXConstructor = (int) 22;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5064</i>
        public static final int CXIdxEntity_CXXDestructor = (int) 23;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5065</i>
        public static final int CXIdxEntity_CXXConversionFunction = (int) 24;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5066</i>
        public static final int CXIdxEntity_CXXTypeAlias = (int) 25;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5067</i>
        public static final int CXIdxEntity_CXXInterface = (int) 26;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    public static interface CXIdxEntityLanguage {
        /// <i>native declaration : src/main/c/clang-c/Index.h:5072</i>
        public static final int CXIdxEntityLang_None = (int) 0;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5073</i>
        public static final int CXIdxEntityLang_C = (int) 1;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5074</i>
        public static final int CXIdxEntityLang_ObjC = (int) 2;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5075</i>
        public static final int CXIdxEntityLang_CXX = (int) 3;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    public static interface CXIdxEntityCXXTemplateKind {
        /// <i>native declaration : src/main/c/clang-c/Index.h:5089</i>
        public static final int CXIdxEntity_NonTemplate = (int) 0;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5090</i>
        public static final int CXIdxEntity_Template = (int) 1;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5091</i>
        public static final int CXIdxEntity_TemplatePartialSpecialization = (int) 2;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5092</i>
        public static final int CXIdxEntity_TemplateSpecialization = (int) 3;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    public static interface CXIdxAttrKind {
        /// <i>native declaration : src/main/c/clang-c/Index.h:5096</i>
        public static final int CXIdxAttr_Unexposed = (int) 0;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5097</i>
        public static final int CXIdxAttr_IBAction = (int) 1;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5098</i>
        public static final int CXIdxAttr_IBOutlet = (int) 2;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5099</i>
        public static final int CXIdxAttr_IBOutletCollection = (int) 3;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    public static interface CXIdxDeclInfoFlags {
        /// <i>native declaration : src/main/c/clang-c/Index.h:5131</i>
        public static final int CXIdxDeclFlag_Skipped = (int) 1;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    public static interface CXIdxObjCContainerKind {
        /// <i>native declaration : src/main/c/clang-c/Index.h:5161</i>
        public static final int CXIdxObjCContainer_ForwardRef = (int) 0;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5162</i>
        public static final int CXIdxObjCContainer_Interface = (int) 1;
        /// <i>native declaration : src/main/c/clang-c/Index.h:5163</i>
        public static final int CXIdxObjCContainer_Implementation = (int) 2;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    public static interface CXIdxEntityRefKind {
        /**
         * \brief The entity is referenced directly in user's code.<br>
         * \brief The entity is referenced directly in user's code.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:5221</i>
         */
        public static final int CXIdxEntityRef_Direct = (int) 1;
        /**
         * \brief An implicit reference, e.g. a reference of an ObjC method via the<br>
         * dot syntax.<br>
         * \brief An implicit reference, e.g. a reference of an ObjC method via the<br>
         * dot syntax.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:5226</i>
         */
        public static final int CXIdxEntityRef_Implicit = (int) 2;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
     * enum values
     */
    public static interface CXIndexOptFlags {
        /**
         * \brief Used to indicate that no special indexing options are needed.<br>
         * \brief Used to indicate that no special indexing options are needed.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:5390</i>
         */
        public static final int CXIndexOpt_None = (int) 0;
        /**
         * \brief Used to indicate that IndexerCallbacks#indexEntityReference should<br>
         * be invoked for only one reference of an entity per source file that does<br>
         * not also include a declaration/definition of the entity.<br>
         * \brief Used to indicate that IndexerCallbacks#indexEntityReference should<br>
         * be invoked for only one reference of an entity per source file that does<br>
         * not also include a declaration/definition of the entity.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:5397</i>
         */
        public static final int CXIndexOpt_SuppressRedundantRefs = (int) 1;
        /**
         * \brief Function-local symbols should be indexed. If this is not set<br>
         * function-local symbols will be ignored.<br>
         * \brief Function-local symbols should be indexed. If this is not set<br>
         * function-local symbols will be ignored.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:5403</i>
         */
        public static final int CXIndexOpt_IndexFunctionLocalSymbols = (int) 2;
        /**
         * \brief Implicit function/class template instantiations should be indexed.<br>
         * If this is not set, implicit instantiations will be ignored.<br>
         * \brief Implicit function/class template instantiations should be indexed.<br>
         * If this is not set, implicit instantiations will be ignored.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:5409</i>
         */
        public static final int CXIndexOpt_IndexImplicitTemplateInstantiations = (int) 4;
        /**
         * \brief Suppress all compiler warnings when parsing for indexing.<br>
         * \brief Suppress all compiler warnings when parsing for indexing.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:5414</i>
         */
        public static final int CXIndexOpt_SuppressWarnings = (int) 8;
        /**
         * \brief Skip a function/method body that was already parsed during an<br>
         * indexing session assosiated with a \c CXIndexAction object.<br>
         * Bodies in system headers are always skipped.<br>
         * \brief Skip a function/method body that was already parsed during an<br>
         * indexing session assosiated with a \c CXIndexAction object.<br>
         * Bodies in system headers are always skipped.<br>
         * <i>native declaration : src/main/c/clang-c/Index.h:5421</i>
         */
        public static final int CXIndexOpt_SkipParsedBodiesInSession = (int) 16;
    }
    /**
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h</i><br>
     * enum values
     */
    /**
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h</i><br>
     * enum values
     */
    public static interface CXCompilationDatabase_Error {
        /**
         * \brief No error occured<br>
         * \brief No error occured<br>
         * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:44</i>
         */
        public static final int CXCompilationDatabase_NoError = (int) 0;
        /**
         * \brief Database can not be loaded<br>
         * \brief Database can not be loaded<br>
         * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:49</i>
         */
        public static final int CXCompilationDatabase_CanNotLoadDatabase = (int) 1;
    }

    /// <i>native declaration : src/main/c/clang-c/Index.h</i>
    public static final int CINDEX_VERSION_MINOR = (int) 9;
    /// <i>native declaration : src/main/c/clang-c/Index.h</i>
    public static final String CINDEX_VERSION_STRING = (String) "0";
    /// <i>native declaration : src/main/c/clang-c/Index.h</i>
    public static final int CINDEX_VERSION = (int) (((0) * 10000) + ((9) * 1));
    /// <i>native declaration : src/main/c/clang-c/Index.h</i>
    public static final int CINDEX_VERSION_MAJOR = (int) 0;
    /**
     * \brief Visitor invoked for each cursor found by a traversal.<br>
     * * This visitor function will be invoked for each cursor found by<br>
     * clang_visitCursorChildren(). Its first argument is the cursor being<br>
     * visited, its second argument is the parent visitor for that cursor,<br>
     * and its third argument is the client data provided to<br>
     * clang_visitCursorChildren().<br>
     * * The visitor should return one of the \c CXChildVisitResult values<br>
     * to direct clang_visitCursorChildren().<br>
     * <i>native declaration : src/main/c/clang-c/Platform.h</i>
     */
    /**
     * \brief Visitor invoked for each cursor found by a traversal.<br>
     * * This visitor function will be invoked for each cursor found by<br>
     * clang_visitCursorChildren(). Its first argument is the cursor being<br>
     * visited, its second argument is the parent visitor for that cursor,<br>
     * and its third argument is the client data provided to<br>
     * clang_visitCursorChildren().<br>
     * * The visitor should return one of the \c CXChildVisitResult values<br>
     * to direct clang_visitCursorChildren().<br>
     * <i>native declaration : src/main/c/clang-c/Platform.h</i>
     */
    public interface CXCursorVisitor extends Callback {
        int apply(CXCursor.ByValue cursor, CXCursor.ByValue parent, Pointer client_data);
    }
    /**
     * \brief Visitor invoked for each file in a translation unit<br>
     *        (used with clang_getInclusions()).<br>
     * * This visitor function will be invoked by clang_getInclusions() for each<br>
     * file included (either at the top-level or by \#include directives) within<br>
     * a translation unit.  The first argument is the file being included, and<br>
     * the second and third arguments provide the inclusion stack.  The<br>
     * array is sorted in order of immediate inclusion.  For example,<br>
     * the first element refers to the location that included 'included_file'.<br>
     * <i>native declaration : src/main/c/clang-c/Platform.h</i>
     */
    /**
     * \brief Visitor invoked for each file in a translation unit<br>
     * (used with clang_getInclusions()).<br>
     * * This visitor function will be invoked by clang_getInclusions() for each<br>
     * file included (either at the top-level or by \#include directives) within<br>
     * a translation unit.  The first argument is the file being included, and<br>
     * the second and third arguments provide the inclusion stack.  The<br>
     * array is sorted in order of immediate inclusion.  For example,<br>
     * the first element refers to the location that included 'included_file'.<br>
     * <i>native declaration : src/main/c/clang-c/Platform.h</i>
     */
    public interface CXInclusionVisitor extends Callback {
        void apply(Pointer included_file, CXSourceLocation inclusion_stack, ClangLibrary.include_len include_len1, Pointer client_data);
    }

    /// <i>native declaration : src/main/c/clang-c/Index.h:4072</i>
    /// <i>native declaration : src/main/c/clang-c/Index.h:4072</i>
    public interface clang_executeOnThread_fn_callback extends Callback {
        void apply(Pointer voidPtr1);
    }

    /**
     * \brief Retrieve the character data associated with the given string.<br>
     * Original signature : <code>char* clang_getCString(CXString)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXString.h:29</i>
     */
    String clang_getCString(CXString.ByValue string);

    /**
     * \brief Free the given string,<br>
     * Original signature : <code>void clang_disposeString(CXString)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXString.h:34</i>
     */
    void clang_disposeString(CXString.ByValue string);

    /**
     * \brief Provides a shared context for creating translation units.<br>
     * * It provides two options:<br>
     * * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of "local"<br>
     * declarations (when loading any new translation units). A "local" declaration<br>
     * is one that belongs in the translation unit itself and not in a precompiled<br>
     * header that was used by the translation unit. If zero, all declarations<br>
     * will be enumerated.<br>
     * * Here is an example:<br>
     * * \code<br>
     * // excludeDeclsFromPCH = 1, displayDiagnostics=1<br>
     * Idx = clang_createIndex(1, 1);<br>
     * *   // IndexTest.pch was produced with the following command:<br>
     * // "clang -x c IndexTest.h -emit-ast -o IndexTest.pch"<br>
     * TU = clang_createTranslationUnit(Idx, "IndexTest.pch");<br>
     * *   // This will load all the symbols from 'IndexTest.pch'<br>
     * clang_visitChildren(clang_getTranslationUnitCursor(TU),<br>
     * TranslationUnitVisitor, 0);<br>
     * clang_disposeTranslationUnit(TU);<br>
     * *   // This will load all the symbols from 'IndexTest.c', excluding symbols<br>
     * // from 'IndexTest.pch'.<br>
     * char *args[] = { "-Xclang", "-include-pch=IndexTest.pch" };<br>
     * TU = clang_createTranslationUnitFromSourceFile(Idx, "IndexTest.c", 2, args,<br>
     * 0, 0);<br>
     * clang_visitChildren(clang_getTranslationUnitCursor(TU),<br>
     * TranslationUnitVisitor, 0);<br>
     * clang_disposeTranslationUnit(TU);<br>
     * \endcode<br>
     * * This process of creating the 'pch', loading it separately, and using it (via<br>
     * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks<br>
     * (which gives the indexer the same performance benefit as the compiler).<br>
     * Original signature : <code>CXIndex clang_createIndex(int, int)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:185</i>
     */
    Pointer clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics);

    /**
     * \brief Destroy the given index.<br>
     * * The index must not be destroyed until all of the translation units created<br>
     * within that index have been destroyed.<br>
     * Original signature : <code>void clang_disposeIndex(CXIndex)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:194</i>
     */
    void clang_disposeIndex(Pointer index);

    /**
     * \brief Sets general options associated with a CXIndex.<br>
     * * For example:<br>
     * \code<br>
     * CXIndex idx = ...;<br>
     * clang_CXIndex_setGlobalOptions(idx,<br>
     * clang_CXIndex_getGlobalOptions(idx) |<br>
     * CXGlobalOpt_ThreadBackgroundPriorityForIndexing);<br>
     * \endcode<br>
     * * \param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.<br>
     * Original signature : <code>void clang_CXIndex_setGlobalOptions(CXIndex, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:243</i>
     */
    void clang_CXIndex_setGlobalOptions(Pointer CXIndex1, int options);

    /**
     * \brief Gets the general options associated with a CXIndex.<br>
     * * \returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that<br>
     * are associated with the given CXIndex object.<br>
     * Original signature : <code>int clang_CXIndex_getGlobalOptions(CXIndex)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:251</i>
     */
    int clang_CXIndex_getGlobalOptions(Pointer CXIndex1);

    /**
     * \brief Retrieve the complete file and path name of the given file.<br>
     * Original signature : <code>CXString clang_getFileName(CXFile)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:268</i>
     */
    CXString.ByValue clang_getFileName(Pointer SFile);

    /**
     * \brief Retrieve the last modification time of the given file.<br>
     * Original signature : <code>time_t clang_getFileTime(CXFile)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:273</i>
     */
    ClangLibrary.time_t clang_getFileTime(Pointer SFile);

    /**
     * \brief Determine whether the given header is guarded against<br>
     * multiple inclusions, either with the conventional<br>
     * \#ifndef/\#define/\#endif macro guards or with \#pragma once.<br>
     * Original signature : <code>int clang_isFileMultipleIncludeGuarded(CXTranslationUnit, CXFile)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:280</i>
     */
    int clang_isFileMultipleIncludeGuarded(ClangLibrary.CXTranslationUnit tu, Pointer file);

    /**
     * \brief Retrieve a file handle within the given translation unit.<br>
     * * \param tu the translation unit<br>
     * * \param file_name the name of the file.<br>
     * * \returns the file handle for the named file in the translation unit \p tu,<br>
     * or a NULL file handle if the file was not a part of this translation unit.<br>
     * Original signature : <code>CXFile clang_getFile(CXTranslationUnit, const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:293</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getFile(clang.ClangLibrary.CXTranslationUnit, java.lang.String)} and {@link #clang_getFile(clang.ClangLibrary.CXTranslationUnit, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    Pointer clang_getFile(ClangLibrary.CXTranslationUnit tu, Pointer file_name);

    /**
     * \brief Retrieve a file handle within the given translation unit.<br>
     * * \param tu the translation unit<br>
     * * \param file_name the name of the file.<br>
     * * \returns the file handle for the named file in the translation unit \p tu,<br>
     * or a NULL file handle if the file was not a part of this translation unit.<br>
     * Original signature : <code>CXFile clang_getFile(CXTranslationUnit, const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:293</i>
     */
    Pointer clang_getFile(ClangLibrary.CXTranslationUnit tu, String file_name);

    /**
     * \brief Retrieve a NULL (invalid) source location.<br>
     * Original signature : <code>CXSourceLocation clang_getNullLocation()</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:340</i>
     */
    CXSourceLocation.ByValue clang_getNullLocation();

    /**
     * \brief Determine whether two source locations, which must refer into<br>
     * the same translation unit, refer to exactly the same point in the source<br>
     * code.<br>
     * * \returns non-zero if the source locations refer to the same location, zero<br>
     * if they refer to different locations.<br>
     * Original signature : <code>int clang_equalLocations(CXSourceLocation, CXSourceLocation)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:350</i>
     */
    int clang_equalLocations(CXSourceLocation.ByValue loc1, CXSourceLocation.ByValue loc2);

    /**
     * \brief Retrieves the source location associated with a given file/line/column<br>
     * in a particular translation unit.<br>
     * Original signature : <code>CXSourceLocation clang_getLocation(CXTranslationUnit, CXFile, unsigned, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:357</i>
     */
    CXSourceLocation.ByValue clang_getLocation(ClangLibrary.CXTranslationUnit tu, Pointer file, int line, int column);

    /**
     * \brief Retrieves the source location associated with a given character offset<br>
     * in a particular translation unit.<br>
     * Original signature : <code>CXSourceLocation clang_getLocationForOffset(CXTranslationUnit, CXFile, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:365</i>
     */
    CXSourceLocation.ByValue clang_getLocationForOffset(ClangLibrary.CXTranslationUnit tu, Pointer file, int offset);

    /**
     * \brief Retrieve a NULL (invalid) source range.<br>
     * Original signature : <code>CXSourceRange clang_getNullRange()</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:372</i>
     */
    CXSourceRange.ByValue clang_getNullRange();

    /**
     * \brief Retrieve a source range given the beginning and ending source<br>
     * locations.<br>
     * Original signature : <code>CXSourceRange clang_getRange(CXSourceLocation, CXSourceLocation)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:378</i>
     */
    CXSourceRange.ByValue clang_getRange(CXSourceLocation.ByValue begin, CXSourceLocation.ByValue end);

    /**
     * \brief Determine whether two ranges are equivalent.<br>
     * * \returns non-zero if the ranges are the same, zero if they differ.<br>
     * Original signature : <code>int clang_equalRanges(CXSourceRange, CXSourceRange)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:386</i>
     */
    int clang_equalRanges(CXSourceRange.ByValue range1, CXSourceRange.ByValue range2);

    /**
     * \brief Returns non-zero if \p range is null.<br>
     * Original signature : <code>int clang_Range_isNull(CXSourceRange)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:392</i>
     */
    int clang_Range_isNull(CXSourceRange.ByValue range);

    /**
     * \brief Retrieve the file, line, column, and offset represented by<br>
     * the given source location.<br>
     * * If the location refers into a macro expansion, retrieves the<br>
     * location of the macro expansion.<br>
     * * \param location the location within a source file that will be decomposed<br>
     * into its parts.<br>
     * * \param file [out] if non-NULL, will be set to the file to which the given<br>
     * source location points.<br>
     * * \param line [out] if non-NULL, will be set to the line to which the given<br>
     * source location points.<br>
     * * \param column [out] if non-NULL, will be set to the column to which the given<br>
     * source location points.<br>
     * * \param offset [out] if non-NULL, will be set to the offset into the<br>
     * buffer to which the given source location points.<br>
     * Original signature : <code>void clang_getExpansionLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:416</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getExpansionLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_getExpansionLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void clang_getExpansionLocation(CXSourceLocation.ByValue location, Pointer file, IntByReference line, IntByReference column, IntByReference offset);

    /**
     * \brief Retrieve the file, line, column, and offset represented by<br>
     * the given source location.<br>
     * * If the location refers into a macro expansion, retrieves the<br>
     * location of the macro expansion.<br>
     * * \param location the location within a source file that will be decomposed<br>
     * into its parts.<br>
     * * \param file [out] if non-NULL, will be set to the file to which the given<br>
     * source location points.<br>
     * * \param line [out] if non-NULL, will be set to the line to which the given<br>
     * source location points.<br>
     * * \param column [out] if non-NULL, will be set to the column to which the given<br>
     * source location points.<br>
     * * \param offset [out] if non-NULL, will be set to the offset into the<br>
     * buffer to which the given source location points.<br>
     * Original signature : <code>void clang_getExpansionLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:416</i>
     */
    void clang_getExpansionLocation(CXSourceLocation.ByValue location, Pointer file, IntBuffer line, IntBuffer column, IntBuffer offset);

    /**
     * \brief Retrieve the file, line, column, and offset represented by<br>
     * the given source location, as specified in a # line directive.<br>
     * * Example: given the following source code in a file somefile.c<br>
     * * \code<br>
     * #123 "dummy.c" 1<br>
     * * static int func(void)<br>
     * {<br>
     * return 0;<br>
     * }<br>
     * \endcode<br>
     * * the location information returned by this function would be<br>
     * * File: dummy.c Line: 124 Column: 12<br>
     * * whereas clang_getExpansionLocation would have returned<br>
     * * File: somefile.c Line: 3 Column: 12<br>
     * * \param location the location within a source file that will be decomposed<br>
     * into its parts.<br>
     * * \param filename [out] if non-NULL, will be set to the filename of the<br>
     * source location. Note that filenames returned will be for "virtual" files,<br>
     * which don't necessarily exist on the machine running clang - e.g. when<br>
     * parsing preprocessed output obtained from a different environment. If<br>
     * a non-NULL value is passed in, remember to dispose of the returned value<br>
     * using \c clang_disposeString() once you've finished with it. For an invalid<br>
     * source location, an empty string is returned.<br>
     * * \param line [out] if non-NULL, will be set to the line number of the<br>
     * source location. For an invalid source location, zero is returned.<br>
     * * \param column [out] if non-NULL, will be set to the column number of the<br>
     * source location. For an invalid source location, zero is returned.<br>
     * Original signature : <code>void clang_getPresumedLocation(CXSourceLocation, CXString*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:462</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getPresumedLocation(clang.CXSourceLocation.ByValue, clang.CXString, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_getPresumedLocation(clang.CXSourceLocation.ByValue, clang.CXString, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void clang_getPresumedLocation(CXSourceLocation.ByValue location, CXString filename, IntByReference line, IntByReference column);

    /**
     * \brief Retrieve the file, line, column, and offset represented by<br>
     * the given source location, as specified in a # line directive.<br>
     * * Example: given the following source code in a file somefile.c<br>
     * * \code<br>
     * #123 "dummy.c" 1<br>
     * * static int func(void)<br>
     * {<br>
     * return 0;<br>
     * }<br>
     * \endcode<br>
     * * the location information returned by this function would be<br>
     * * File: dummy.c Line: 124 Column: 12<br>
     * * whereas clang_getExpansionLocation would have returned<br>
     * * File: somefile.c Line: 3 Column: 12<br>
     * * \param location the location within a source file that will be decomposed<br>
     * into its parts.<br>
     * * \param filename [out] if non-NULL, will be set to the filename of the<br>
     * source location. Note that filenames returned will be for "virtual" files,<br>
     * which don't necessarily exist on the machine running clang - e.g. when<br>
     * parsing preprocessed output obtained from a different environment. If<br>
     * a non-NULL value is passed in, remember to dispose of the returned value<br>
     * using \c clang_disposeString() once you've finished with it. For an invalid<br>
     * source location, an empty string is returned.<br>
     * * \param line [out] if non-NULL, will be set to the line number of the<br>
     * source location. For an invalid source location, zero is returned.<br>
     * * \param column [out] if non-NULL, will be set to the column number of the<br>
     * source location. For an invalid source location, zero is returned.<br>
     * Original signature : <code>void clang_getPresumedLocation(CXSourceLocation, CXString*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:462</i>
     */
    void clang_getPresumedLocation(CXSourceLocation.ByValue location, CXString filename, IntBuffer line, IntBuffer column);

    /**
     * \brief Legacy API to retrieve the file, line, column, and offset represented<br>
     * by the given source location.<br>
     * * This interface has been replaced by the newer interface<br>
     * #clang_getExpansionLocation(). See that interface's documentation for<br>
     * details.<br>
     * Original signature : <code>void clang_getInstantiationLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:475</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getInstantiationLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_getInstantiationLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void clang_getInstantiationLocation(CXSourceLocation.ByValue location, Pointer file, IntByReference line, IntByReference column, IntByReference offset);

    /**
     * \brief Legacy API to retrieve the file, line, column, and offset represented<br>
     * by the given source location.<br>
     * * This interface has been replaced by the newer interface<br>
     * #clang_getExpansionLocation(). See that interface's documentation for<br>
     * details.<br>
     * Original signature : <code>void clang_getInstantiationLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:475</i>
     */
    void clang_getInstantiationLocation(CXSourceLocation.ByValue location, Pointer file, IntBuffer line, IntBuffer column, IntBuffer offset);

    /**
     * \brief Retrieve the file, line, column, and offset represented by<br>
     * the given source location.<br>
     * * If the location refers into a macro instantiation, return where the<br>
     * location was originally spelled in the source file.<br>
     * * \param location the location within a source file that will be decomposed<br>
     * into its parts.<br>
     * * \param file [out] if non-NULL, will be set to the file to which the given<br>
     * source location points.<br>
     * * \param line [out] if non-NULL, will be set to the line to which the given<br>
     * source location points.<br>
     * * \param column [out] if non-NULL, will be set to the column to which the given<br>
     * source location points.<br>
     * * \param offset [out] if non-NULL, will be set to the offset into the<br>
     * buffer to which the given source location points.<br>
     * Original signature : <code>void clang_getSpellingLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:503</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getSpellingLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_getSpellingLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void clang_getSpellingLocation(CXSourceLocation.ByValue location, Pointer file, IntByReference line, IntByReference column, IntByReference offset);

    /**
     * \brief Retrieve the file, line, column, and offset represented by<br>
     * the given source location.<br>
     * * If the location refers into a macro instantiation, return where the<br>
     * location was originally spelled in the source file.<br>
     * * \param location the location within a source file that will be decomposed<br>
     * into its parts.<br>
     * * \param file [out] if non-NULL, will be set to the file to which the given<br>
     * source location points.<br>
     * * \param line [out] if non-NULL, will be set to the line to which the given<br>
     * source location points.<br>
     * * \param column [out] if non-NULL, will be set to the column to which the given<br>
     * source location points.<br>
     * * \param offset [out] if non-NULL, will be set to the offset into the<br>
     * buffer to which the given source location points.<br>
     * Original signature : <code>void clang_getSpellingLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:503</i>
     */
    void clang_getSpellingLocation(CXSourceLocation.ByValue location, Pointer file, IntBuffer line, IntBuffer column, IntBuffer offset);

    /**
     * \brief Retrieve a source location representing the first character within a<br>
     * source range.<br>
     * Original signature : <code>CXSourceLocation clang_getRangeStart(CXSourceRange)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:513</i>
     */
    CXSourceLocation.ByValue clang_getRangeStart(CXSourceRange.ByValue range);

    /**
     * \brief Retrieve a source location representing the last character within a<br>
     * source range.<br>
     * Original signature : <code>CXSourceLocation clang_getRangeEnd(CXSourceRange)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:519</i>
     */
    CXSourceLocation.ByValue clang_getRangeEnd(CXSourceRange.ByValue range);

    /**
     * \brief Determine the number of diagnostics in a CXDiagnosticSet.<br>
     * Original signature : <code>int clang_getNumDiagnosticsInSet(CXDiagnosticSet)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:580</i>
     */
    int clang_getNumDiagnosticsInSet(Pointer Diags);

    /**
     * \brief Retrieve a diagnostic associated with the given CXDiagnosticSet.<br>
     * * \param Diags the CXDiagnosticSet to query.<br>
     * \param Index the zero-based diagnostic number to retrieve.<br>
     * * \returns the requested diagnostic. This diagnostic must be freed<br>
     * via a call to \c clang_disposeDiagnostic().<br>
     * Original signature : <code>CXDiagnostic clang_getDiagnosticInSet(CXDiagnosticSet, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:591</i>
     */
    Pointer clang_getDiagnosticInSet(Pointer Diags, int Index);

    /**
     * \brief Deserialize a set of diagnostics from a Clang diagnostics bitcode<br>
     * file.<br>
     * * \param file The name of the file to deserialize.<br>
     * \param error A pointer to a enum value recording if there was a problem<br>
     * deserializing the diagnostics.<br>
     * \param errorString A pointer to a CXString for recording the error string<br>
     * if the file was not successfully loaded.<br>
     * * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These<br>
     * diagnostics should be released using clang_disposeDiagnosticSet().<br>
     * Original signature : <code>CXDiagnosticSet clang_loadDiagnostics(const char*, CXLoadDiag_Error*, CXString*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:637</i><br>
     *
     * @deprecated use the safer methods {@link #clang_loadDiagnostics(java.lang.String, java.nio.IntBuffer, clang.CXString)} and {@link #clang_loadDiagnostics(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, clang.CXString)} instead
     */
    @Deprecated
    Pointer clang_loadDiagnostics(Pointer file, IntByReference error, CXString errorString);

    /**
     * \brief Deserialize a set of diagnostics from a Clang diagnostics bitcode<br>
     * file.<br>
     * * \param file The name of the file to deserialize.<br>
     * \param error A pointer to a enum value recording if there was a problem<br>
     * deserializing the diagnostics.<br>
     * \param errorString A pointer to a CXString for recording the error string<br>
     * if the file was not successfully loaded.<br>
     * * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These<br>
     * diagnostics should be released using clang_disposeDiagnosticSet().<br>
     * Original signature : <code>CXDiagnosticSet clang_loadDiagnostics(const char*, CXLoadDiag_Error*, CXString*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:637</i>
     */
    Pointer clang_loadDiagnostics(String file, IntBuffer error, CXString errorString);

    /**
     * \brief Release a CXDiagnosticSet and all of its contained diagnostics.<br>
     * Original signature : <code>void clang_disposeDiagnosticSet(CXDiagnosticSet)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:644</i>
     */
    void clang_disposeDiagnosticSet(Pointer Diags);

    /**
     * \brief Retrieve the child diagnostics of a CXDiagnostic. <br>
     * * This CXDiagnosticSet does not need to be released by<br>
     * clang_diposeDiagnosticSet.<br>
     * Original signature : <code>CXDiagnosticSet clang_getChildDiagnostics(CXDiagnostic)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:652</i>
     */
    Pointer clang_getChildDiagnostics(Pointer D);

    /**
     * \brief Determine the number of diagnostics produced for the given<br>
     * translation unit.<br>
     * Original signature : <code>int clang_getNumDiagnostics(CXTranslationUnit)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:658</i>
     */
    int clang_getNumDiagnostics(ClangLibrary.CXTranslationUnit Unit);

    /**
     * \brief Retrieve a diagnostic associated with the given translation unit.<br>
     * * \param Unit the translation unit to query.<br>
     * \param Index the zero-based diagnostic number to retrieve.<br>
     * * \returns the requested diagnostic. This diagnostic must be freed<br>
     * via a call to \c clang_disposeDiagnostic().<br>
     * Original signature : <code>CXDiagnostic clang_getDiagnostic(CXTranslationUnit, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:669</i>
     */
    Pointer clang_getDiagnostic(ClangLibrary.CXTranslationUnit Unit, int Index);

    /**
     * \brief Retrieve the complete set of diagnostics associated with a<br>
     * translation unit.<br>
     * * \param Unit the translation unit to query.<br>
     * Original signature : <code>CXDiagnosticSet clang_getDiagnosticSetFromTU(CXTranslationUnit)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:678</i>
     */
    Pointer clang_getDiagnosticSetFromTU(ClangLibrary.CXTranslationUnit Unit);

    /**
     * \brief Destroy a diagnostic.<br>
     * Original signature : <code>void clang_disposeDiagnostic(CXDiagnostic)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:684</i>
     */
    void clang_disposeDiagnostic(Pointer Diagnostic);

    /**
     * \brief Format the given diagnostic in a manner that is suitable for display.<br>
     * * This routine will format the given diagnostic to a string, rendering<br>
     * the diagnostic according to the various options given. The<br>
     * \c clang_defaultDiagnosticDisplayOptions() function returns the set of<br>
     * options that most closely mimics the behavior of the clang compiler.<br>
     * * \param Diagnostic The diagnostic to print.<br>
     * * \param Options A set of options that control the diagnostic display,<br>
     * created by combining \c CXDiagnosticDisplayOptions values.<br>
     * * \returns A new string containing for formatted diagnostic.<br>
     * Original signature : <code>CXString clang_formatDiagnostic(CXDiagnostic, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:769</i>
     */
    CXString.ByValue clang_formatDiagnostic(Pointer Diagnostic, int Options);

    /**
     * \brief Retrieve the set of display options most similar to the<br>
     * default behavior of the clang compiler.<br>
     * * \returns A set of display options suitable for use with \c<br>
     * clang_displayDiagnostic().<br>
     * Original signature : <code>int clang_defaultDiagnosticDisplayOptions()</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:779</i>
     */
    int clang_defaultDiagnosticDisplayOptions();

    /**
     * \brief Determine the severity of the given diagnostic.<br>
     * Original signature : <code>CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:784</i>
     */
    int clang_getDiagnosticSeverity(Pointer CXDiagnostic1);

    /**
     * \brief Retrieve the source location of the given diagnostic.<br>
     * * This location is where Clang would print the caret ('^') when<br>
     * displaying the diagnostic on the command line.<br>
     * Original signature : <code>CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:793</i>
     */
    CXSourceLocation.ByValue clang_getDiagnosticLocation(Pointer CXDiagnostic1);

    /**
     * \brief Retrieve the text of the given diagnostic.<br>
     * Original signature : <code>CXString clang_getDiagnosticSpelling(CXDiagnostic)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:798</i>
     */
    CXString.ByValue clang_getDiagnosticSpelling(Pointer CXDiagnostic1);

    /**
     * \brief Retrieve the name of the command-line option that enabled this<br>
     * diagnostic.<br>
     * * \param Diag The diagnostic to be queried.<br>
     * * \param Disable If non-NULL, will be set to the option that disables this<br>
     * diagnostic (if any).<br>
     * * \returns A string that contains the command-line option used to enable this<br>
     * warning, such as "-Wconversion" or "-pedantic".<br>
     * Original signature : <code>CXString clang_getDiagnosticOption(CXDiagnostic, CXString*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:812</i>
     */
    CXString.ByValue clang_getDiagnosticOption(Pointer Diag, CXString Disable);

    /**
     * \brief Retrieve the category number for this diagnostic.<br>
     * * Diagnostics can be categorized into groups along with other, related<br>
     * diagnostics (e.g., diagnostics under the same warning flag). This routine <br>
     * retrieves the category number for the given diagnostic.<br>
     * * \returns The number of the category that contains this diagnostic, or zero<br>
     * if this diagnostic is uncategorized.<br>
     * Original signature : <code>int clang_getDiagnosticCategory(CXDiagnostic)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:825</i>
     */
    int clang_getDiagnosticCategory(Pointer CXDiagnostic1);

    /**
     * Original signature : <code>CXString clang_getDiagnosticCategoryName(unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:838</i>
     */
    CXString.ByValue clang_getDiagnosticCategoryName(int Category);

    /**
     * \brief Retrieve the diagnostic category text for a given diagnostic.<br>
     * * \returns The text of the given diagnostic category.<br>
     * Original signature : <code>CXString clang_getDiagnosticCategoryText(CXDiagnostic)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:845</i>
     */
    CXString.ByValue clang_getDiagnosticCategoryText(Pointer CXDiagnostic1);

    /**
     * \brief Determine the number of source ranges associated with the given<br>
     * diagnostic.<br>
     * Original signature : <code>int clang_getDiagnosticNumRanges(CXDiagnostic)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:851</i>
     */
    int clang_getDiagnosticNumRanges(Pointer CXDiagnostic1);

    /**
     * \brief Retrieve a source range associated with the diagnostic.<br>
     * * A diagnostic's source ranges highlight important elements in the source<br>
     * code. On the command line, Clang displays source ranges by<br>
     * underlining them with '~' characters.<br>
     * * \param Diagnostic the diagnostic whose range is being extracted.<br>
     * * \param Range the zero-based index specifying which range to<br>
     * * \returns the requested source range.<br>
     * Original signature : <code>CXSourceRange clang_getDiagnosticRange(CXDiagnostic, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:866</i>
     */
    CXSourceRange.ByValue clang_getDiagnosticRange(Pointer Diagnostic, int Range);

    /**
     * \brief Determine the number of fix-it hints associated with the<br>
     * given diagnostic.<br>
     * Original signature : <code>int clang_getDiagnosticNumFixIts(CXDiagnostic)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:873</i>
     */
    int clang_getDiagnosticNumFixIts(Pointer Diagnostic);

    /**
     * \brief Retrieve the replacement information for a given fix-it.<br>
     * * Fix-its are described in terms of a source range whose contents<br>
     * should be replaced by a string. This approach generalizes over<br>
     * three kinds of operations: removal of source code (the range covers<br>
     * the code to be removed and the replacement string is empty),<br>
     * replacement of source code (the range covers the code to be<br>
     * replaced and the replacement string provides the new code), and<br>
     * insertion (both the start and end of the range point at the<br>
     * insertion location, and the replacement string provides the text to<br>
     * insert).<br>
     * * \param Diagnostic The diagnostic whose fix-its are being queried.<br>
     * * \param FixIt The zero-based index of the fix-it.<br>
     * * \param ReplacementRange The source range whose contents will be<br>
     * replaced with the returned replacement string. Note that source<br>
     * ranges are half-open ranges [a, b), so the source code should be<br>
     * replaced from a and up to (but not including) b.<br>
     * * \returns A string containing text that should be replace the source<br>
     * code indicated by the \c ReplacementRange.<br>
     * Original signature : <code>CXString clang_getDiagnosticFixIt(CXDiagnostic, unsigned, CXSourceRange*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:900</i>
     */
    CXString.ByValue clang_getDiagnosticFixIt(Pointer Diagnostic, int FixIt, CXSourceRange ReplacementRange);

    /**
     * \brief Get the original translation unit source file name.<br>
     * Original signature : <code>CXString clang_getTranslationUnitSpelling(CXTranslationUnit)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:921</i>
     */
    CXString.ByValue clang_getTranslationUnitSpelling(ClangLibrary.CXTranslationUnit CTUnit);

    /**
     * \brief Return the CXTranslationUnit for a given source file and the provided<br>
     * command line arguments one would pass to the compiler.<br>
     * * Note: The 'source_filename' argument is optional.  If the caller provides a<br>
     * NULL pointer, the name of the source file is expected to reside in the<br>
     * specified command line arguments.<br>
     * * Note: When encountered in 'clang_command_line_args', the following options<br>
     * are ignored:<br>
     * *   '-c'<br>
     * '-emit-ast'<br>
     * '-fsyntax-only'<br>
     * '-o \<output file>'  (both '-o' and '\<output file>' are ignored)<br>
     * * \param CIdx The index object with which the translation unit will be<br>
     * associated.<br>
     * * \param source_filename The name of the source file to load, or NULL if the<br>
     * source file is included in \p clang_command_line_args.<br>
     * * \param num_clang_command_line_args The number of command-line arguments in<br>
     * \p clang_command_line_args.<br>
     * * \param clang_command_line_args The command-line arguments that would be<br>
     * passed to the \c clang executable if it were being invoked out-of-process.<br>
     * These command-line options will be parsed and will affect how the translation<br>
     * unit is parsed. Note that the following options are ignored: '-c',<br>
     * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
     * * \param num_unsaved_files the number of unsaved file entries in \p<br>
     * unsaved_files.<br>
     * * \param unsaved_files the files that have not yet been saved to disk<br>
     * but may be required for code completion, including the contents of<br>
     * those files.  The contents and name of these files (as specified by<br>
     * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
     * guarantee their validity until the call to this function returns.<br>
     * Original signature : <code>CXTranslationUnit clang_createTranslationUnitFromSourceFile(CXIndex, const char*, int, const const char**, unsigned, CXUnsavedFile*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:964</i><br>
     *
     * @deprecated use the safer methods {@link #clang_createTranslationUnitFromSourceFile(com.sun.jna.Pointer, java.lang.String, int, byte[][], int, clang.CXUnsavedFile)} and {@link #clang_createTranslationUnitFromSourceFile(com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.ptr.PointerByReference, int, clang.CXUnsavedFile)} instead
     */
    @Deprecated
    ClangLibrary.CXTranslationUnit clang_createTranslationUnitFromSourceFile(Pointer CIdx, Pointer source_filename, int num_clang_command_line_args, PointerByReference clang_command_line_args, int num_unsaved_files, CXUnsavedFile unsaved_files);

    /**
     * \brief Return the CXTranslationUnit for a given source file and the provided<br>
     * command line arguments one would pass to the compiler.<br>
     * * Note: The 'source_filename' argument is optional.  If the caller provides a<br>
     * NULL pointer, the name of the source file is expected to reside in the<br>
     * specified command line arguments.<br>
     * * Note: When encountered in 'clang_command_line_args', the following options<br>
     * are ignored:<br>
     * *   '-c'<br>
     * '-emit-ast'<br>
     * '-fsyntax-only'<br>
     * '-o \<output file>'  (both '-o' and '\<output file>' are ignored)<br>
     * * \param CIdx The index object with which the translation unit will be<br>
     * associated.<br>
     * * \param source_filename The name of the source file to load, or NULL if the<br>
     * source file is included in \p clang_command_line_args.<br>
     * * \param num_clang_command_line_args The number of command-line arguments in<br>
     * \p clang_command_line_args.<br>
     * * \param clang_command_line_args The command-line arguments that would be<br>
     * passed to the \c clang executable if it were being invoked out-of-process.<br>
     * These command-line options will be parsed and will affect how the translation<br>
     * unit is parsed. Note that the following options are ignored: '-c',<br>
     * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
     * * \param num_unsaved_files the number of unsaved file entries in \p<br>
     * unsaved_files.<br>
     * * \param unsaved_files the files that have not yet been saved to disk<br>
     * but may be required for code completion, including the contents of<br>
     * those files.  The contents and name of these files (as specified by<br>
     * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
     * guarantee their validity until the call to this function returns.<br>
     * Original signature : <code>CXTranslationUnit clang_createTranslationUnitFromSourceFile(CXIndex, const char*, int, const const char**, unsigned, CXUnsavedFile*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:964</i>
     */
    ClangLibrary.CXTranslationUnit clang_createTranslationUnitFromSourceFile(Pointer CIdx, String source_filename, int num_clang_command_line_args, byte[] clang_command_line_args[], int num_unsaved_files, CXUnsavedFile unsaved_files);

    /**
     * \brief Create a translation unit from an AST file (-emit-ast).<br>
     * Original signature : <code>CXTranslationUnit clang_createTranslationUnit(CXIndex, const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:975</i><br>
     *
     * @deprecated use the safer methods {@link #clang_createTranslationUnit(com.sun.jna.Pointer, java.lang.String)} and {@link #clang_createTranslationUnit(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    ClangLibrary.CXTranslationUnit clang_createTranslationUnit(Pointer CXIndex1, Pointer ast_filename);

    /**
     * \brief Create a translation unit from an AST file (-emit-ast).<br>
     * Original signature : <code>CXTranslationUnit clang_createTranslationUnit(CXIndex, const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:975</i>
     */
    ClangLibrary.CXTranslationUnit clang_createTranslationUnit(Pointer CXIndex1, String ast_filename);

    /**
     * \brief Returns the set of flags that is suitable for parsing a translation<br>
     * unit that is being edited.<br>
     * * The set of flags returned provide options for \c clang_parseTranslationUnit()<br>
     * to indicate that the translation unit is likely to be reparsed many times,<br>
     * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly<br>
     * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag<br>
     * set contains an unspecified set of optimizations (e.g., the precompiled <br>
     * preamble) geared toward improving the performance of these routines. The<br>
     * set of optimizations enabled may change from one version to the next.<br>
     * Original signature : <code>int clang_defaultEditingTranslationUnitOptions()</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1089</i>
     */
    int clang_defaultEditingTranslationUnitOptions();

    /**
     * \brief Parse the given source file and the translation unit corresponding<br>
     * to that file.<br>
     * * This routine is the main entry point for the Clang C API, providing the<br>
     * ability to parse a source file into a translation unit that can then be<br>
     * queried by other functions in the API. This routine accepts a set of<br>
     * command-line arguments so that the compilation can be configured in the same<br>
     * way that the compiler is configured on the command line.<br>
     * * \param CIdx The index object with which the translation unit will be <br>
     * associated.<br>
     * * \param source_filename The name of the source file to load, or NULL if the<br>
     * source file is included in \p command_line_args.<br>
     * * \param command_line_args The command-line arguments that would be<br>
     * passed to the \c clang executable if it were being invoked out-of-process.<br>
     * These command-line options will be parsed and will affect how the translation<br>
     * unit is parsed. Note that the following options are ignored: '-c', <br>
     * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
     * * \param num_command_line_args The number of command-line arguments in<br>
     * \p command_line_args.<br>
     * * \param unsaved_files the files that have not yet been saved to disk<br>
     * but may be required for parsing, including the contents of<br>
     * those files.  The contents and name of these files (as specified by<br>
     * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
     * guarantee their validity until the call to this function returns.<br>
     * * \param num_unsaved_files the number of unsaved file entries in \p<br>
     * unsaved_files.<br>
     * * \param options A bitmask of options that affects how the translation unit<br>
     * is managed but not its compilation. This should be a bitwise OR of the<br>
     * CXTranslationUnit_XXX flags.<br>
     * * \returns A new translation unit describing the parsed code and containing<br>
     * any diagnostics produced by the compiler. If there is a failure from which<br>
     * the compiler cannot recover, returns NULL.<br>
     * Original signature : <code>CXTranslationUnit clang_parseTranslationUnit(CXIndex, const char*, const const char**, int, CXUnsavedFile*, unsigned, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1133</i><br>
     *
     * @deprecated use the safer methods {@link #clang_parseTranslationUnit(com.sun.jna.Pointer, java.lang.String, byte[][], int, clang.CXUnsavedFile, int, int)} and {@link #clang_parseTranslationUnit(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, int, clang.CXUnsavedFile, int, int)} instead
     */
    @Deprecated
    ClangLibrary.CXTranslationUnit clang_parseTranslationUnit(Pointer CIdx, Pointer source_filename, PointerByReference command_line_args, int num_command_line_args, CXUnsavedFile unsaved_files, int num_unsaved_files, int options);

    /**
     * \brief Parse the given source file and the translation unit corresponding<br>
     * to that file.<br>
     * * This routine is the main entry point for the Clang C API, providing the<br>
     * ability to parse a source file into a translation unit that can then be<br>
     * queried by other functions in the API. This routine accepts a set of<br>
     * command-line arguments so that the compilation can be configured in the same<br>
     * way that the compiler is configured on the command line.<br>
     * * \param CIdx The index object with which the translation unit will be <br>
     * associated.<br>
     * * \param source_filename The name of the source file to load, or NULL if the<br>
     * source file is included in \p command_line_args.<br>
     * * \param command_line_args The command-line arguments that would be<br>
     * passed to the \c clang executable if it were being invoked out-of-process.<br>
     * These command-line options will be parsed and will affect how the translation<br>
     * unit is parsed. Note that the following options are ignored: '-c', <br>
     * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
     * * \param num_command_line_args The number of command-line arguments in<br>
     * \p command_line_args.<br>
     * * \param unsaved_files the files that have not yet been saved to disk<br>
     * but may be required for parsing, including the contents of<br>
     * those files.  The contents and name of these files (as specified by<br>
     * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
     * guarantee their validity until the call to this function returns.<br>
     * * \param num_unsaved_files the number of unsaved file entries in \p<br>
     * unsaved_files.<br>
     * * \param options A bitmask of options that affects how the translation unit<br>
     * is managed but not its compilation. This should be a bitwise OR of the<br>
     * CXTranslationUnit_XXX flags.<br>
     * * \returns A new translation unit describing the parsed code and containing<br>
     * any diagnostics produced by the compiler. If there is a failure from which<br>
     * the compiler cannot recover, returns NULL.<br>
     * Original signature : <code>CXTranslationUnit clang_parseTranslationUnit(CXIndex, const char*, const const char**, int, CXUnsavedFile*, unsigned, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1133</i>
     */
    ClangLibrary.CXTranslationUnit clang_parseTranslationUnit(Pointer CIdx, String source_filename, byte[] command_line_args[], int num_command_line_args, CXUnsavedFile unsaved_files, int num_unsaved_files, int options);

    /**
     * \brief Returns the set of flags that is suitable for saving a translation<br>
     * unit.<br>
     * * The set of flags returned provide options for<br>
     * \c clang_saveTranslationUnit() by default. The returned flag<br>
     * set contains an unspecified set of options that save translation units with<br>
     * the most commonly-requested data.<br>
     * Original signature : <code>int clang_defaultSaveOptions(CXTranslationUnit)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1164</i>
     */
    int clang_defaultSaveOptions(ClangLibrary.CXTranslationUnit TU);

    /**
     * \brief Saves a translation unit into a serialized representation of<br>
     * that translation unit on disk.<br>
     * * Any translation unit that was parsed without error can be saved<br>
     * into a file. The translation unit can then be deserialized into a<br>
     * new \c CXTranslationUnit with \c clang_createTranslationUnit() or,<br>
     * if it is an incomplete translation unit that corresponds to a<br>
     * header, used as a precompiled header when parsing other translation<br>
     * units.<br>
     * * \param TU The translation unit to save.<br>
     * * \param FileName The file to which the translation unit will be saved.<br>
     * * \param options A bitmask of options that affects how the translation unit<br>
     * is saved. This should be a bitwise OR of the<br>
     * CXSaveTranslationUnit_XXX flags.<br>
     * * \returns A value that will match one of the enumerators of the CXSaveError<br>
     * enumeration. Zero (CXSaveError_None) indicates that the translation unit was <br>
     * saved successfully, while a non-zero value indicates that a problem occurred.<br>
     * Original signature : <code>int clang_saveTranslationUnit(CXTranslationUnit, const char*, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1224</i><br>
     *
     * @deprecated use the safer methods {@link #clang_saveTranslationUnit(clang.ClangLibrary.CXTranslationUnit, java.lang.String, int)} and {@link #clang_saveTranslationUnit(clang.ClangLibrary.CXTranslationUnit, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int clang_saveTranslationUnit(ClangLibrary.CXTranslationUnit TU, Pointer FileName, int options);

    /**
     * \brief Saves a translation unit into a serialized representation of<br>
     * that translation unit on disk.<br>
     * * Any translation unit that was parsed without error can be saved<br>
     * into a file. The translation unit can then be deserialized into a<br>
     * new \c CXTranslationUnit with \c clang_createTranslationUnit() or,<br>
     * if it is an incomplete translation unit that corresponds to a<br>
     * header, used as a precompiled header when parsing other translation<br>
     * units.<br>
     * * \param TU The translation unit to save.<br>
     * * \param FileName The file to which the translation unit will be saved.<br>
     * * \param options A bitmask of options that affects how the translation unit<br>
     * is saved. This should be a bitwise OR of the<br>
     * CXSaveTranslationUnit_XXX flags.<br>
     * * \returns A value that will match one of the enumerators of the CXSaveError<br>
     * enumeration. Zero (CXSaveError_None) indicates that the translation unit was <br>
     * saved successfully, while a non-zero value indicates that a problem occurred.<br>
     * Original signature : <code>int clang_saveTranslationUnit(CXTranslationUnit, const char*, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1224</i>
     */
    int clang_saveTranslationUnit(ClangLibrary.CXTranslationUnit TU, String FileName, int options);

    /**
     * \brief Destroy the specified CXTranslationUnit object.<br>
     * Original signature : <code>void clang_disposeTranslationUnit(CXTranslationUnit)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1231</i>
     */
    void clang_disposeTranslationUnit(ClangLibrary.CXTranslationUnit CXTranslationUnit1);

    /**
     * \brief Returns the set of flags that is suitable for reparsing a translation<br>
     * unit.<br>
     * * The set of flags returned provide options for<br>
     * \c clang_reparseTranslationUnit() by default. The returned flag<br>
     * set contains an unspecified set of optimizations geared toward common uses<br>
     * of reparsing. The set of optimizations enabled may change from one version <br>
     * to the next.<br>
     * Original signature : <code>int clang_defaultReparseOptions(CXTranslationUnit)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1257</i>
     */
    int clang_defaultReparseOptions(ClangLibrary.CXTranslationUnit TU);

    /**
     * \brief Reparse the source files that produced this translation unit.<br>
     * * This routine can be used to re-parse the source files that originally<br>
     * created the given translation unit, for example because those source files<br>
     * have changed (either on disk or as passed via \p unsaved_files). The<br>
     * source code will be reparsed with the same command-line options as it<br>
     * was originally parsed. <br>
     * * Reparsing a translation unit invalidates all cursors and source locations<br>
     * that refer into that translation unit. This makes reparsing a translation<br>
     * unit semantically equivalent to destroying the translation unit and then<br>
     * creating a new translation unit with the same command-line arguments.<br>
     * However, it may be more efficient to reparse a translation <br>
     * unit using this routine.<br>
     * * \param TU The translation unit whose contents will be re-parsed. The<br>
     * translation unit must originally have been built with <br>
     * \c clang_createTranslationUnitFromSourceFile().<br>
     * * \param num_unsaved_files The number of unsaved file entries in \p<br>
     * unsaved_files.<br>
     * * \param unsaved_files The files that have not yet been saved to disk<br>
     * but may be required for parsing, including the contents of<br>
     * those files.  The contents and name of these files (as specified by<br>
     * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
     * guarantee their validity until the call to this function returns.<br>
     * <br>
     * \param options A bitset of options composed of the flags in CXReparse_Flags.<br>
     * The function \c clang_defaultReparseOptions() produces a default set of<br>
     * options recommended for most uses, based on the translation unit.<br>
     * * \returns 0 if the sources could be reparsed. A non-zero value will be<br>
     * returned if reparsing was impossible, such that the translation unit is<br>
     * invalid. In such cases, the only valid call for \p TU is <br>
     * \c clang_disposeTranslationUnit(TU).<br>
     * Original signature : <code>int clang_reparseTranslationUnit(CXTranslationUnit, unsigned, CXUnsavedFile*, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1297</i>
     */
    int clang_reparseTranslationUnit(ClangLibrary.CXTranslationUnit TU, int num_unsaved_files, CXUnsavedFile unsaved_files, int options);

    /**
     * Original signature : <code>char* clang_getTUResourceUsageName(CXTUResourceUsageKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1333</i>
     */
    String clang_getTUResourceUsageName(int kind);

    /**
     * \brief Return the memory usage of a translation unit.  This object<br>
     * should be released with clang_disposeCXTUResourceUsage().<br>
     * Original signature : <code>CXTUResourceUsage clang_getCXTUResourceUsage(CXTranslationUnit)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1363</i>
     */
    clang.CXTUResourceUsage.ByValue clang_getCXTUResourceUsage(ClangLibrary.CXTranslationUnit TU);

    /**
     * Original signature : <code>void clang_disposeCXTUResourceUsage(CXTUResourceUsage)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:1365</i>
     */
    void clang_disposeCXTUResourceUsage(clang.CXTUResourceUsage.ByValue usage);

    /**
     * \brief Retrieve the NULL cursor, which represents no entity.<br>
     * Original signature : <code>CXCursor clang_getNullCursor()</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2071</i>
     */
    CXCursor.ByValue clang_getNullCursor();

    /**
     * \brief Retrieve the cursor that represents the given translation unit.<br>
     * * The translation unit cursor can be used to start traversing the<br>
     * various declarations within the given translation unit.<br>
     * Original signature : <code>CXCursor clang_getTranslationUnitCursor(CXTranslationUnit)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2079</i>
     */
    CXCursor.ByValue clang_getTranslationUnitCursor(ClangLibrary.CXTranslationUnit CXTranslationUnit1);

    /**
     * \brief Determine whether two cursors are equivalent.<br>
     * Original signature : <code>int clang_equalCursors(CXCursor, CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2084</i>
     */
    int clang_equalCursors(CXCursor.ByValue CXCursor1, CXCursor.ByValue CXCursor2);

    /**
     * \brief Returns non-zero if \p cursor is null.<br>
     * Original signature : <code>int clang_Cursor_isNull(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2089</i>
     */
    int clang_Cursor_isNull(CXCursor.ByValue cursor);

    /**
     * \brief Compute a hash value for the given cursor.<br>
     * Original signature : <code>int clang_hashCursor(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2094</i>
     */
    int clang_hashCursor(CXCursor.ByValue CXCursor1);

    /**
     * \brief Retrieve the kind of the given cursor.<br>
     * Original signature : <code>CXCursorKind clang_getCursorKind(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2099</i>
     */
    int clang_getCursorKind(CXCursor.ByValue CXCursor1);

    /**
     * \brief Determine whether the given cursor kind represents a declaration.<br>
     * Original signature : <code>int clang_isDeclaration(CXCursorKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2104</i>
     */
    int clang_isDeclaration(int arg1);

    /**
     * \brief Determine whether the given cursor kind represents a simple<br>
     * reference.<br>
     * * Note that other kinds of cursors (such as expressions) can also refer to<br>
     * other cursors. Use clang_getCursorReferenced() to determine whether a<br>
     * particular cursor refers to another entity.<br>
     * Original signature : <code>int clang_isReference(CXCursorKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2114</i>
     */
    int clang_isReference(int arg1);

    /**
     * \brief Determine whether the given cursor kind represents an expression.<br>
     * Original signature : <code>int clang_isExpression(CXCursorKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2119</i>
     */
    int clang_isExpression(int arg1);

    /**
     * \brief Determine whether the given cursor kind represents a statement.<br>
     * Original signature : <code>int clang_isStatement(CXCursorKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2124</i>
     */
    int clang_isStatement(int arg1);

    /**
     * \brief Determine whether the given cursor kind represents an attribute.<br>
     * Original signature : <code>int clang_isAttribute(CXCursorKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2129</i>
     */
    int clang_isAttribute(int arg1);

    /**
     * \brief Determine whether the given cursor kind represents an invalid<br>
     * cursor.<br>
     * Original signature : <code>int clang_isInvalid(CXCursorKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2135</i>
     */
    int clang_isInvalid(int arg1);

    /**
     * \brief Determine whether the given cursor kind represents a translation<br>
     * unit.<br>
     * Original signature : <code>int clang_isTranslationUnit(CXCursorKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2141</i>
     */
    int clang_isTranslationUnit(int arg1);

    /**
     * \brief Determine whether the given cursor represents a preprocessing<br>
     * element, such as a preprocessor directive or macro instantiation.<br>
     * Original signature : <code>int clang_isPreprocessing(CXCursorKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2147</i>
     */
    int clang_isPreprocessing(int arg1);

    /**
     * \brief Determine whether the given cursor represents a currently<br>
     * unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).<br>
     * Original signature : <code>int clang_isUnexposed(CXCursorKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2153</i>
     */
    int clang_isUnexposed(int arg1);

    /**
     * \brief Determine the linkage of the entity referred to by a given cursor.<br>
     * Original signature : <code>CXLinkageKind clang_getCursorLinkage(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2179</i>
     */
    int clang_getCursorLinkage(CXCursor.ByValue cursor);

    /**
     * \brief Determine the availability of the entity that this cursor refers to,<br>
     * taking the current target platform into account.<br>
     * * \param cursor The cursor to query.<br>
     * * \returns The availability of the cursor.<br>
     * Original signature : <code>CXAvailabilityKind clang_getCursorAvailability(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2189</i>
     */
    int clang_getCursorAvailability(CXCursor.ByValue cursor);

    /**
     * \brief Determine the availability of the entity that this cursor refers to<br>
     * on any platforms for which availability information is known.<br>
     * * \param cursor The cursor to query.<br>
     * * \param always_deprecated If non-NULL, will be set to indicate whether the <br>
     * entity is deprecated on all platforms.<br>
     * * \param deprecated_message If non-NULL, will be set to the message text <br>
     * provided along with the unconditional deprecation of this entity. The client<br>
     * is responsible for deallocating this string.<br>
     * * \param always_unavailable If non-NULL, will be set to indicate whether the<br>
     * entity is unavailable on all platforms.<br>
     * * \param unavailable_message If non-NULL, will be set to the message text<br>
     * provided along with the unconditional unavailability of this entity. The <br>
     * client is responsible for deallocating this string.<br>
     * * \param availability If non-NULL, an array of CXPlatformAvailability instances<br>
     * that will be populated with platform availability information, up to either<br>
     * the number of platforms for which availability information is available (as<br>
     * returned by this function) or \c availability_size, whichever is smaller.<br>
     * * \param availability_size The number of elements available in the <br>
     * \c availability array.<br>
     * * \returns The number of platforms (N) for which availability information is<br>
     * available (which is unrelated to \c availability_size).<br>
     * * Note that the client is responsible for calling <br>
     * \c clang_disposeCXPlatformAvailability to free each of the <br>
     * platform-availability structures returned. There are <br>
     * \c min(N, availability_size) such structures.<br>
     * Original signature : <code>int clang_getCursorPlatformAvailability(CXCursor, int*, CXString*, int*, CXString*, CXPlatformAvailability*, int)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2265</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getCursorPlatformAvailability(clang.CXCursor.ByValue, java.nio.IntBuffer, clang.CXString, java.nio.IntBuffer, clang.CXString, clang.CXPlatformAvailability, int)} and {@link #clang_getCursorPlatformAvailability(clang.CXCursor.ByValue, com.sun.jna.ptr.IntByReference, clang.CXString, com.sun.jna.ptr.IntByReference, clang.CXString, clang.CXPlatformAvailability, int)} instead
     */
    @Deprecated
    int clang_getCursorPlatformAvailability(CXCursor.ByValue cursor, IntByReference always_deprecated, CXString deprecated_message, IntByReference always_unavailable, CXString unavailable_message, CXPlatformAvailability availability, int availability_size);

    /**
     * \brief Determine the availability of the entity that this cursor refers to<br>
     * on any platforms for which availability information is known.<br>
     * * \param cursor The cursor to query.<br>
     * * \param always_deprecated If non-NULL, will be set to indicate whether the <br>
     * entity is deprecated on all platforms.<br>
     * * \param deprecated_message If non-NULL, will be set to the message text <br>
     * provided along with the unconditional deprecation of this entity. The client<br>
     * is responsible for deallocating this string.<br>
     * * \param always_unavailable If non-NULL, will be set to indicate whether the<br>
     * entity is unavailable on all platforms.<br>
     * * \param unavailable_message If non-NULL, will be set to the message text<br>
     * provided along with the unconditional unavailability of this entity. The <br>
     * client is responsible for deallocating this string.<br>
     * * \param availability If non-NULL, an array of CXPlatformAvailability instances<br>
     * that will be populated with platform availability information, up to either<br>
     * the number of platforms for which availability information is available (as<br>
     * returned by this function) or \c availability_size, whichever is smaller.<br>
     * * \param availability_size The number of elements available in the <br>
     * \c availability array.<br>
     * * \returns The number of platforms (N) for which availability information is<br>
     * available (which is unrelated to \c availability_size).<br>
     * * Note that the client is responsible for calling <br>
     * \c clang_disposeCXPlatformAvailability to free each of the <br>
     * platform-availability structures returned. There are <br>
     * \c min(N, availability_size) such structures.<br>
     * Original signature : <code>int clang_getCursorPlatformAvailability(CXCursor, int*, CXString*, int*, CXString*, CXPlatformAvailability*, int)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2265</i>
     */
    int clang_getCursorPlatformAvailability(CXCursor.ByValue cursor, IntBuffer always_deprecated, CXString deprecated_message, IntBuffer always_unavailable, CXString unavailable_message, CXPlatformAvailability availability, int availability_size);

    /**
     * \brief Free the memory associated with a \c CXPlatformAvailability structure.<br>
     * Original signature : <code>void clang_disposeCXPlatformAvailability(CXPlatformAvailability*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2277</i>
     */
    void clang_disposeCXPlatformAvailability(CXPlatformAvailability availability);

    /**
     * \brief Determine the "language" of the entity referred to by a given cursor.<br>
     * Original signature : <code>CXLanguageKind clang_getCursorLanguage(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2293</i>
     */
    int clang_getCursorLanguage(CXCursor.ByValue cursor);

    /**
     * \brief Returns the translation unit that a cursor originated from.<br>
     * Original signature : <code>CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2298</i>
     */
    ClangLibrary.CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor.ByValue CXCursor1);

    /**
     * \brief Creates an empty CXCursorSet.<br>
     * Original signature : <code>CXCursorSet clang_createCXCursorSet()</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2309</i>
     */
    ClangLibrary.CXCursorSet clang_createCXCursorSet();

    /**
     * \brief Disposes a CXCursorSet and releases its associated memory.<br>
     * Original signature : <code>void clang_disposeCXCursorSet(CXCursorSet)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2314</i>
     */
    void clang_disposeCXCursorSet(ClangLibrary.CXCursorSet cset);

    /**
     * \brief Queries a CXCursorSet to see if it contains a specific CXCursor.<br>
     * * \returns non-zero if the set contains the specified cursor.<br>
     * Original signature : <code>int clang_CXCursorSet_contains(CXCursorSet, CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2321</i>
     */
    int clang_CXCursorSet_contains(ClangLibrary.CXCursorSet cset, CXCursor.ByValue cursor);

    /**
     * \brief Inserts a CXCursor into a CXCursorSet.<br>
     * * \returns zero if the CXCursor was already in the set, and non-zero otherwise.<br>
     * Original signature : <code>int clang_CXCursorSet_insert(CXCursorSet, CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2329</i>
     */
    int clang_CXCursorSet_insert(ClangLibrary.CXCursorSet cset, CXCursor.ByValue cursor);

    /**
     * \brief Determine the semantic parent of the given cursor.<br>
     * * The semantic parent of a cursor is the cursor that semantically contains<br>
     * the given \p cursor. For many declarations, the lexical and semantic parents<br>
     * are equivalent (the lexical parent is returned by <br>
     * \c clang_getCursorLexicalParent()). They diverge when declarations or<br>
     * definitions are provided out-of-line. For example:<br>
     * * \code<br>
     * class C {<br>
     * void f();<br>
     * };<br>
     * * void C::f() { }<br>
     * \endcode<br>
     * * In the out-of-line definition of \c C::f, the semantic parent is the <br>
     * the class \c C, of which this function is a member. The lexical parent is<br>
     * the place where the declaration actually occurs in the source code; in this<br>
     * case, the definition occurs in the translation unit. In general, the <br>
     * lexical parent for a given entity can change without affecting the semantics<br>
     * of the program, and the lexical parent of different declarations of the<br>
     * same entity may be different. Changing the semantic parent of a declaration,<br>
     * on the other hand, can have a major impact on semantics, and redeclarations<br>
     * of a particular entity should all have the same semantic context.<br>
     * * In the example above, both declarations of \c C::f have \c C as their<br>
     * semantic context, while the lexical context of the first \c C::f is \c C<br>
     * and the lexical context of the second \c C::f is the translation unit.<br>
     * * For global declarations, the semantic parent is the translation unit.<br>
     * Original signature : <code>CXCursor clang_getCursorSemanticParent(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2365</i>
     */
    CXCursor.ByValue clang_getCursorSemanticParent(CXCursor.ByValue cursor);

    /**
     * \brief Determine the lexical parent of the given cursor.<br>
     * * The lexical parent of a cursor is the cursor in which the given \p cursor<br>
     * was actually written. For many declarations, the lexical and semantic parents<br>
     * are equivalent (the semantic parent is returned by <br>
     * \c clang_getCursorSemanticParent()). They diverge when declarations or<br>
     * definitions are provided out-of-line. For example:<br>
     * * \code<br>
     * class C {<br>
     * void f();<br>
     * };<br>
     * * void C::f() { }<br>
     * \endcode<br>
     * * In the out-of-line definition of \c C::f, the semantic parent is the <br>
     * the class \c C, of which this function is a member. The lexical parent is<br>
     * the place where the declaration actually occurs in the source code; in this<br>
     * case, the definition occurs in the translation unit. In general, the <br>
     * lexical parent for a given entity can change without affecting the semantics<br>
     * of the program, and the lexical parent of different declarations of the<br>
     * same entity may be different. Changing the semantic parent of a declaration,<br>
     * on the other hand, can have a major impact on semantics, and redeclarations<br>
     * of a particular entity should all have the same semantic context.<br>
     * * In the example above, both declarations of \c C::f have \c C as their<br>
     * semantic context, while the lexical context of the first \c C::f is \c C<br>
     * and the lexical context of the second \c C::f is the translation unit.<br>
     * * For declarations written in the global scope, the lexical parent is<br>
     * the translation unit.<br>
     * Original signature : <code>CXCursor clang_getCursorLexicalParent(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2401</i>
     */
    CXCursor.ByValue clang_getCursorLexicalParent(CXCursor.ByValue cursor);

    /**
     * \brief Determine the set of methods that are overridden by the given<br>
     * method.<br>
     * * In both Objective-C and C++, a method (aka virtual member function,<br>
     * in C++) can override a virtual method in a base class. For<br>
     * Objective-C, a method is said to override any method in the class's<br>
     * base class, its protocols, or its categories' protocols, that has the same<br>
     * selector and is of the same kind (class or instance).<br>
     * If no such method exists, the search continues to the class's superclass,<br>
     * its protocols, and its categories, and so on. A method from an Objective-C<br>
     * implementation is considered to override the same methods as its<br>
     * corresponding method in the interface.<br>
     * * For C++, a virtual member function overrides any virtual member<br>
     * function with the same signature that occurs in its base<br>
     * classes. With multiple inheritance, a virtual member function can<br>
     * override several virtual member functions coming from different<br>
     * base classes.<br>
     * * In all cases, this function determines the immediate overridden<br>
     * method, rather than all of the overridden methods. For example, if<br>
     * a method is originally declared in a class A, then overridden in B<br>
     * (which in inherits from A) and also in C (which inherited from B),<br>
     * then the only overridden method returned from this function when<br>
     * invoked on C's method will be B's method. The client may then<br>
     * invoke this function again, given the previously-found overridden<br>
     * methods, to map out the complete method-override set.<br>
     * * \param cursor A cursor representing an Objective-C or C++<br>
     * method. This routine will compute the set of methods that this<br>
     * method overrides.<br>
     * <br>
     * \param overridden A pointer whose pointee will be replaced with a<br>
     * pointer to an array of cursors, representing the set of overridden<br>
     * methods. If there are no overridden methods, the pointee will be<br>
     * set to NULL. The pointee must be freed via a call to <br>
     * \c clang_disposeOverriddenCursors().<br>
     * * \param num_overridden A pointer to the number of overridden<br>
     * functions, will be set to the number of overridden functions in the<br>
     * array pointed to by \p overridden.<br>
     * Original signature : <code>void clang_getOverriddenCursors(CXCursor, CXCursor**, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2446</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getOverriddenCursors(clang.CXCursor.ByValue, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer)} and {@link #clang_getOverriddenCursors(clang.CXCursor.ByValue, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void clang_getOverriddenCursors(CXCursor.ByValue cursor, PointerByReference overridden, IntByReference num_overridden);

    /**
     * \brief Determine the set of methods that are overridden by the given<br>
     * method.<br>
     * * In both Objective-C and C++, a method (aka virtual member function,<br>
     * in C++) can override a virtual method in a base class. For<br>
     * Objective-C, a method is said to override any method in the class's<br>
     * base class, its protocols, or its categories' protocols, that has the same<br>
     * selector and is of the same kind (class or instance).<br>
     * If no such method exists, the search continues to the class's superclass,<br>
     * its protocols, and its categories, and so on. A method from an Objective-C<br>
     * implementation is considered to override the same methods as its<br>
     * corresponding method in the interface.<br>
     * * For C++, a virtual member function overrides any virtual member<br>
     * function with the same signature that occurs in its base<br>
     * classes. With multiple inheritance, a virtual member function can<br>
     * override several virtual member functions coming from different<br>
     * base classes.<br>
     * * In all cases, this function determines the immediate overridden<br>
     * method, rather than all of the overridden methods. For example, if<br>
     * a method is originally declared in a class A, then overridden in B<br>
     * (which in inherits from A) and also in C (which inherited from B),<br>
     * then the only overridden method returned from this function when<br>
     * invoked on C's method will be B's method. The client may then<br>
     * invoke this function again, given the previously-found overridden<br>
     * methods, to map out the complete method-override set.<br>
     * * \param cursor A cursor representing an Objective-C or C++<br>
     * method. This routine will compute the set of methods that this<br>
     * method overrides.<br>
     * <br>
     * \param overridden A pointer whose pointee will be replaced with a<br>
     * pointer to an array of cursors, representing the set of overridden<br>
     * methods. If there are no overridden methods, the pointee will be<br>
     * set to NULL. The pointee must be freed via a call to <br>
     * \c clang_disposeOverriddenCursors().<br>
     * * \param num_overridden A pointer to the number of overridden<br>
     * functions, will be set to the number of overridden functions in the<br>
     * array pointed to by \p overridden.<br>
     * Original signature : <code>void clang_getOverriddenCursors(CXCursor, CXCursor**, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2446</i>
     */
    void clang_getOverriddenCursors(CXCursor.ByValue cursor, PointerByReference overridden, IntBuffer num_overridden);

    /**
     * \brief Free the set of overridden cursors returned by \c<br>
     * clang_getOverriddenCursors().<br>
     * Original signature : <code>void clang_disposeOverriddenCursors(CXCursor*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2454</i>
     */
    void clang_disposeOverriddenCursors(CXCursor overridden);

    /**
     * \brief Retrieve the file that is included by the given inclusion directive<br>
     * cursor.<br>
     * Original signature : <code>CXFile clang_getIncludedFile(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2460</i>
     */
    Pointer clang_getIncludedFile(CXCursor.ByValue cursor);

    /**
     * \brief Map a source location to the cursor that describes the entity at that<br>
     * location in the source code.<br>
     * * clang_getCursor() maps an arbitrary source location within a translation<br>
     * unit down to the most specific cursor that describes the entity at that<br>
     * location. For example, given an expression \c x + y, invoking<br>
     * clang_getCursor() with a source location pointing to "x" will return the<br>
     * cursor for "x"; similarly for "y". If the cursor points anywhere between<br>
     * "x" or "y" (e.g., on the + or the whitespace around it), clang_getCursor()<br>
     * will return a cursor referring to the "+" expression.<br>
     * * \returns a cursor representing the entity at the given source location, or<br>
     * a NULL cursor if no such entity can be found.<br>
     * Original signature : <code>CXCursor clang_getCursor(CXTranslationUnit, CXSourceLocation)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2492</i>
     */
    CXCursor.ByValue clang_getCursor(ClangLibrary.CXTranslationUnit CXTranslationUnit1, CXSourceLocation.ByValue CXSourceLocation1);

    /**
     * \brief Retrieve the physical location of the source constructor referenced<br>
     * by the given cursor.<br>
     * * The location of a declaration is typically the location of the name of that<br>
     * declaration, where the name of that declaration would occur if it is<br>
     * unnamed, or some keyword that introduces that particular declaration.<br>
     * The location of a reference is where that reference occurs within the<br>
     * source code.<br>
     * Original signature : <code>CXSourceLocation clang_getCursorLocation(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2504</i>
     */
    CXSourceLocation.ByValue clang_getCursorLocation(CXCursor.ByValue CXCursor1);

    /**
     * \brief Retrieve the physical extent of the source construct referenced by<br>
     * the given cursor.<br>
     * * The extent of a cursor starts with the file/line/column pointing at the<br>
     * first character within the source construct that the cursor refers to and<br>
     * ends with the last character withinin that source construct. For a<br>
     * declaration, the extent covers the declaration itself. For a reference,<br>
     * the extent covers the location of the reference (e.g., where the referenced<br>
     * entity was actually used).<br>
     * Original signature : <code>CXSourceRange clang_getCursorExtent(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2517</i>
     */
    CXSourceRange.ByValue clang_getCursorExtent(CXCursor.ByValue CXCursor1);

    /**
     * \brief Retrieve the type of a CXCursor (if any).<br>
     * Original signature : <code>CXType clang_getCursorType(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2623</i>
     */
    clang.CXType.ByValue clang_getCursorType(CXCursor.ByValue C);

    /**
     * \brief Retrieve the underlying type of a typedef declaration.<br>
     * * If the cursor does not reference a typedef declaration, an invalid type is<br>
     * returned.<br>
     * Original signature : <code>CXType clang_getTypedefDeclUnderlyingType(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2631</i>
     */
    clang.CXType.ByValue clang_getTypedefDeclUnderlyingType(CXCursor.ByValue C);

    /**
     * \brief Retrieve the integer type of an enum declaration.<br>
     * * If the cursor does not reference an enum declaration, an invalid type is<br>
     * returned.<br>
     * Original signature : <code>CXType clang_getEnumDeclIntegerType(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2639</i>
     */
    clang.CXType.ByValue clang_getEnumDeclIntegerType(CXCursor.ByValue C);

    /**
     * \brief Retrieve the integer value of an enum constant declaration as a signed<br>
     * long long.<br>
     * * If the cursor does not reference an enum constant declaration, LLONG_MIN is returned.<br>
     * Since this is also potentially a valid constant value, the kind of the cursor<br>
     * must be verified before calling this function.<br>
     * Original signature : <code>long long clang_getEnumConstantDeclValue(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2649</i>
     */
    long clang_getEnumConstantDeclValue(CXCursor.ByValue C);

    /**
     * \brief Retrieve the integer value of an enum constant declaration as an unsigned<br>
     * long long.<br>
     * * If the cursor does not reference an enum constant declaration, ULLONG_MAX is returned.<br>
     * Since this is also potentially a valid constant value, the kind of the cursor<br>
     * must be verified before calling this function.<br>
     * Original signature : <code>long long clang_getEnumConstantDeclUnsignedValue(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2659</i>
     */
    long clang_getEnumConstantDeclUnsignedValue(CXCursor.ByValue C);

    /**
     * \brief Retrieve the bit width of a bit field declaration as an integer.<br>
     * * If a cursor that is not a bit field declaration is passed in, -1 is returned.<br>
     * Original signature : <code>int clang_getFieldDeclBitWidth(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2666</i>
     */
    int clang_getFieldDeclBitWidth(CXCursor.ByValue C);

    /**
     * \brief Retrieve the number of non-variadic arguments associated with a given<br>
     * cursor.<br>
     * * If a cursor that is not a function or method is passed in, -1 is returned.<br>
     * Original signature : <code>int clang_Cursor_getNumArguments(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2674</i>
     */
    int clang_Cursor_getNumArguments(CXCursor.ByValue C);

    /**
     * \brief Retrieve the argument cursor of a function or method.<br>
     * * If a cursor that is not a function or method is passed in or the index<br>
     * exceeds the number of arguments, an invalid cursor is returned.<br>
     * Original signature : <code>CXCursor clang_Cursor_getArgument(CXCursor, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2682</i>
     */
    CXCursor.ByValue clang_Cursor_getArgument(CXCursor.ByValue C, int i);

    /**
     * \brief Determine whether two CXTypes represent the same type.<br>
     * * \returns non-zero if the CXTypes represent the same type and<br>
     * zero otherwise.<br>
     * Original signature : <code>int clang_equalTypes(CXType, CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2690</i>
     */
    int clang_equalTypes(clang.CXType.ByValue A, clang.CXType.ByValue B);

    /**
     * \brief Return the canonical type for a CXType.<br>
     * * Clang's type system explicitly models typedefs and all the ways<br>
     * a specific type can be represented.  The canonical type is the underlying<br>
     * type with all the "sugar" removed.  For example, if 'T' is a typedef<br>
     * for 'int', the canonical type for 'T' would be 'int'.<br>
     * Original signature : <code>CXType clang_getCanonicalType(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2700</i>
     */
    clang.CXType.ByValue clang_getCanonicalType(clang.CXType.ByValue T);

    /**
     * \brief Determine whether a CXType has the "const" qualifier set,<br>
     * without looking through typedefs that may have added "const" at a<br>
     * different level.<br>
     * Original signature : <code>int clang_isConstQualifiedType(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2707</i>
     */
    int clang_isConstQualifiedType(clang.CXType.ByValue T);

    /**
     * \brief Determine whether a CXType has the "volatile" qualifier set,<br>
     * without looking through typedefs that may have added "volatile" at<br>
     * a different level.<br>
     * Original signature : <code>int clang_isVolatileQualifiedType(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2714</i>
     */
    int clang_isVolatileQualifiedType(clang.CXType.ByValue T);

    /**
     * \brief Determine whether a CXType has the "restrict" qualifier set,<br>
     * without looking through typedefs that may have added "restrict" at a<br>
     * different level.<br>
     * Original signature : <code>int clang_isRestrictQualifiedType(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2721</i>
     */
    int clang_isRestrictQualifiedType(clang.CXType.ByValue T);

    /**
     * \brief For pointer types, returns the type of the pointee.<br>
     * Original signature : <code>CXType clang_getPointeeType(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2726</i>
     */
    clang.CXType.ByValue clang_getPointeeType(clang.CXType.ByValue T);

    /**
     * \brief Return the cursor for the declaration of the given type.<br>
     * Original signature : <code>CXCursor clang_getTypeDeclaration(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2731</i>
     */
    CXCursor.ByValue clang_getTypeDeclaration(clang.CXType.ByValue T);

    /**
     * Returns the Objective-C type encoding for the specified declaration.<br>
     * Original signature : <code>CXString clang_getDeclObjCTypeEncoding(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2736</i>
     */
    CXString.ByValue clang_getDeclObjCTypeEncoding(CXCursor.ByValue C);

    /**
     * \brief Retrieve the spelling of a given CXTypeKind.<br>
     * Original signature : <code>CXString clang_getTypeKindSpelling(CXTypeKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2741</i>
     */
    CXString.ByValue clang_getTypeKindSpelling(int K);

    /**
     * \brief Retrieve the calling convention associated with a function type.<br>
     * * If a non-function type is passed in, CXCallingConv_Invalid is returned.<br>
     * Original signature : <code>CXCallingConv clang_getFunctionTypeCallingConv(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2748</i>
     */
    int clang_getFunctionTypeCallingConv(clang.CXType.ByValue T);

    /**
     * \brief Retrieve the result type associated with a function type.<br>
     * * If a non-function type is passed in, an invalid type is returned.<br>
     * Original signature : <code>CXType clang_getResultType(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2755</i>
     */
    clang.CXType.ByValue clang_getResultType(clang.CXType.ByValue T);

    /**
     * \brief Retrieve the number of non-variadic arguments associated with a<br>
     * function type.<br>
     * * If a non-function type is passed in, -1 is returned.<br>
     * Original signature : <code>int clang_getNumArgTypes(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2763</i>
     */
    int clang_getNumArgTypes(clang.CXType.ByValue T);

    /**
     * \brief Retrieve the type of an argument of a function type.<br>
     * * If a non-function type is passed in or the function does not have enough<br>
     * parameters, an invalid type is returned.<br>
     * Original signature : <code>CXType clang_getArgType(CXType, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2771</i>
     */
    clang.CXType.ByValue clang_getArgType(clang.CXType.ByValue T, int i);

    /**
     * \brief Return 1 if the CXType is a variadic function type, and 0 otherwise.<br>
     * Original signature : <code>int clang_isFunctionTypeVariadic(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2776</i>
     */
    int clang_isFunctionTypeVariadic(clang.CXType.ByValue T);

    /**
     * \brief Retrieve the result type associated with a given cursor.<br>
     * * This only returns a valid type if the cursor refers to a function or method.<br>
     * Original signature : <code>CXType clang_getCursorResultType(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2783</i>
     */
    clang.CXType.ByValue clang_getCursorResultType(CXCursor.ByValue C);

    /**
     * \brief Return 1 if the CXType is a POD (plain old data) type, and 0<br>
     * otherwise.<br>
     * Original signature : <code>int clang_isPODType(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2789</i>
     */
    int clang_isPODType(clang.CXType.ByValue T);

    /**
     * \brief Return the element type of an array, complex, or vector type.<br>
     * * If a type is passed in that is not an array, complex, or vector type,<br>
     * an invalid type is returned.<br>
     * Original signature : <code>CXType clang_getElementType(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2797</i>
     */
    clang.CXType.ByValue clang_getElementType(clang.CXType.ByValue T);

    /**
     * \brief Return the number of elements of an array or vector type.<br>
     * * If a type is passed in that is not an array or vector type,<br>
     * -1 is returned.<br>
     * Original signature : <code>long long clang_getNumElements(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2805</i>
     */
    long clang_getNumElements(clang.CXType.ByValue T);

    /**
     * \brief Return the element type of an array type.<br>
     * * If a non-array type is passed in, an invalid type is returned.<br>
     * Original signature : <code>CXType clang_getArrayElementType(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2812</i>
     */
    clang.CXType.ByValue clang_getArrayElementType(clang.CXType.ByValue T);

    /**
     * \brief Return the array size of a constant array.<br>
     * * If a non-array type is passed in, -1 is returned.<br>
     * Original signature : <code>long long clang_getArraySize(CXType)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2819</i>
     */
    long clang_getArraySize(clang.CXType.ByValue T);

    /**
     * \brief Returns 1 if the base class specified by the cursor with kind<br>
     * CX_CXXBaseSpecifier is virtual.<br>
     * Original signature : <code>int clang_isVirtualBase(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2825</i>
     */
    int clang_isVirtualBase(CXCursor.ByValue CXCursor1);

    /**
     * \brief Returns the access control level for the C++ base specifier<br>
     * represented by a cursor with kind CXCursor_CXXBaseSpecifier or<br>
     * CXCursor_AccessSpecifier.<br>
     * Original signature : <code>CX_CXXAccessSpecifier clang_getCXXAccessSpecifier(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2843</i>
     */
    int clang_getCXXAccessSpecifier(CXCursor.ByValue CXCursor1);

    /**
     * \brief Determine the number of overloaded declarations referenced by a <br>
     * \c CXCursor_OverloadedDeclRef cursor.<br>
     * * \param cursor The cursor whose overloaded declarations are being queried.<br>
     * * \returns The number of overloaded declarations referenced by \c cursor. If it<br>
     * is not a \c CXCursor_OverloadedDeclRef cursor, returns 0.<br>
     * Original signature : <code>int clang_getNumOverloadedDecls(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2854</i>
     */
    int clang_getNumOverloadedDecls(CXCursor.ByValue cursor);

    /**
     * \brief Retrieve a cursor for one of the overloaded declarations referenced<br>
     * by a \c CXCursor_OverloadedDeclRef cursor.<br>
     * * \param cursor The cursor whose overloaded declarations are being queried.<br>
     * * \param index The zero-based index into the set of overloaded declarations in<br>
     * the cursor.<br>
     * * \returns A cursor representing the declaration referenced by the given <br>
     * \c cursor at the specified \c index. If the cursor does not have an <br>
     * associated set of overloaded declarations, or if the index is out of bounds,<br>
     * returns \c clang_getNullCursor();<br>
     * Original signature : <code>CXCursor clang_getOverloadedDecl(CXCursor, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2870</i>
     */
    CXCursor.ByValue clang_getOverloadedDecl(CXCursor.ByValue cursor, int index);

    /**
     * \brief For cursors representing an iboutletcollection attribute,<br>
     * this function returns the collection element type.<br>
     * Original signature : <code>CXType clang_getIBOutletCollectionType(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2889</i>
     */
    clang.CXType.ByValue clang_getIBOutletCollectionType(CXCursor.ByValue CXCursor1);

    /**
     * \brief Visit the children of a particular cursor.<br>
     * * This function visits all the direct children of the given cursor,<br>
     * invoking the given \p visitor function with the cursors of each<br>
     * visited child. The traversal may be recursive, if the visitor returns<br>
     * \c CXChildVisit_Recurse. The traversal may also be ended prematurely, if<br>
     * the visitor returns \c CXChildVisit_Break.<br>
     * * \param parent the cursor whose child may be visited. All kinds of<br>
     * cursors can be visited, including invalid cursors (which, by<br>
     * definition, have no children).<br>
     * * \param visitor the visitor function that will be invoked for each<br>
     * child of \p parent.<br>
     * * \param client_data pointer data supplied by the client, which will<br>
     * be passed to the visitor each time it is invoked.<br>
     * * \returns a non-zero value if the traversal was terminated<br>
     * prematurely by the visitor returning \c CXChildVisit_Break.<br>
     * Original signature : <code>int clang_visitChildren(CXCursor, CXCursorVisitor, CXClientData)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:2966</i>
     */
    int clang_visitChildren(CXCursor.ByValue parent, ClangLibrary.CXCursorVisitor visitor, Pointer client_data);

    /**
     * \brief Retrieve a Unified Symbol Resolution (USR) for the entity referenced<br>
     * by the given cursor.<br>
     * * A Unified Symbol Resolution (USR) is a string that identifies a particular<br>
     * entity (function, class, variable, etc.) within a program. USRs can be<br>
     * compared across translation units to determine, e.g., when references in<br>
     * one translation refer to an entity defined in another translation unit.<br>
     * Original signature : <code>CXString clang_getCursorUSR(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3017</i>
     */
    CXString.ByValue clang_getCursorUSR(CXCursor.ByValue CXCursor1);

    /**
     * \brief Construct a USR for a specified Objective-C class.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCClass(const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3022</i><br>
     *
     * @deprecated use the safer methods {@link #clang_constructUSR_ObjCClass(java.lang.String)} and {@link #clang_constructUSR_ObjCClass(com.sun.jna.Pointer)} instead
     */
    @Deprecated
    CXString.ByValue clang_constructUSR_ObjCClass(Pointer class_name);

    /**
     * \brief Construct a USR for a specified Objective-C class.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCClass(const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3022</i>
     */
    CXString.ByValue clang_constructUSR_ObjCClass(String class_name);

    /**
     * \brief Construct a USR for a specified Objective-C category.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCCategory(const char*, const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3027</i><br>
     *
     * @deprecated use the safer methods {@link #clang_constructUSR_ObjCCategory(java.lang.String, java.lang.String)} and {@link #clang_constructUSR_ObjCCategory(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    CXString.ByValue clang_constructUSR_ObjCCategory(Pointer class_name, Pointer category_name);

    /**
     * \brief Construct a USR for a specified Objective-C category.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCCategory(const char*, const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3027</i>
     */
    CXString.ByValue clang_constructUSR_ObjCCategory(String class_name, String category_name);

    /**
     * \brief Construct a USR for a specified Objective-C protocol.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCProtocol(const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3034</i><br>
     *
     * @deprecated use the safer methods {@link #clang_constructUSR_ObjCProtocol(java.lang.String)} and {@link #clang_constructUSR_ObjCProtocol(com.sun.jna.Pointer)} instead
     */
    @Deprecated
    CXString.ByValue clang_constructUSR_ObjCProtocol(Pointer protocol_name);

    /**
     * \brief Construct a USR for a specified Objective-C protocol.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCProtocol(const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3034</i>
     */
    CXString.ByValue clang_constructUSR_ObjCProtocol(String protocol_name);

    /**
     * \brief Construct a USR for a specified Objective-C instance variable and<br>
     * the USR for its containing class.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCIvar(const char*, CXString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3042</i><br>
     *
     * @deprecated use the safer methods {@link #clang_constructUSR_ObjCIvar(java.lang.String, clang.CXString.ByValue)} and {@link #clang_constructUSR_ObjCIvar(com.sun.jna.Pointer, clang.CXString.ByValue)} instead
     */
    @Deprecated
    CXString.ByValue clang_constructUSR_ObjCIvar(Pointer name, CXString.ByValue classUSR);

    /**
     * \brief Construct a USR for a specified Objective-C instance variable and<br>
     * the USR for its containing class.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCIvar(const char*, CXString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3042</i>
     */
    CXString.ByValue clang_constructUSR_ObjCIvar(String name, CXString.ByValue classUSR);

    /**
     * \brief Construct a USR for a specified Objective-C method and<br>
     * the USR for its containing class.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCMethod(const char*, unsigned, CXString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3049</i><br>
     *
     * @deprecated use the safer methods {@link #clang_constructUSR_ObjCMethod(java.lang.String, int, clang.CXString.ByValue)} and {@link #clang_constructUSR_ObjCMethod(com.sun.jna.Pointer, int, clang.CXString.ByValue)} instead
     */
    @Deprecated
    CXString.ByValue clang_constructUSR_ObjCMethod(Pointer name, int isInstanceMethod, CXString.ByValue classUSR);

    /**
     * \brief Construct a USR for a specified Objective-C method and<br>
     * the USR for its containing class.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCMethod(const char*, unsigned, CXString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3049</i>
     */
    CXString.ByValue clang_constructUSR_ObjCMethod(String name, int isInstanceMethod, CXString.ByValue classUSR);

    /**
     * \brief Construct a USR for a specified Objective-C property and the USR<br>
     * for its containing class.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCProperty(const char*, CXString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3057</i><br>
     *
     * @deprecated use the safer methods {@link #clang_constructUSR_ObjCProperty(java.lang.String, clang.CXString.ByValue)} and {@link #clang_constructUSR_ObjCProperty(com.sun.jna.Pointer, clang.CXString.ByValue)} instead
     */
    @Deprecated
    CXString.ByValue clang_constructUSR_ObjCProperty(Pointer property, CXString.ByValue classUSR);

    /**
     * \brief Construct a USR for a specified Objective-C property and the USR<br>
     * for its containing class.<br>
     * Original signature : <code>CXString clang_constructUSR_ObjCProperty(const char*, CXString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3057</i>
     */
    CXString.ByValue clang_constructUSR_ObjCProperty(String property, CXString.ByValue classUSR);

    /**
     * \brief Retrieve a name for the entity referenced by this cursor.<br>
     * Original signature : <code>CXString clang_getCursorSpelling(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3063</i>
     */
    CXString.ByValue clang_getCursorSpelling(CXCursor.ByValue CXCursor1);

    /**
     * \brief Retrieve a range for a piece that forms the cursors spelling name.<br>
     * Most of the times there is only one range for the complete spelling but for<br>
     * objc methods and objc message expressions, there are multiple pieces for each<br>
     * selector identifier.<br>
     * <br>
     * \param pieceIndex the index of the spelling name piece. If this is greater<br>
     * than the actual number of pieces, it will return a NULL (invalid) range.<br>
     * <br>
     * \param options Reserved.<br>
     * Original signature : <code>CXSourceRange clang_Cursor_getSpellingNameRange(CXCursor, unsigned, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3076</i>
     */
    CXSourceRange.ByValue clang_Cursor_getSpellingNameRange(CXCursor.ByValue CXCursor1, int pieceIndex, int options);

    /**
     * \brief Retrieve the display name for the entity referenced by this cursor.<br>
     * * The display name contains extra information that helps identify the cursor,<br>
     * such as the parameters of a function or template or the arguments of a <br>
     * class template specialization.<br>
     * Original signature : <code>CXString clang_getCursorDisplayName(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3087</i>
     */
    CXString.ByValue clang_getCursorDisplayName(CXCursor.ByValue CXCursor1);

    /**
     * \brief For a cursor that is a reference, retrieve a cursor representing the<br>
     * entity that it references.<br>
     * * Reference cursors refer to other entities in the AST. For example, an<br>
     * Objective-C superclass reference cursor refers to an Objective-C class.<br>
     * This function produces the cursor for the Objective-C class from the<br>
     * cursor for the superclass reference. If the input cursor is a declaration or<br>
     * definition, it returns that declaration or definition unchanged.<br>
     * Otherwise, returns the NULL cursor.<br>
     * Original signature : <code>CXCursor clang_getCursorReferenced(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3099</i>
     */
    CXCursor.ByValue clang_getCursorReferenced(CXCursor.ByValue CXCursor1);

    /**
     * \brief For a cursor that is either a reference to or a declaration<br>
     * of some entity, retrieve a cursor that describes the definition of<br>
     * that entity.<br>
     * *  Some entities can be declared multiple times within a translation<br>
     * unit, but only one of those declarations can also be a<br>
     * definition. For example, given:<br>
     * *  \code<br>
     * int f(int, int);<br>
     * int g(int x, int y) { return f(x, y); }<br>
     * int f(int a, int b) { return a + b; }<br>
     * int f(int, int);<br>
     * \endcode<br>
     * *  there are three declarations of the function "f", but only the<br>
     * second one is a definition. The clang_getCursorDefinition()<br>
     * function will take any cursor pointing to a declaration of "f"<br>
     * (the first or fourth lines of the example) or a cursor referenced<br>
     * that uses "f" (the call to "f' inside "g") and will return a<br>
     * declaration cursor pointing to the definition (the second "f"<br>
     * declaration).<br>
     * *  If given a cursor for which there is no corresponding definition,<br>
     * e.g., because there is no definition of that entity within this<br>
     * translation unit, returns a NULL cursor.<br>
     * Original signature : <code>CXCursor clang_getCursorDefinition(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3129</i>
     */
    CXCursor.ByValue clang_getCursorDefinition(CXCursor.ByValue CXCursor1);

    /**
     * \brief Determine whether the declaration pointed to by this cursor<br>
     * is also a definition of that entity.<br>
     * Original signature : <code>int clang_isCursorDefinition(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3135</i>
     */
    int clang_isCursorDefinition(CXCursor.ByValue CXCursor1);

    /**
     * \brief Retrieve the canonical cursor corresponding to the given cursor.<br>
     * * In the C family of languages, many kinds of entities can be declared several<br>
     * times within a single translation unit. For example, a structure type can<br>
     * be forward-declared (possibly multiple times) and later defined:<br>
     * * \code<br>
     * struct X;<br>
     * struct X;<br>
     * struct X {<br>
     * int member;<br>
     * };<br>
     * \endcode<br>
     * * The declarations and the definition of \c X are represented by three <br>
     * different cursors, all of which are declarations of the same underlying <br>
     * entity. One of these cursor is considered the "canonical" cursor, which<br>
     * is effectively the representative for the underlying entity. One can <br>
     * determine if two cursors are declarations of the same underlying entity by<br>
     * comparing their canonical cursors.<br>
     * * \returns The canonical cursor for the entity referred to by the given cursor.<br>
     * Original signature : <code>CXCursor clang_getCanonicalCursor(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3161</i>
     */
    CXCursor.ByValue clang_getCanonicalCursor(CXCursor.ByValue CXCursor1);

    /**
     * \brief If the cursor points to a selector identifier in a objc method or<br>
     * message expression, this returns the selector index.<br>
     * * After getting a cursor with #clang_getCursor, this can be called to<br>
     * determine if the location points to a selector identifier.<br>
     * * \returns The selector index if the cursor is an objc method or message<br>
     * expression and the cursor is pointing to a selector identifier, or -1<br>
     * otherwise.<br>
     * Original signature : <code>int clang_Cursor_getObjCSelectorIndex(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3175</i>
     */
    int clang_Cursor_getObjCSelectorIndex(CXCursor.ByValue CXCursor1);

    /**
     * \brief Given a cursor pointing to a C++ method call or an ObjC message,<br>
     * returns non-zero if the method/message is "dynamic", meaning:<br>
     * <br>
     * For a C++ method: the call is virtual.<br>
     * For an ObjC message: the receiver is an object instance, not 'super' or a<br>
     * specific class.<br>
     * <br>
     * If the method/message is "static" or the cursor does not point to a<br>
     * method/message, it will return zero.<br>
     * Original signature : <code>int clang_Cursor_isDynamicCall(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3188</i>
     */
    int clang_Cursor_isDynamicCall(CXCursor.ByValue C);

    /**
     * \brief Given a cursor pointing to an ObjC message, returns the CXType of the<br>
     * receiver.<br>
     * Original signature : <code>CXType clang_Cursor_getReceiverType(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3194</i>
     */
    clang.CXType.ByValue clang_Cursor_getReceiverType(CXCursor.ByValue C);

    /**
     * \brief Given a cursor that represents a declaration, return the associated<br>
     * comment's source range.  The range may include multiple consecutive comments<br>
     * with whitespace in between.<br>
     * Original signature : <code>CXSourceRange clang_Cursor_getCommentRange(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3201</i>
     */
    CXSourceRange.ByValue clang_Cursor_getCommentRange(CXCursor.ByValue C);

    /**
     * \brief Given a cursor that represents a declaration, return the associated<br>
     * comment text, including comment markers.<br>
     * Original signature : <code>CXString clang_Cursor_getRawCommentText(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3207</i>
     */
    CXString.ByValue clang_Cursor_getRawCommentText(CXCursor.ByValue C);

    /**
     * \brief Given a cursor that represents a documentable entity (e.g.,<br>
     * declaration), return the associated \\brief paragraph; otherwise return the<br>
     * first paragraph.<br>
     * Original signature : <code>CXString clang_Cursor_getBriefCommentText(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3214</i>
     */
    CXString.ByValue clang_Cursor_getBriefCommentText(CXCursor.ByValue C);

    /**
     * \brief Given a cursor that represents a documentable entity (e.g.,<br>
     * declaration), return the associated parsed comment as a<br>
     * \c CXComment_FullComment AST node.<br>
     * Original signature : <code>CXComment clang_Cursor_getParsedComment(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3221</i>
     */
    clang.CXComment.ByValue clang_Cursor_getParsedComment(CXCursor.ByValue C);

    /**
     * \brief Given a CXCursor_ModuleImportDecl cursor, return the associated module.<br>
     * Original signature : <code>CXModule clang_Cursor_getModule(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3240</i>
     */
    Pointer clang_Cursor_getModule(CXCursor.ByValue C);

    /**
     * \param Module a module object.<br>
     * * \returns the parent of a sub-module or NULL if the given module is top-level,<br>
     * e.g. for 'std.vector' it will return the 'std' module.<br>
     * Original signature : <code>CXModule clang_Module_getParent(CXModule)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3248</i>
     */
    Pointer clang_Module_getParent(Pointer Module);

    /**
     * \param Module a module object.<br>
     * * \returns the name of the module, e.g. for the 'std.vector' sub-module it<br>
     * will return "vector".<br>
     * Original signature : <code>CXString clang_Module_getName(CXModule)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3256</i>
     */
    CXString.ByValue clang_Module_getName(Pointer Module);

    /**
     * \param Module a module object.<br>
     * * \returns the full name of the module, e.g. "std.vector".<br>
     * Original signature : <code>CXString clang_Module_getFullName(CXModule)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3263</i>
     */
    CXString.ByValue clang_Module_getFullName(Pointer Module);

    /**
     * \param Module a module object.<br>
     * * \returns the number of top level headers associated with this module.<br>
     * Original signature : <code>int clang_Module_getNumTopLevelHeaders(CXModule)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3270</i>
     */
    int clang_Module_getNumTopLevelHeaders(Pointer Module);

    /**
     * Original signature : <code>CXFile clang_Module_getTopLevelHeader(CXModule, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3280</i>
     */
    Pointer clang_Module_getTopLevelHeader(Pointer Module, int Index);

    /**
     * \param Comment AST node of any kind.<br>
     * * \returns the type of the AST node.<br>
     * Original signature : <code>CXCommentKind clang_Comment_getKind(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3459</i>
     */
    int clang_Comment_getKind(clang.CXComment.ByValue Comment);

    /**
     * \param Comment AST node of any kind.<br>
     * * \returns number of children of the AST node.<br>
     * Original signature : <code>int clang_Comment_getNumChildren(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3466</i>
     */
    int clang_Comment_getNumChildren(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>CXComment clang_Comment_getChild(CXComment, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3476</i>
     */
    clang.CXComment.ByValue clang_Comment_getChild(clang.CXComment.ByValue Comment, int ChildIdx);

    /**
     * \brief A \c CXComment_Paragraph node is considered whitespace if it contains<br>
     * only \c CXComment_Text nodes that are empty or whitespace.<br>
     * * Other AST nodes (except \c CXComment_Paragraph and \c CXComment_Text) are<br>
     * never considered whitespace.<br>
     * * \returns non-zero if \c Comment is whitespace.<br>
     * Original signature : <code>int clang_Comment_isWhitespace(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3487</i>
     */
    int clang_Comment_isWhitespace(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>int clang_InlineContentComment_hasTrailingNewline(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3495</i>
     */
    int clang_InlineContentComment_hasTrailingNewline(clang.CXComment.ByValue Comment);

    /**
     * \param Comment a \c CXComment_Text AST node.<br>
     * * \returns text contained in the AST node.<br>
     * Original signature : <code>CXString clang_TextComment_getText(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3502</i>
     */
    CXString.ByValue clang_TextComment_getText(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>CXString clang_InlineCommandComment_getCommandName(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3510</i>
     */
    CXString.ByValue clang_InlineCommandComment_getCommandName(clang.CXComment.ByValue Comment);

    /**
     * \param Comment a \c CXComment_InlineCommand AST node.<br>
     * * \returns the most appropriate rendering mode, chosen on command<br>
     * semantics in Doxygen.<br>
     * Original signature : <code>CXCommentInlineCommandRenderKind clang_InlineCommandComment_getRenderKind(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3518</i>
     */
    int clang_InlineCommandComment_getRenderKind(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>int clang_InlineCommandComment_getNumArgs(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3527</i>
     */
    int clang_InlineCommandComment_getNumArgs(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>CXString clang_InlineCommandComment_getArgText(CXComment, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3537</i>
     */
    CXString.ByValue clang_InlineCommandComment_getArgText(clang.CXComment.ByValue Comment, int ArgIdx);

    /**
     * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST<br>
     * node.<br>
     * * \returns HTML tag name.<br>
     * Original signature : <code>CXString clang_HTMLTagComment_getTagName(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3546</i>
     */
    CXString.ByValue clang_HTMLTagComment_getTagName(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>int clang_HTMLStartTagComment_isSelfClosing(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3554</i>
     */
    int clang_HTMLStartTagComment_isSelfClosing(clang.CXComment.ByValue Comment);

    /**
     * \param Comment a \c CXComment_HTMLStartTag AST node.<br>
     * * \returns number of attributes (name-value pairs) attached to the start tag.<br>
     * Original signature : <code>int clang_HTMLStartTag_getNumAttrs(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3561</i>
     */
    int clang_HTMLStartTag_getNumAttrs(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>CXString clang_HTMLStartTag_getAttrName(CXComment, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3571</i>
     */
    CXString.ByValue clang_HTMLStartTag_getAttrName(clang.CXComment.ByValue Comment, int AttrIdx);

    /**
     * Original signature : <code>CXString clang_HTMLStartTag_getAttrValue(CXComment, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3581</i>
     */
    CXString.ByValue clang_HTMLStartTag_getAttrValue(clang.CXComment.ByValue Comment, int AttrIdx);

    /**
     * Original signature : <code>CXString clang_BlockCommandComment_getCommandName(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3589</i>
     */
    CXString.ByValue clang_BlockCommandComment_getCommandName(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>int clang_BlockCommandComment_getNumArgs(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3597</i>
     */
    int clang_BlockCommandComment_getNumArgs(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>CXString clang_BlockCommandComment_getArgText(CXComment, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3607</i>
     */
    CXString.ByValue clang_BlockCommandComment_getArgText(clang.CXComment.ByValue Comment, int ArgIdx);

    /**
     * Original signature : <code>CXComment clang_BlockCommandComment_getParagraph(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3617</i>
     */
    clang.CXComment.ByValue clang_BlockCommandComment_getParagraph(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>CXString clang_ParamCommandComment_getParamName(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3625</i>
     */
    CXString.ByValue clang_ParamCommandComment_getParamName(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>int clang_ParamCommandComment_isParamIndexValid(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3635</i>
     */
    int clang_ParamCommandComment_isParamIndexValid(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>int clang_ParamCommandComment_getParamIndex(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3643</i>
     */
    int clang_ParamCommandComment_getParamIndex(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>int clang_ParamCommandComment_isDirectionExplicit(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3652</i>
     */
    int clang_ParamCommandComment_isDirectionExplicit(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>CXCommentParamPassDirection clang_ParamCommandComment_getDirection(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3660</i>
     */
    int clang_ParamCommandComment_getDirection(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>CXString clang_TParamCommandComment_getParamName(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3669</i>
     */
    CXString.ByValue clang_TParamCommandComment_getParamName(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>int clang_TParamCommandComment_isParamPositionValid(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3681</i>
     */
    int clang_TParamCommandComment_isParamPositionValid(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>int clang_TParamCommandComment_getDepth(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3697</i>
     */
    int clang_TParamCommandComment_getDepth(clang.CXComment.ByValue Comment);

    /**
     * Original signature : <code>int clang_TParamCommandComment_getIndex(CXComment, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3718</i>
     */
    int clang_TParamCommandComment_getIndex(clang.CXComment.ByValue Comment, int Depth);

    /**
     * Original signature : <code>CXString clang_VerbatimBlockLineComment_getText(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3726</i>
     */
    CXString.ByValue clang_VerbatimBlockLineComment_getText(clang.CXComment.ByValue Comment);

    /**
     * \param Comment a \c CXComment_VerbatimLine AST node.<br>
     * * \returns text contained in the AST node.<br>
     * Original signature : <code>CXString clang_VerbatimLineComment_getText(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3733</i>
     */
    CXString.ByValue clang_VerbatimLineComment_getText(clang.CXComment.ByValue Comment);

    /**
     * \brief Convert an HTML tag AST node to string.<br>
     * * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST<br>
     * node.<br>
     * * \returns string containing an HTML tag.<br>
     * Original signature : <code>CXString clang_HTMLTagComment_getAsString(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3743</i>
     */
    CXString.ByValue clang_HTMLTagComment_getAsString(clang.CXComment.ByValue Comment);

    /**
     * \brief Convert a given full parsed comment to an HTML fragment.<br>
     * * Specific details of HTML layout are subject to change.  Don't try to parse<br>
     * this HTML back into an AST, use other APIs instead.<br>
     * * Currently the following CSS classes are used:<br>
     * \li "para-brief" for \\brief paragraph and equivalent commands;<br>
     * \li "para-returns" for \\returns paragraph and equivalent commands;<br>
     * \li "word-returns" for the "Returns" word in \\returns paragraph.<br>
     * * Function argument documentation is rendered as a \<dl\> list with arguments<br>
     * sorted in function prototype order.  CSS classes used:<br>
     * \li "param-name-index-NUMBER" for parameter name (\<dt\>);<br>
     * \li "param-descr-index-NUMBER" for parameter description (\<dd\>);<br>
     * \li "param-name-index-invalid" and "param-descr-index-invalid" are used if<br>
     * parameter index is invalid.<br>
     * * Template parameter documentation is rendered as a \<dl\> list with<br>
     * parameters sorted in template parameter list order.  CSS classes used:<br>
     * \li "tparam-name-index-NUMBER" for parameter name (\<dt\>);<br>
     * \li "tparam-descr-index-NUMBER" for parameter description (\<dd\>);<br>
     * \li "tparam-name-index-other" and "tparam-descr-index-other" are used for<br>
     * names inside template template parameters;<br>
     * \li "tparam-name-index-invalid" and "tparam-descr-index-invalid" are used if<br>
     * parameter position is invalid.<br>
     * * \param Comment a \c CXComment_FullComment AST node.<br>
     * * \returns string containing an HTML fragment.<br>
     * Original signature : <code>CXString clang_FullComment_getAsHTML(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3776</i>
     */
    CXString.ByValue clang_FullComment_getAsHTML(clang.CXComment.ByValue Comment);

    /**
     * \brief Convert a given full parsed comment to an XML document.<br>
     * * A Relax NG schema for the XML can be found in comment-xml-schema.rng file<br>
     * inside clang source tree.<br>
     * * \param Comment a \c CXComment_FullComment AST node.<br>
     * * \returns string containing an XML document.<br>
     * Original signature : <code>CXString clang_FullComment_getAsXML(CXComment)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3788</i>
     */
    CXString.ByValue clang_FullComment_getAsXML(clang.CXComment.ByValue Comment);

    /**
     * \brief Determine if a C++ member function or member function template is <br>
     * declared 'static'.<br>
     * Original signature : <code>int clang_CXXMethod_isStatic(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3807</i>
     */
    int clang_CXXMethod_isStatic(CXCursor.ByValue C);

    /**
     * \brief Determine if a C++ member function or member function template is<br>
     * explicitly declared 'virtual' or if it overrides a virtual method from<br>
     * one of the base classes.<br>
     * Original signature : <code>int clang_CXXMethod_isVirtual(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3814</i>
     */
    int clang_CXXMethod_isVirtual(CXCursor.ByValue C);

    /**
     * \brief Given a cursor that represents a template, determine<br>
     * the cursor kind of the specializations would be generated by instantiating<br>
     * the template.<br>
     * * This routine can be used to determine what flavor of function template,<br>
     * class template, or class template partial specialization is stored in the<br>
     * cursor. For example, it can describe whether a class template cursor is<br>
     * declared with "struct", "class" or "union".<br>
     * * \param C The cursor to query. This cursor should represent a template<br>
     * declaration.<br>
     * * \returns The cursor kind of the specializations that would be generated<br>
     * by instantiating the template \p C. If \p C is not a template, returns<br>
     * \c CXCursor_NoDeclFound.<br>
     * Original signature : <code>CXCursorKind clang_getTemplateCursorKind(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3833</i>
     */
    int clang_getTemplateCursorKind(CXCursor.ByValue C);

    /**
     * \brief Given a cursor that may represent a specialization or instantiation<br>
     * of a template, retrieve the cursor that represents the template that it<br>
     * specializes or from which it was instantiated.<br>
     * * This routine determines the template involved both for explicit <br>
     * specializations of templates and for implicit instantiations of the template,<br>
     * both of which are referred to as "specializations". For a class template<br>
     * specialization (e.g., \c std::vector<bool>), this routine will return <br>
     * either the primary template (\c std::vector) or, if the specialization was<br>
     * instantiated from a class template partial specialization, the class template<br>
     * partial specialization. For a class template partial specialization and a<br>
     * function template specialization (including instantiations), this<br>
     * this routine will return the specialized template.<br>
     * * For members of a class template (e.g., member functions, member classes, or<br>
     * static data members), returns the specialized or instantiated member. <br>
     * Although not strictly "templates" in the C++ language, members of class<br>
     * templates have the same notions of specializations and instantiations that<br>
     * templates do, so this routine treats them similarly.<br>
     * * \param C A cursor that may be a specialization of a template or a member<br>
     * of a template.<br>
     * * \returns If the given cursor is a specialization or instantiation of a <br>
     * template or a member thereof, the template or member that it specializes or<br>
     * from which it was instantiated. Otherwise, returns a NULL cursor.<br>
     * Original signature : <code>CXCursor clang_getSpecializedCursorTemplate(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3863</i>
     */
    CXCursor.ByValue clang_getSpecializedCursorTemplate(CXCursor.ByValue C);

    /**
     * \brief Given a cursor that references something else, return the source range<br>
     * covering that reference.<br>
     * * \param C A cursor pointing to a member reference, a declaration reference, or<br>
     * an operator call.<br>
     * \param NameFlags A bitset with three independent flags: <br>
     * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and<br>
     * CXNameRange_WantSinglePiece.<br>
     * \param PieceIndex For contiguous names or when passing the flag <br>
     * CXNameRange_WantSinglePiece, only one piece with index 0 is <br>
     * available. When the CXNameRange_WantSinglePiece flag is not passed for a<br>
     * non-contiguous names, this index can be used to retrieve the individual<br>
     * pieces of the name. See also CXNameRange_WantSinglePiece.<br>
     * * \returns The piece of the name pointed to by the given cursor. If there is no<br>
     * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.<br>
     * Original signature : <code>CXSourceRange clang_getCursorReferenceNameRange(CXCursor, unsigned, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3883</i>
     */
    CXSourceRange.ByValue clang_getCursorReferenceNameRange(CXCursor.ByValue C, int NameFlags, int PieceIndex);

    /**
     * \brief Determine the kind of the given token.<br>
     * Original signature : <code>CXTokenKind clang_getTokenKind(CXToken)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3968</i>
     */
    int clang_getTokenKind(CXToken.ByValue CXToken1);

    /**
     * \brief Determine the spelling of the given token.<br>
     * * The spelling of a token is the textual representation of that token, e.g.,<br>
     * the text of an identifier or keyword.<br>
     * Original signature : <code>CXString clang_getTokenSpelling(CXTranslationUnit, CXToken)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3976</i>
     */
    CXString.ByValue clang_getTokenSpelling(ClangLibrary.CXTranslationUnit CXTranslationUnit1, CXToken.ByValue CXToken1);

    /**
     * \brief Retrieve the source location of the given token.<br>
     * Original signature : <code>CXSourceLocation clang_getTokenLocation(CXTranslationUnit, CXToken)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3981</i>
     */
    CXSourceLocation.ByValue clang_getTokenLocation(ClangLibrary.CXTranslationUnit CXTranslationUnit1, CXToken.ByValue CXToken1);

    /**
     * \brief Retrieve a source range that covers the given token.<br>
     * Original signature : <code>CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:3987</i>
     */
    CXSourceRange.ByValue clang_getTokenExtent(ClangLibrary.CXTranslationUnit CXTranslationUnit1, CXToken.ByValue CXToken1);

    /**
     * \brief Tokenize the source code described by the given range into raw<br>
     * lexical tokens.<br>
     * * \param TU the translation unit whose text is being tokenized.<br>
     * * \param Range the source range in which text should be tokenized. All of the<br>
     * tokens produced by tokenization will fall within this source range,<br>
     * * \param Tokens this pointer will be set to point to the array of tokens<br>
     * that occur within the given source range. The returned pointer must be<br>
     * freed with clang_disposeTokens() before the translation unit is destroyed.<br>
     * * \param NumTokens will be set to the number of tokens in the \c *Tokens<br>
     * array.<br>
     * Original signature : <code>void clang_tokenize(CXTranslationUnit, CXSourceRange, CXToken**, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4006</i><br>
     *
     * @deprecated use the safer methods {@link #clang_tokenize(clang.ClangLibrary.CXTranslationUnit, clang.CXSourceRange.ByValue, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer)} and {@link #clang_tokenize(clang.ClangLibrary.CXTranslationUnit, clang.CXSourceRange.ByValue, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void clang_tokenize(ClangLibrary.CXTranslationUnit TU, CXSourceRange.ByValue Range, PointerByReference Tokens, IntByReference NumTokens);

    /**
     * \brief Tokenize the source code described by the given range into raw<br>
     * lexical tokens.<br>
     * * \param TU the translation unit whose text is being tokenized.<br>
     * * \param Range the source range in which text should be tokenized. All of the<br>
     * tokens produced by tokenization will fall within this source range,<br>
     * * \param Tokens this pointer will be set to point to the array of tokens<br>
     * that occur within the given source range. The returned pointer must be<br>
     * freed with clang_disposeTokens() before the translation unit is destroyed.<br>
     * * \param NumTokens will be set to the number of tokens in the \c *Tokens<br>
     * array.<br>
     * Original signature : <code>void clang_tokenize(CXTranslationUnit, CXSourceRange, CXToken**, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4006</i>
     */
    void clang_tokenize(ClangLibrary.CXTranslationUnit TU, CXSourceRange.ByValue Range, PointerByReference Tokens, IntBuffer NumTokens);

    /**
     * \brief Annotate the given set of tokens by providing cursors for each token<br>
     * that can be mapped to a specific entity within the abstract syntax tree.<br>
     * * This token-annotation routine is equivalent to invoking<br>
     * clang_getCursor() for the source locations of each of the<br>
     * tokens. The cursors provided are filtered, so that only those<br>
     * cursors that have a direct correspondence to the token are<br>
     * accepted. For example, given a function call \c f(x),<br>
     * clang_getCursor() would provide the following cursors:<br>
     * *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.<br>
     * * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.<br>
     * * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.<br>
     * * Only the first and last of these cursors will occur within the<br>
     * annotate, since the tokens "f" and "x' directly refer to a function<br>
     * and a variable, respectively, but the parentheses are just a small<br>
     * part of the full syntax of the function call expression, which is<br>
     * not provided as an annotation.<br>
     * * \param TU the translation unit that owns the given tokens.<br>
     * * \param Tokens the set of tokens to annotate.<br>
     * * \param NumTokens the number of tokens in \p Tokens.<br>
     * * \param Cursors an array of \p NumTokens cursors, whose contents will be<br>
     * replaced with the cursors corresponding to each token.<br>
     * Original signature : <code>void clang_annotateTokens(CXTranslationUnit, CXToken*, unsigned, CXCursor*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4039</i>
     */
    void clang_annotateTokens(ClangLibrary.CXTranslationUnit TU, CXToken Tokens, int NumTokens, CXCursor Cursors);

    /**
     * \brief Free the given set of tokens.<br>
     * Original signature : <code>void clang_disposeTokens(CXTranslationUnit, CXToken*, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4046</i>
     */
    void clang_disposeTokens(ClangLibrary.CXTranslationUnit TU, CXToken Tokens, int NumTokens);

    /**
     * for debug/testing<br>
     * Original signature : <code>CXString clang_getCursorKindSpelling(CXCursorKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4063</i>
     */
    CXString.ByValue clang_getCursorKindSpelling(int Kind);

    /**
     * Original signature : <code>void clang_getDefinitionSpellingAndExtent(CXCursor, const char**, const char**, unsigned*, unsigned*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4064</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getDefinitionSpellingAndExtent(clang.CXCursor.ByValue, java.lang.String[], java.lang.String[], java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_getDefinitionSpellingAndExtent(clang.CXCursor.ByValue, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void clang_getDefinitionSpellingAndExtent(CXCursor.ByValue CXCursor1, PointerByReference startBuf, PointerByReference endBuf, IntByReference startLine, IntByReference startColumn, IntByReference endLine, IntByReference endColumn);

    /**
     * Original signature : <code>void clang_getDefinitionSpellingAndExtent(CXCursor, const char**, const char**, unsigned*, unsigned*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4064</i>
     */
    void clang_getDefinitionSpellingAndExtent(CXCursor.ByValue CXCursor1, String startBuf[], String endBuf[], IntBuffer startLine, IntBuffer startColumn, IntBuffer endLine, IntBuffer endColumn);

    /**
     * Original signature : <code>void clang_enableStackTraces()</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4071</i>
     */
    void clang_enableStackTraces();

    /**
     * Original signature : <code>void clang_executeOnThread(clang_executeOnThread_fn_callback, void*, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4072</i>
     */
    void clang_executeOnThread(ClangLibrary.clang_executeOnThread_fn_callback arg, Pointer user_data, int stack_size);

    /**
     * \brief Determine the kind of a particular chunk within a completion string.<br>
     * * \param completion_string the completion string to query.<br>
     * * \param chunk_number the 0-based index of the chunk in the completion string.<br>
     * * \returns the kind of the chunk at the index \c chunk_number.<br>
     * Original signature : <code>CXCompletionChunkKind clang_getCompletionChunkKind(CXCompletionString, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4309</i>
     */
    int clang_getCompletionChunkKind(Pointer completion_string, int chunk_number);

    /**
     * \brief Retrieve the text associated with a particular chunk within a<br>
     * completion string.<br>
     * * \param completion_string the completion string to query.<br>
     * * \param chunk_number the 0-based index of the chunk in the completion string.<br>
     * * \returns the text associated with the chunk at index \c chunk_number.<br>
     * Original signature : <code>CXString clang_getCompletionChunkText(CXCompletionString, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4323</i>
     */
    CXString.ByValue clang_getCompletionChunkText(Pointer completion_string, int chunk_number);

    /**
     * \brief Retrieve the completion string associated with a particular chunk<br>
     * within a completion string.<br>
     * * \param completion_string the completion string to query.<br>
     * * \param chunk_number the 0-based index of the chunk in the completion string.<br>
     * * \returns the completion string associated with the chunk at index<br>
     * \c chunk_number.<br>
     * Original signature : <code>CXCompletionString clang_getCompletionChunkCompletionString(CXCompletionString, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4338</i>
     */
    Pointer clang_getCompletionChunkCompletionString(Pointer completion_string, int chunk_number);

    /**
     * \brief Retrieve the number of chunks in the given code-completion string.<br>
     * Original signature : <code>int clang_getNumCompletionChunks(CXCompletionString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4345</i>
     */
    int clang_getNumCompletionChunks(Pointer completion_string);

    /**
     * \brief Determine the priority of this code completion.<br>
     * * The priority of a code completion indicates how likely it is that this <br>
     * particular completion is the completion that the user will select. The<br>
     * priority is selected by various internal heuristics.<br>
     * * \param completion_string The completion string to query.<br>
     * * \returns The priority of this completion string. Smaller values indicate<br>
     * higher-priority (more likely) completions.<br>
     * Original signature : <code>int clang_getCompletionPriority(CXCompletionString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4360</i>
     */
    int clang_getCompletionPriority(Pointer completion_string);

    /**
     * \brief Determine the availability of the entity that this code-completion<br>
     * string refers to.<br>
     * * \param completion_string The completion string to query.<br>
     * * \returns The availability of the completion string.<br>
     * Original signature : <code>CXAvailabilityKind clang_getCompletionAvailability(CXCompletionString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4371</i>
     */
    int clang_getCompletionAvailability(Pointer completion_string);

    /**
     * \brief Retrieve the number of annotations associated with the given<br>
     * completion string.<br>
     * * \param completion_string the completion string to query.<br>
     * * \returns the number of annotations associated with the given completion<br>
     * string.<br>
     * Original signature : <code>int clang_getCompletionNumAnnotations(CXCompletionString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4383</i>
     */
    int clang_getCompletionNumAnnotations(Pointer completion_string);

    /**
     * \brief Retrieve the annotation associated with the given completion string.<br>
     * * \param completion_string the completion string to query.<br>
     * * \param annotation_number the 0-based index of the annotation of the<br>
     * completion string.<br>
     * * \returns annotation string associated with the completion at index<br>
     * \c annotation_number, or a NULL string if that annotation is not available.<br>
     * Original signature : <code>CXString clang_getCompletionAnnotation(CXCompletionString, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4397</i>
     */
    CXString.ByValue clang_getCompletionAnnotation(Pointer completion_string, int annotation_number);

    /**
     * \brief Retrieve the parent context of the given completion string.<br>
     * * The parent context of a completion string is the semantic parent of <br>
     * the declaration (if any) that the code completion represents. For example,<br>
     * a code completion for an Objective-C method would have the method's class<br>
     * or protocol as its context.<br>
     * * \param completion_string The code completion string whose parent is<br>
     * being queried.<br>
     * * \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.<br>
     * * \returns The name of the completion parent, e.g., "NSObject" if<br>
     * the completion string represents a method in the NSObject class.<br>
     * Original signature : <code>CXString clang_getCompletionParent(CXCompletionString, CXCursorKind*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4417</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getCompletionParent(com.sun.jna.Pointer, java.nio.IntBuffer)} and {@link #clang_getCompletionParent(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    CXString.ByValue clang_getCompletionParent(Pointer completion_string, IntByReference kind);

    /**
     * \brief Retrieve the parent context of the given completion string.<br>
     * * The parent context of a completion string is the semantic parent of <br>
     * the declaration (if any) that the code completion represents. For example,<br>
     * a code completion for an Objective-C method would have the method's class<br>
     * or protocol as its context.<br>
     * * \param completion_string The code completion string whose parent is<br>
     * being queried.<br>
     * * \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.<br>
     * * \returns The name of the completion parent, e.g., "NSObject" if<br>
     * the completion string represents a method in the NSObject class.<br>
     * Original signature : <code>CXString clang_getCompletionParent(CXCompletionString, CXCursorKind*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4417</i>
     */
    CXString.ByValue clang_getCompletionParent(Pointer completion_string, IntBuffer kind);

    /**
     * \brief Retrieve the brief documentation comment attached to the declaration<br>
     * that corresponds to the given completion string.<br>
     * Original signature : <code>CXString clang_getCompletionBriefComment(CXCompletionString)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4425</i>
     */
    CXString.ByValue clang_getCompletionBriefComment(Pointer completion_string);

    /**
     * \brief Retrieve a completion string for an arbitrary declaration or macro<br>
     * definition cursor.<br>
     * * \param cursor The cursor to query.<br>
     * * \returns A non-context-sensitive completion string for declaration and macro<br>
     * definition cursors, or NULL for other kinds of cursors.<br>
     * Original signature : <code>CXCompletionString clang_getCursorCompletionString(CXCursor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4437</i>
     */
    Pointer clang_getCursorCompletionString(CXCursor.ByValue cursor);

    /**
     * \brief Returns a default set of code-completion options that can be<br>
     * passed to\c clang_codeCompleteAt().<br>
     * Original signature : <code>int clang_defaultCodeCompleteOptions()</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4622</i>
     */
    int clang_defaultCodeCompleteOptions();

    /**
     * Original signature : <code>CXCodeCompleteResults* clang_codeCompleteAt(CXTranslationUnit, const char*, unsigned, unsigned, CXUnsavedFile*, unsigned, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4693</i><br>
     *
     * @deprecated use the safer methods {@link #clang_codeCompleteAt(clang.ClangLibrary.CXTranslationUnit, java.lang.String, int, int, clang.CXUnsavedFile, int, int)} and {@link #clang_codeCompleteAt(clang.ClangLibrary.CXTranslationUnit, com.sun.jna.Pointer, int, int, clang.CXUnsavedFile, int, int)} instead
     */
    @Deprecated
    CXCodeCompleteResults clang_codeCompleteAt(ClangLibrary.CXTranslationUnit TU, Pointer complete_filename, int complete_line, int complete_column, CXUnsavedFile unsaved_files, int num_unsaved_files, int options);

    /**
     * Original signature : <code>CXCodeCompleteResults* clang_codeCompleteAt(CXTranslationUnit, const char*, unsigned, unsigned, CXUnsavedFile*, unsigned, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4693</i>
     */
    CXCodeCompleteResults clang_codeCompleteAt(ClangLibrary.CXTranslationUnit TU, String complete_filename, int complete_line, int complete_column, CXUnsavedFile unsaved_files, int num_unsaved_files, int options);

    /**
     * Original signature : <code>void clang_sortCodeCompletionResults(CXCompletionResult*, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4709</i>
     */
    void clang_sortCodeCompletionResults(CXCompletionResult Results, int NumResults);

    /**
     * Original signature : <code>void clang_disposeCodeCompleteResults(CXCodeCompleteResults*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4716</i>
     */
    void clang_disposeCodeCompleteResults(CXCodeCompleteResults Results);

    /**
     * Original signature : <code>int clang_codeCompleteGetNumDiagnostics(CXCodeCompleteResults*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4723</i>
     */
    int clang_codeCompleteGetNumDiagnostics(CXCodeCompleteResults Results);

    /**
     * Original signature : <code>CXDiagnostic clang_codeCompleteGetDiagnostic(CXCodeCompleteResults*, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4735</i>
     */
    Pointer clang_codeCompleteGetDiagnostic(CXCodeCompleteResults Results, int Index);

    /**
     * Original signature : <code>long long clang_codeCompleteGetContexts(CXCodeCompleteResults*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4748</i>
     */
    long clang_codeCompleteGetContexts(CXCodeCompleteResults Results);

    /**
     * Original signature : <code>CXCursorKind clang_codeCompleteGetContainerKind(CXCodeCompleteResults*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4768</i><br>
     *
     * @deprecated use the safer methods {@link #clang_codeCompleteGetContainerKind(clang.CXCodeCompleteResults, java.nio.IntBuffer)} and {@link #clang_codeCompleteGetContainerKind(clang.CXCodeCompleteResults, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    int clang_codeCompleteGetContainerKind(CXCodeCompleteResults Results, IntByReference IsIncomplete);

    /**
     * Original signature : <code>CXCursorKind clang_codeCompleteGetContainerKind(CXCodeCompleteResults*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4768</i>
     */
    int clang_codeCompleteGetContainerKind(CXCodeCompleteResults Results, IntBuffer IsIncomplete);

    /**
     * Original signature : <code>CXString clang_codeCompleteGetContainerUSR(CXCodeCompleteResults*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4782</i>
     */
    CXString.ByValue clang_codeCompleteGetContainerUSR(CXCodeCompleteResults Results);

    /**
     * Original signature : <code>CXString clang_codeCompleteGetObjCSelector(CXCodeCompleteResults*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4797</i>
     */
    CXString.ByValue clang_codeCompleteGetObjCSelector(CXCodeCompleteResults Results);

    /**
     * \brief Return a version string, suitable for showing to a user, but not<br>
     * intended to be parsed (the format is not guaranteed to be stable).<br>
     * Original signature : <code>CXString clang_getClangVersion()</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4814</i>
     */
    CXString.ByValue clang_getClangVersion();

    /**
     * \brief Enable/disable crash recovery.<br>
     * * \param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero<br>
     * value enables crash recovery, while 0 disables it.<br>
     * Original signature : <code>void clang_toggleCrashRecovery(unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4823</i>
     */
    void clang_toggleCrashRecovery(int isEnabled);

    /**
     * \brief Visit the set of preprocessor inclusions in a translation unit.<br>
     * The visitor function is called with the provided data for every included<br>
     * file.  This does not include headers included by the PCH file (unless one<br>
     * is inspecting the inclusions in the PCH file itself).<br>
     * Original signature : <code>void clang_getInclusions(CXTranslationUnit, CXInclusionVisitor, CXClientData)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4847</i>
     */
    void clang_getInclusions(ClangLibrary.CXTranslationUnit tu, ClangLibrary.CXInclusionVisitor visitor, Pointer client_data);

    /**
     * \brief Retrieve a remapping.<br>
     * * \param path the path that contains metadata about remappings.<br>
     * * \returns the requested remapping. This remapping must be freed<br>
     * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.<br>
     * Original signature : <code>CXRemapping clang_getRemappings(const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4873</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getRemappings(java.lang.String)} and {@link #clang_getRemappings(com.sun.jna.Pointer)} instead
     */
    @Deprecated
    Pointer clang_getRemappings(Pointer path);

    /**
     * \brief Retrieve a remapping.<br>
     * * \param path the path that contains metadata about remappings.<br>
     * * \returns the requested remapping. This remapping must be freed<br>
     * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.<br>
     * Original signature : <code>CXRemapping clang_getRemappings(const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4873</i>
     */
    Pointer clang_getRemappings(String path);

    /**
     * Original signature : <code>CXRemapping clang_getRemappingsFromFileList(const char**, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4886</i><br>
     *
     * @deprecated use the safer methods {@link #clang_getRemappingsFromFileList(java.lang.String[], int)} and {@link #clang_getRemappingsFromFileList(com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    Pointer clang_getRemappingsFromFileList(PointerByReference filePaths, int numFiles);

    /**
     * Original signature : <code>CXRemapping clang_getRemappingsFromFileList(const char**, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4886</i>
     */
    Pointer clang_getRemappingsFromFileList(String filePaths[], int numFiles);

    /**
     * \brief Determine the number of remappings.<br>
     * Original signature : <code>int clang_remap_getNumFiles(CXRemapping)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4892</i>
     */
    int clang_remap_getNumFiles(Pointer CXRemapping1);

    /**
     * \brief Get the original and the associated filename from the remapping.<br>
     * <br>
     * \param original If non-NULL, will be set to the original filename.<br>
     * * \param transformed If non-NULL, will be set to the filename that the original<br>
     * is associated with.<br>
     * Original signature : <code>void clang_remap_getFilenames(CXRemapping, unsigned, CXString*, CXString*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4902</i>
     */
    void clang_remap_getFilenames(Pointer CXRemapping1, int index, CXString original, CXString transformed);

    /**
     * \brief Dispose the remapping.<br>
     * Original signature : <code>void clang_remap_dispose(CXRemapping)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4908</i>
     */
    void clang_remap_dispose(Pointer CXRemapping1);

    /**
     * \brief Find references of a declaration in a specific file.<br>
     * <br>
     * \param cursor pointing to a declaration or a reference of one.<br>
     * * \param file to search for references.<br>
     * * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for<br>
     * each reference found.<br>
     * The CXSourceRange will point inside the file; if the reference is inside<br>
     * a macro (and not a macro argument) the CXSourceRange will be invalid.<br>
     * Original signature : <code>void clang_findReferencesInFile(CXCursor, CXFile, CXCursorAndRangeVisitor)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:4941</i>
     */
    void clang_findReferencesInFile(CXCursor.ByValue cursor, Pointer file, clang.CXCursorAndRangeVisitor.ByValue visitor);

    /**
     * Original signature : <code>int clang_index_isEntityObjCContainerKind(CXIdxEntityKind)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5315</i>
     */
    int clang_index_isEntityObjCContainerKind(int CXIdxEntityKind1);

    /**
     * Original signature : <code>CXIdxObjCContainerDeclInfo* clang_index_getObjCContainerDeclInfo(const CXIdxDeclInfo*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5316</i>
     */
    CXIdxObjCContainerDeclInfo clang_index_getObjCContainerDeclInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);

    /**
     * Original signature : <code>CXIdxObjCInterfaceDeclInfo* clang_index_getObjCInterfaceDeclInfo(const CXIdxDeclInfo*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5319</i>
     */
    CXIdxObjCInterfaceDeclInfo clang_index_getObjCInterfaceDeclInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);

    /**
     * Original signature : <code>CXIdxObjCCategoryDeclInfo* clang_index_getObjCCategoryDeclInfo(const CXIdxDeclInfo*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5323</i>
     */
    CXIdxObjCCategoryDeclInfo clang_index_getObjCCategoryDeclInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);

    /**
     * Original signature : <code>CXIdxObjCProtocolRefListInfo* clang_index_getObjCProtocolRefListInfo(const CXIdxDeclInfo*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5326</i>
     */
    CXIdxObjCProtocolRefListInfo clang_index_getObjCProtocolRefListInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);

    /**
     * Original signature : <code>CXIdxObjCPropertyDeclInfo* clang_index_getObjCPropertyDeclInfo(const CXIdxDeclInfo*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5329</i>
     */
    CXIdxObjCPropertyDeclInfo clang_index_getObjCPropertyDeclInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);

    /**
     * Original signature : <code>CXIdxIBOutletCollectionAttrInfo* clang_index_getIBOutletCollectionAttrInfo(const CXIdxAttrInfo*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5332</i>
     */
    CXIdxIBOutletCollectionAttrInfo clang_index_getIBOutletCollectionAttrInfo(CXIdxAttrInfo CXIdxAttrInfoPtr1);

    /**
     * Original signature : <code>CXIdxCXXClassDeclInfo* clang_index_getCXXClassDeclInfo(const CXIdxDeclInfo*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5335</i>
     */
    CXIdxCXXClassDeclInfo clang_index_getCXXClassDeclInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);

    /**
     * \brief For retrieving a custom CXIdxClientContainer attached to a<br>
     * container.<br>
     * Original signature : <code>CXIdxClientContainer clang_index_getClientContainer(const CXIdxContainerInfo*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5342</i>
     */
    Pointer clang_index_getClientContainer(CXIdxContainerInfo CXIdxContainerInfoPtr1);

    /**
     * \brief For setting a custom CXIdxClientContainer attached to a<br>
     * container.<br>
     * Original signature : <code>void clang_index_setClientContainer(const CXIdxContainerInfo*, CXIdxClientContainer)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5349</i>
     */
    void clang_index_setClientContainer(CXIdxContainerInfo CXIdxContainerInfoPtr1, Pointer CXIdxClientContainer1);

    /**
     * \brief For retrieving a custom CXIdxClientEntity attached to an entity.<br>
     * Original signature : <code>CXIdxClientEntity clang_index_getClientEntity(const CXIdxEntityInfo*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5355</i>
     */
    Pointer clang_index_getClientEntity(CXIdxEntityInfo CXIdxEntityInfoPtr1);

    /**
     * \brief For setting a custom CXIdxClientEntity attached to an entity.<br>
     * Original signature : <code>void clang_index_setClientEntity(const CXIdxEntityInfo*, CXIdxClientEntity)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5361</i>
     */
    void clang_index_setClientEntity(CXIdxEntityInfo CXIdxEntityInfoPtr1, Pointer CXIdxClientEntity1);

    /**
     * \brief An indexing action/session, to be applied to one or multiple<br>
     * translation units.<br>
     * * \param CIdx The index object with which the index action will be associated.<br>
     * Original signature : <code>CXIndexAction clang_IndexAction_create(CXIndex)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5376</i>
     */
    Pointer clang_IndexAction_create(Pointer CIdx);

    /**
     * \brief Destroy the given index action.<br>
     * * The index action must not be destroyed until all of the translation units<br>
     * created within that index action have been destroyed.<br>
     * Original signature : <code>void clang_IndexAction_dispose(CXIndexAction)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5384</i>
     */
    void clang_IndexAction_dispose(Pointer CXIndexAction1);

    /**
     * \brief Index the given source file and the translation unit corresponding<br>
     * to that file via callbacks implemented through #IndexerCallbacks.<br>
     * * \param client_data pointer data supplied by the client, which will<br>
     * be passed to the invoked callbacks.<br>
     * * \param index_callbacks Pointer to indexing callbacks that the client<br>
     * implements.<br>
     * * \param index_callbacks_size Size of #IndexerCallbacks structure that gets<br>
     * passed in index_callbacks.<br>
     * * \param index_options A bitmask of options that affects how indexing is<br>
     * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.<br>
     * * \param out_TU [out] pointer to store a CXTranslationUnit that can be reused<br>
     * after indexing is finished. Set to NULL if you do not require it.<br>
     * * \returns If there is a failure from which the there is no recovery, returns<br>
     * non-zero, otherwise returns 0.<br>
     * * The rest of the parameters are the same as #clang_parseTranslationUnit.<br>
     * Original signature : <code>int clang_indexSourceFile(CXIndexAction, CXClientData, IndexerCallbacks*, unsigned, unsigned, const char*, const const char**, int, CXUnsavedFile*, unsigned, CXTranslationUnit*, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5449</i><br>
     *
     * @deprecated use the safer methods {@link #clang_indexSourceFile(com.sun.jna.Pointer, com.sun.jna.Pointer, clang.IndexerCallbacks, int, int, java.lang.String, byte[][], int, clang.CXUnsavedFile, int, clang.ClangLibrary.CXTranslationUnit, int)} and {@link #clang_indexSourceFile(com.sun.jna.Pointer, com.sun.jna.Pointer, clang.IndexerCallbacks, int, int, com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, int, clang.CXUnsavedFile, int, clang.ClangLibrary.CXTranslationUnit, int)} instead
     */
    @Deprecated
    int clang_indexSourceFile(Pointer CXIndexAction1, Pointer client_data, IndexerCallbacks index_callbacks, int index_callbacks_size, int index_options, Pointer source_filename, PointerByReference command_line_args, int num_command_line_args, CXUnsavedFile unsaved_files, int num_unsaved_files, ClangLibrary.CXTranslationUnit out_TU, int TU_options);

    /**
     * \brief Index the given source file and the translation unit corresponding<br>
     * to that file via callbacks implemented through #IndexerCallbacks.<br>
     * * \param client_data pointer data supplied by the client, which will<br>
     * be passed to the invoked callbacks.<br>
     * * \param index_callbacks Pointer to indexing callbacks that the client<br>
     * implements.<br>
     * * \param index_callbacks_size Size of #IndexerCallbacks structure that gets<br>
     * passed in index_callbacks.<br>
     * * \param index_options A bitmask of options that affects how indexing is<br>
     * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.<br>
     * * \param out_TU [out] pointer to store a CXTranslationUnit that can be reused<br>
     * after indexing is finished. Set to NULL if you do not require it.<br>
     * * \returns If there is a failure from which the there is no recovery, returns<br>
     * non-zero, otherwise returns 0.<br>
     * * The rest of the parameters are the same as #clang_parseTranslationUnit.<br>
     * Original signature : <code>int clang_indexSourceFile(CXIndexAction, CXClientData, IndexerCallbacks*, unsigned, unsigned, const char*, const const char**, int, CXUnsavedFile*, unsigned, CXTranslationUnit*, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5449</i>
     */
    int clang_indexSourceFile(Pointer CXIndexAction1, Pointer client_data, IndexerCallbacks index_callbacks, int index_callbacks_size, int index_options, String source_filename, byte[] command_line_args[], int num_command_line_args, CXUnsavedFile unsaved_files, int num_unsaved_files, ClangLibrary.CXTranslationUnit out_TU, int TU_options);

    /**
     * \brief Index the given translation unit via callbacks implemented through<br>
     * #IndexerCallbacks.<br>
     * <br>
     * The order of callback invocations is not guaranteed to be the same as<br>
     * when indexing a source file. The high level order will be:<br>
     * <br>
     * -Preprocessor callbacks invocations<br>
     * -Declaration/reference callbacks invocations<br>
     * -Diagnostic callback invocations<br>
     * * The parameters are the same as #clang_indexSourceFile.<br>
     * <br>
     * \returns If there is a failure from which the there is no recovery, returns<br>
     * non-zero, otherwise returns 0.<br>
     * Original signature : <code>int clang_indexTranslationUnit(CXIndexAction, CXClientData, IndexerCallbacks*, unsigned, unsigned, CXTranslationUnit)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5478</i>
     */
    int clang_indexTranslationUnit(Pointer CXIndexAction1, Pointer client_data, IndexerCallbacks index_callbacks, int index_callbacks_size, int index_options, ClangLibrary.CXTranslationUnit CXTranslationUnit1);

    /**
     * \brief Retrieve the CXIdxFile, file, line, column, and offset represented by<br>
     * the given CXIdxLoc.<br>
     * * If the location refers into a macro expansion, retrieves the<br>
     * location of the macro expansion and if it refers into a macro argument<br>
     * retrieves the location of the argument.<br>
     * Original signature : <code>void clang_indexLoc_getFileLocation(CXIdxLoc, CXIdxClientFile*, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5493</i><br>
     *
     * @deprecated use the safer methods {@link #clang_indexLoc_getFileLocation(clang.CXIdxLoc.ByValue, com.sun.jna.Pointer, com.sun.jna.Pointer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_indexLoc_getFileLocation(clang.CXIdxLoc.ByValue, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void clang_indexLoc_getFileLocation(clang.CXIdxLoc.ByValue loc, Pointer indexFile, Pointer file, IntByReference line, IntByReference column, IntByReference offset);

    /**
     * \brief Retrieve the CXIdxFile, file, line, column, and offset represented by<br>
     * the given CXIdxLoc.<br>
     * * If the location refers into a macro expansion, retrieves the<br>
     * location of the macro expansion and if it refers into a macro argument<br>
     * retrieves the location of the argument.<br>
     * Original signature : <code>void clang_indexLoc_getFileLocation(CXIdxLoc, CXIdxClientFile*, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5493</i>
     */
    void clang_indexLoc_getFileLocation(clang.CXIdxLoc.ByValue loc, Pointer indexFile, Pointer file, IntBuffer line, IntBuffer column, IntBuffer offset);

    /**
     * Original signature : <code>CXSourceLocation clang_indexLoc_getCXSourceLocation(CXIdxLoc)</code><br>
     * <i>native declaration : src/main/c/clang-c/Index.h:5504</i>
     */
    CXSourceLocation.ByValue clang_indexLoc_getCXSourceLocation(clang.CXIdxLoc.ByValue loc);

    /**
     * \brief Creates a compilation database from the database found in directory<br>
     * buildDir. For example, CMake can output a compile_commands.json which can<br>
     * be used to build the database.<br>
     * * It must be freed by \c clang_CompilationDatabase_dispose.<br>
     * Original signature : <code>CXCompilationDatabase clang_CompilationDatabase_fromDirectory(const char*, CXCompilationDatabase_Error*)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:60</i><br>
     *
     * @deprecated use the safer methods {@link #clang_CompilationDatabase_fromDirectory(java.lang.String, java.nio.IntBuffer)} and {@link #clang_CompilationDatabase_fromDirectory(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    Pointer clang_CompilationDatabase_fromDirectory(Pointer BuildDir, IntByReference ErrorCode);

    /**
     * \brief Creates a compilation database from the database found in directory<br>
     * buildDir. For example, CMake can output a compile_commands.json which can<br>
     * be used to build the database.<br>
     * * It must be freed by \c clang_CompilationDatabase_dispose.<br>
     * Original signature : <code>CXCompilationDatabase clang_CompilationDatabase_fromDirectory(const char*, CXCompilationDatabase_Error*)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:60</i>
     */
    Pointer clang_CompilationDatabase_fromDirectory(String BuildDir, IntBuffer ErrorCode);

    /**
     * \brief Free the given compilation database<br>
     * Original signature : <code>void clang_CompilationDatabase_dispose(CXCompilationDatabase)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:67</i>
     */
    void clang_CompilationDatabase_dispose(Pointer CXCompilationDatabase1);

    /**
     * \brief Find the compile commands used for a file. The compile commands<br>
     * must be freed by \c clang_CompileCommands_dispose.<br>
     * Original signature : <code>CXCompileCommands clang_CompilationDatabase_getCompileCommands(CXCompilationDatabase, const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:74</i><br>
     *
     * @deprecated use the safer methods {@link #clang_CompilationDatabase_getCompileCommands(com.sun.jna.Pointer, java.lang.String)} and {@link #clang_CompilationDatabase_getCompileCommands(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    Pointer clang_CompilationDatabase_getCompileCommands(Pointer CXCompilationDatabase1, Pointer CompleteFileName);

    /**
     * \brief Find the compile commands used for a file. The compile commands<br>
     * must be freed by \c clang_CompileCommands_dispose.<br>
     * Original signature : <code>CXCompileCommands clang_CompilationDatabase_getCompileCommands(CXCompilationDatabase, const char*)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:74</i>
     */
    Pointer clang_CompilationDatabase_getCompileCommands(Pointer CXCompilationDatabase1, String CompleteFileName);

    /**
     * \brief Get all the compile commands in the given compilation database.<br>
     * Original signature : <code>CXCompileCommands clang_CompilationDatabase_getAllCompileCommands(CXCompilationDatabase)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:81</i>
     */
    Pointer clang_CompilationDatabase_getAllCompileCommands(Pointer CXCompilationDatabase1);

    /**
     * \brief Free the given CompileCommands<br>
     * Original signature : <code>void clang_CompileCommands_dispose(CXCompileCommands)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:87</i>
     */
    void clang_CompileCommands_dispose(Pointer CXCompileCommands1);

    /**
     * \brief Get the number of CompileCommand we have for a file<br>
     * Original signature : <code>int clang_CompileCommands_getSize(CXCompileCommands)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:92</i>
     */
    int clang_CompileCommands_getSize(Pointer CXCompileCommands1);

    /**
     * \brief Get the I'th CompileCommand for a file<br>
     * * Note : 0 <= i < clang_CompileCommands_getSize(CXCompileCommands)<br>
     * Original signature : <code>CXCompileCommand clang_CompileCommands_getCommand(CXCompileCommands, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:100</i>
     */
    Pointer clang_CompileCommands_getCommand(Pointer CXCompileCommands1, int I);

    /**
     * \brief Get the working directory where the CompileCommand was executed from<br>
     * Original signature : <code>CXString clang_CompileCommand_getDirectory(CXCompileCommand)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:106</i>
     */
    CXString.ByValue clang_CompileCommand_getDirectory(Pointer CXCompileCommand1);

    /**
     * \brief Get the number of arguments in the compiler invocation.<br>
     * Original signature : <code>int clang_CompileCommand_getNumArgs(CXCompileCommand)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:113</i>
     */
    int clang_CompileCommand_getNumArgs(Pointer CXCompileCommand1);

    /**
     * \brief Get the I'th argument value in the compiler invocations<br>
     * * Invariant :<br>
     * - argument 0 is the compiler executable<br>
     * Original signature : <code>CXString clang_CompileCommand_getArg(CXCompileCommand, unsigned)</code><br>
     * <i>native declaration : src/main/c/clang-c/CXCompilationDatabase.h:122</i>
     */
    CXString.ByValue clang_CompileCommand_getArg(Pointer CXCompileCommand1, int I);

    public static class CXTranslationUnit extends PointerType {
        public CXTranslationUnit(Pointer address) {
            super(address);
        }

        public CXTranslationUnit() {
            super();
        }
    }

    public static class time_t extends PointerType {
        public time_t(Pointer address) {
            super(address);
        }

        public time_t() {
            super();
        }
    }

    public static class include_len extends PointerType {
        public include_len(Pointer address) {
            super(address);
        }

        public include_len() {
            super();
        }
    }

    public static class CXCursorSet extends PointerType {
        public CXCursorSet(Pointer address) {
            super(address);
        }

        public CXCursorSet() {
            super();
        }
    }
}
