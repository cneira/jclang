package clang;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.IntBuffer;
/**
 * JNA Wrapper for library <b>Clang</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface ClangLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "Clang";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(ClangLibrary.JNA_LIBRARY_NAME);
	public static final ClangLibrary INSTANCE = (ClangLibrary)Native.loadLibrary(ClangLibrary.JNA_LIBRARY_NAME, ClangLibrary.class);
	/**
	 * \brief Describes the availability of a particular entity, which indicates<br>
	 * whether the use of this entity will result in a warning or error due to<br>
	 * it being deprecated or unavailable.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:101</i><br>
	 * enum values
	 */
	/**
	 * \brief Describes the availability of a particular entity, which indicates<br>
	 * whether the use of this entity will result in a warning or error due to<br>
	 * it being deprecated or unavailable.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:101</i><br>
	 * enum values
	 */
	public static interface CXAvailabilityKind {
		/**
		 * \brief The entity is available.<br>
		 * \brief The entity is available.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:105</i>
		 */
		public static final int CXAvailability_Available = (int)0;
		/**
		 * \brief The entity is available, but has been deprecated (and its use is<br>
		 * not recommended).<br>
		 * \brief The entity is available, but has been deprecated (and its use is<br>
		 * not recommended).<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:110</i>
		 */
		public static final int CXAvailability_Deprecated = (int)1;
		/**
		 * \brief The entity is not available; any use of it will be an error.<br>
		 * \brief The entity is not available; any use of it will be an error.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:114</i>
		 */
		public static final int CXAvailability_NotAvailable = (int)2;
		/**
		 * \brief The entity is available, but not accessible; any use of it will be<br>
		 * an error.<br>
		 * \brief The entity is available, but not accessible; any use of it will be<br>
		 * an error.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:119</i>
		 */
		public static final int CXAvailability_NotAccessible = (int)3;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXGlobalOptFlags {
		/**
		 * \brief Used to indicate that no special CXIndex options are needed.<br>
		 * \brief Used to indicate that no special CXIndex options are needed.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:200</i>
		 */
		public static final int CXGlobalOpt_None = (int)0;
		/**
		 * \brief Used to indicate that threads that libclang creates for indexing<br>
		 * purposes should use background priority.<br>
		 * * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,<br>
		 * #clang_parseTranslationUnit, #clang_saveTranslationUnit.<br>
		 * \brief Used to indicate that threads that libclang creates for indexing<br>
		 * purposes should use background priority.<br>
		 * * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,<br>
		 * #clang_parseTranslationUnit, #clang_saveTranslationUnit.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:209</i>
		 */
		public static final int CXGlobalOpt_ThreadBackgroundPriorityForIndexing = (int)1;
		/**
		 * \brief Used to indicate that threads that libclang creates for editing<br>
		 * purposes should use background priority.<br>
		 * * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,<br>
		 * #clang_annotateTokens<br>
		 * \brief Used to indicate that threads that libclang creates for editing<br>
		 * purposes should use background priority.<br>
		 * * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,<br>
		 * #clang_annotateTokens<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:218</i>
		 */
		public static final int CXGlobalOpt_ThreadBackgroundPriorityForEditing = (int)2;
		/**
		 * \brief Used to indicate that all threads that libclang creates should use<br>
		 * background priority.<br>
		 * \brief Used to indicate that all threads that libclang creates should use<br>
		 * background priority.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:224</i>
		 */
		public static final int CXGlobalOpt_ThreadBackgroundPriorityForAll = (int)((int)ClangLibrary.CXGlobalOptFlags.CXGlobalOpt_ThreadBackgroundPriorityForIndexing | (int)ClangLibrary.CXGlobalOptFlags.CXGlobalOpt_ThreadBackgroundPriorityForEditing);
	};
	/**
	 * \brief Describes the severity of a particular diagnostic.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:534</i><br>
	 * enum values
	 */
	/**
	 * \brief Describes the severity of a particular diagnostic.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:534</i><br>
	 * enum values
	 */
	public static interface CXDiagnosticSeverity {
		/**
		 * \brief A diagnostic that has been suppressed, e.g., by a command-line<br>
		 * option.<br>
		 * \brief A diagnostic that has been suppressed, e.g., by a command-line<br>
		 * option.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:539</i>
		 */
		public static final int CXDiagnostic_Ignored = (int)0;
		/**
		 * \brief This diagnostic is a note that should be attached to the<br>
		 * previous (non-note) diagnostic.<br>
		 * \brief This diagnostic is a note that should be attached to the<br>
		 * previous (non-note) diagnostic.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:545</i>
		 */
		public static final int CXDiagnostic_Note = (int)1;
		/**
		 * \brief This diagnostic indicates suspicious code that may not be<br>
		 * wrong.<br>
		 * \brief This diagnostic indicates suspicious code that may not be<br>
		 * wrong.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:551</i>
		 */
		public static final int CXDiagnostic_Warning = (int)2;
		/**
		 * \brief This diagnostic indicates that the code is ill-formed.<br>
		 * \brief This diagnostic indicates that the code is ill-formed.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:556</i>
		 */
		public static final int CXDiagnostic_Error = (int)3;
		/**
		 * \brief This diagnostic indicates that the code is ill-formed such<br>
		 * that future parser recovery is unlikely to produce useful<br>
		 * results.<br>
		 * \brief This diagnostic indicates that the code is ill-formed such<br>
		 * that future parser recovery is unlikely to produce useful<br>
		 * results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:563</i>
		 */
		public static final int CXDiagnostic_Fatal = (int)4;
	};
	/**
	 * \brief Describes the kind of error that occurred (if any) in a call to<br>
	 * \c clang_loadDiagnostics.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:599</i><br>
	 * enum values
	 */
	/**
	 * \brief Describes the kind of error that occurred (if any) in a call to<br>
	 * \c clang_loadDiagnostics.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:599</i><br>
	 * enum values
	 */
	public static interface CXLoadDiag_Error {
		/**
		 * \brief Indicates that no error occurred.<br>
		 * \brief Indicates that no error occurred.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:603</i>
		 */
		public static final int CXLoadDiag_None = (int)0;
		/**
		 * \brief Indicates that an unknown error occurred while attempting to<br>
		 * deserialize diagnostics.<br>
		 * \brief Indicates that an unknown error occurred while attempting to<br>
		 * deserialize diagnostics.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:609</i>
		 */
		public static final int CXLoadDiag_Unknown = (int)1;
		/**
		 * \brief Indicates that the file containing the serialized diagnostics<br>
		 * could not be opened.<br>
		 * \brief Indicates that the file containing the serialized diagnostics<br>
		 * could not be opened.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:615</i>
		 */
		public static final int CXLoadDiag_CannotLoad = (int)2;
		/**
		 * \brief Indicates that the serialized diagnostics file is invalid or<br>
		 * corrupt.<br>
		 * \brief Indicates that the serialized diagnostics file is invalid or<br>
		 * corrupt.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:621</i>
		 */
		public static final int CXLoadDiag_InvalidFile = (int)3;
	};
	/**
	 * \brief Options to control the display of diagnostics.<br>
	 * * The values in this enum are meant to be combined to customize the<br>
	 * behavior of \c clang_displayDiagnostic().<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:692</i><br>
	 * enum values
	 */
	/**
	 * \brief Options to control the display of diagnostics.<br>
	 * * The values in this enum are meant to be combined to customize the<br>
	 * behavior of \c clang_displayDiagnostic().<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:692</i><br>
	 * enum values
	 */
	public static interface CXDiagnosticDisplayOptions {
		/**
		 * \brief Display the source-location information where the<br>
		 * diagnostic was located.<br>
		 * * When set, diagnostics will be prefixed by the file, line, and<br>
		 * (optionally) column to which the diagnostic refers. For example,<br>
		 * * \code<br>
		 * test.c:28: warning: extra tokens at end of #endif directive<br>
		 * \endcode<br>
		 * * This option corresponds to the clang flag \c -fshow-source-location.<br>
		 * \brief Display the source-location information where the<br>
		 * diagnostic was located.<br>
		 * * When set, diagnostics will be prefixed by the file, line, and<br>
		 * (optionally) column to which the diagnostic refers. For example,<br>
		 * * \code<br>
		 * test.c:28: warning: extra tokens at end of #endif directive<br>
		 * \endcode<br>
		 * * This option corresponds to the clang flag \c -fshow-source-location.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:706</i>
		 */
		public static final int CXDiagnostic_DisplaySourceLocation = (int)1;
		/**
		 * \brief If displaying the source-location information of the<br>
		 * diagnostic, also include the column number.<br>
		 * * This option corresponds to the clang flag \c -fshow-column.<br>
		 * \brief If displaying the source-location information of the<br>
		 * diagnostic, also include the column number.<br>
		 * * This option corresponds to the clang flag \c -fshow-column.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:714</i>
		 */
		public static final int CXDiagnostic_DisplayColumn = (int)2;
		/**
		 * \brief If displaying the source-location information of the<br>
		 * diagnostic, also include information about source ranges in a<br>
		 * machine-parsable format.<br>
		 * * This option corresponds to the clang flag<br>
		 * \c -fdiagnostics-print-source-range-info.<br>
		 * \brief If displaying the source-location information of the<br>
		 * diagnostic, also include information about source ranges in a<br>
		 * machine-parsable format.<br>
		 * * This option corresponds to the clang flag<br>
		 * \c -fdiagnostics-print-source-range-info.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:724</i>
		 */
		public static final int CXDiagnostic_DisplaySourceRanges = (int)4;
		/**
		 * \brief Display the option name associated with this diagnostic, if any.<br>
		 * * The option name displayed (e.g., -Wconversion) will be placed in brackets<br>
		 * after the diagnostic text. This option corresponds to the clang flag<br>
		 * \c -fdiagnostics-show-option.<br>
		 * \brief Display the option name associated with this diagnostic, if any.<br>
		 * * The option name displayed (e.g., -Wconversion) will be placed in brackets<br>
		 * after the diagnostic text. This option corresponds to the clang flag<br>
		 * \c -fdiagnostics-show-option.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:733</i>
		 */
		public static final int CXDiagnostic_DisplayOption = (int)8;
		/**
		 * \brief Display the category number associated with this diagnostic, if any.<br>
		 * * The category number is displayed within brackets after the diagnostic text.<br>
		 * This option corresponds to the clang flag <br>
		 * \c -fdiagnostics-show-category=id.<br>
		 * \brief Display the category number associated with this diagnostic, if any.<br>
		 * * The category number is displayed within brackets after the diagnostic text.<br>
		 * This option corresponds to the clang flag <br>
		 * \c -fdiagnostics-show-category=id.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:742</i>
		 */
		public static final int CXDiagnostic_DisplayCategoryId = (int)16;
		/**
		 * \brief Display the category name associated with this diagnostic, if any.<br>
		 * * The category name is displayed within brackets after the diagnostic text.<br>
		 * This option corresponds to the clang flag <br>
		 * \c -fdiagnostics-show-category=name.<br>
		 * \brief Display the category name associated with this diagnostic, if any.<br>
		 * * The category name is displayed within brackets after the diagnostic text.<br>
		 * This option corresponds to the clang flag <br>
		 * \c -fdiagnostics-show-category=name.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:751</i>
		 */
		public static final int CXDiagnostic_DisplayCategoryName = (int)32;
	};
	/**
	 * \brief Flags that control the creation of translation units.<br>
	 * * The enumerators in this enumeration type are meant to be bitwise<br>
	 * ORed together to specify which options should be used when<br>
	 * constructing the translation unit.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:985</i><br>
	 * enum values
	 */
	/**
	 * \brief Flags that control the creation of translation units.<br>
	 * * The enumerators in this enumeration type are meant to be bitwise<br>
	 * ORed together to specify which options should be used when<br>
	 * constructing the translation unit.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:985</i><br>
	 * enum values
	 */
	public static interface CXTranslationUnit_Flags {
		/**
		 * \brief Used to indicate that no special translation-unit options are<br>
		 * needed.<br>
		 * \brief Used to indicate that no special translation-unit options are<br>
		 * needed.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:990</i>
		 */
		public static final int CXTranslationUnit_None = (int)0;
		/**
		 * \brief Used to indicate that the parser should construct a "detailed"<br>
		 * preprocessing record, including all macro definitions and instantiations.<br>
		 * * Constructing a detailed preprocessing record requires more memory<br>
		 * and time to parse, since the information contained in the record<br>
		 * is usually not retained. However, it can be useful for<br>
		 * applications that require more detailed information about the<br>
		 * behavior of the preprocessor.<br>
		 * \brief Used to indicate that the parser should construct a "detailed"<br>
		 * preprocessing record, including all macro definitions and instantiations.<br>
		 * * Constructing a detailed preprocessing record requires more memory<br>
		 * and time to parse, since the information contained in the record<br>
		 * is usually not retained. However, it can be useful for<br>
		 * applications that require more detailed information about the<br>
		 * behavior of the preprocessor.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1002</i>
		 */
		public static final int CXTranslationUnit_DetailedPreprocessingRecord = (int)1;
		/**
		 * \brief Used to indicate that the translation unit is incomplete.<br>
		 * * When a translation unit is considered "incomplete", semantic<br>
		 * analysis that is typically performed at the end of the<br>
		 * translation unit will be suppressed. For example, this suppresses<br>
		 * the completion of tentative declarations in C and of<br>
		 * instantiation of implicitly-instantiation function templates in<br>
		 * C++. This option is typically used when parsing a header with the<br>
		 * intent of producing a precompiled header.<br>
		 * \brief Used to indicate that the translation unit is incomplete.<br>
		 * * When a translation unit is considered "incomplete", semantic<br>
		 * analysis that is typically performed at the end of the<br>
		 * translation unit will be suppressed. For example, this suppresses<br>
		 * the completion of tentative declarations in C and of<br>
		 * instantiation of implicitly-instantiation function templates in<br>
		 * C++. This option is typically used when parsing a header with the<br>
		 * intent of producing a precompiled header.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1015</i>
		 */
		public static final int CXTranslationUnit_Incomplete = (int)2;
		/**
		 * \brief Used to indicate that the translation unit should be built with an <br>
		 * implicit precompiled header for the preamble.<br>
		 * * An implicit precompiled header is used as an optimization when a<br>
		 * particular translation unit is likely to be reparsed many times<br>
		 * when the sources aren't changing that often. In this case, an<br>
		 * implicit precompiled header will be built containing all of the<br>
		 * initial includes at the top of the main file (what we refer to as<br>
		 * the "preamble" of the file). In subsequent parses, if the<br>
		 * preamble or the files in it have not changed, \c<br>
		 * clang_reparseTranslationUnit() will re-use the implicit<br>
		 * precompiled header to improve parsing performance.<br>
		 * \brief Used to indicate that the translation unit should be built with an <br>
		 * implicit precompiled header for the preamble.<br>
		 * * An implicit precompiled header is used as an optimization when a<br>
		 * particular translation unit is likely to be reparsed many times<br>
		 * when the sources aren't changing that often. In this case, an<br>
		 * implicit precompiled header will be built containing all of the<br>
		 * initial includes at the top of the main file (what we refer to as<br>
		 * the "preamble" of the file). In subsequent parses, if the<br>
		 * preamble or the files in it have not changed, \c<br>
		 * clang_reparseTranslationUnit() will re-use the implicit<br>
		 * precompiled header to improve parsing performance.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1031</i>
		 */
		public static final int CXTranslationUnit_PrecompiledPreamble = (int)4;
		/**
		 * \brief Used to indicate that the translation unit should cache some<br>
		 * code-completion results with each reparse of the source file.<br>
		 * * Caching of code-completion results is a performance optimization that<br>
		 * introduces some overhead to reparsing but improves the performance of<br>
		 * code-completion operations.<br>
		 * \brief Used to indicate that the translation unit should cache some<br>
		 * code-completion results with each reparse of the source file.<br>
		 * * Caching of code-completion results is a performance optimization that<br>
		 * introduces some overhead to reparsing but improves the performance of<br>
		 * code-completion operations.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1041</i>
		 */
		public static final int CXTranslationUnit_CacheCompletionResults = (int)8;
		/**
		 * \brief Used to indicate that the translation unit will be serialized with<br>
		 * \c clang_saveTranslationUnit.<br>
		 * * This option is typically used when parsing a header with the intent of<br>
		 * producing a precompiled header.<br>
		 * \brief Used to indicate that the translation unit will be serialized with<br>
		 * \c clang_saveTranslationUnit.<br>
		 * * This option is typically used when parsing a header with the intent of<br>
		 * producing a precompiled header.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1050</i>
		 */
		public static final int CXTranslationUnit_ForSerialization = (int)16;
		/**
		 * \brief DEPRECATED: Enabled chained precompiled preambles in C++.<br>
		 * * Note: this is a *temporary* option that is available only while<br>
		 * we are testing C++ precompiled preamble support. It is deprecated.<br>
		 * \brief DEPRECATED: Enabled chained precompiled preambles in C++.<br>
		 * * Note: this is a *temporary* option that is available only while<br>
		 * we are testing C++ precompiled preamble support. It is deprecated.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1058</i>
		 */
		public static final int CXTranslationUnit_CXXChainedPCH = (int)32;
		/**
		 * \brief Used to indicate that function/method bodies should be skipped while<br>
		 * parsing.<br>
		 * * This option can be used to search for declarations/definitions while<br>
		 * ignoring the usages.<br>
		 * \brief Used to indicate that function/method bodies should be skipped while<br>
		 * parsing.<br>
		 * * This option can be used to search for declarations/definitions while<br>
		 * ignoring the usages.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1067</i>
		 */
		public static final int CXTranslationUnit_SkipFunctionBodies = (int)64;
		/**
		 * \brief Used to indicate that brief documentation comments should be<br>
		 * included into the set of code completions returned from this translation<br>
		 * unit.<br>
		 * \brief Used to indicate that brief documentation comments should be<br>
		 * included into the set of code completions returned from this translation<br>
		 * unit.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1074</i>
		 */
		public static final int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = (int)128;
	};
	/**
	 * \brief Flags that control how translation units are saved.<br>
	 * * The enumerators in this enumeration type are meant to be bitwise<br>
	 * ORed together to specify which options should be used when<br>
	 * saving the translation unit.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1148</i><br>
	 * enum values
	 */
	/**
	 * \brief Flags that control how translation units are saved.<br>
	 * * The enumerators in this enumeration type are meant to be bitwise<br>
	 * ORed together to specify which options should be used when<br>
	 * saving the translation unit.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1148</i><br>
	 * enum values
	 */
	public static interface CXSaveTranslationUnit_Flags {
		/**
		 * \brief Used to indicate that no special saving options are needed.<br>
		 * \brief Used to indicate that no special saving options are needed.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1152</i>
		 */
		public static final int CXSaveTranslationUnit_None = (int)0;
	};
	/**
	 * \brief Describes the kind of error that occurred (if any) in a call to<br>
	 * \c clang_saveTranslationUnit().<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1170</i><br>
	 * enum values
	 */
	/**
	 * \brief Describes the kind of error that occurred (if any) in a call to<br>
	 * \c clang_saveTranslationUnit().<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1170</i><br>
	 * enum values
	 */
	public static interface CXSaveError {
		/**
		 * \brief Indicates that no error occurred while saving a translation unit.<br>
		 * \brief Indicates that no error occurred while saving a translation unit.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1174</i>
		 */
		public static final int CXSaveError_None = (int)0;
		/**
		 * \brief Indicates that an unknown error occurred while attempting to save<br>
		 * the file.<br>
		 * * This error typically indicates that file I/O failed when attempting to <br>
		 * write the file.<br>
		 * \brief Indicates that an unknown error occurred while attempting to save<br>
		 * the file.<br>
		 * * This error typically indicates that file I/O failed when attempting to <br>
		 * write the file.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1183</i>
		 */
		public static final int CXSaveError_Unknown = (int)1;
		/**
		 * \brief Indicates that errors during translation prevented this attempt<br>
		 * to save the translation unit.<br>
		 * <br>
		 * Errors that prevent the translation unit from being saved can be<br>
		 * extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().<br>
		 * \brief Indicates that errors during translation prevented this attempt<br>
		 * to save the translation unit.<br>
		 * <br>
		 * Errors that prevent the translation unit from being saved can be<br>
		 * extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1192</i>
		 */
		public static final int CXSaveError_TranslationErrors = (int)2;
		/**
		 * \brief Indicates that the translation unit to be saved was somehow<br>
		 * invalid (e.g., NULL).<br>
		 * \brief Indicates that the translation unit to be saved was somehow<br>
		 * invalid (e.g., NULL).<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1198</i>
		 */
		public static final int CXSaveError_InvalidTU = (int)3;
	};
	/**
	 * \brief Flags that control the reparsing of translation units.<br>
	 * * The enumerators in this enumeration type are meant to be bitwise<br>
	 * ORed together to specify which options should be used when<br>
	 * reparsing the translation unit.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1240</i><br>
	 * enum values
	 */
	/**
	 * \brief Flags that control the reparsing of translation units.<br>
	 * * The enumerators in this enumeration type are meant to be bitwise<br>
	 * ORed together to specify which options should be used when<br>
	 * reparsing the translation unit.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1240</i><br>
	 * enum values
	 */
	public static interface CXReparse_Flags {
		/**
		 * \brief Used to indicate that no special reparsing options are needed.<br>
		 * \brief Used to indicate that no special reparsing options are needed.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:1244</i>
		 */
		public static final int CXReparse_None = (int)0;
	};
	/**
	 * \brief Categorizes how memory is being used by a translation unit.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1305</i><br>
	 * enum values
	 */
	/**
	 * \brief Categorizes how memory is being used by a translation unit.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1305</i><br>
	 * enum values
	 */
	public static interface CXTUResourceUsageKind {
		/// <i>native declaration : src/main/c/clang-c/Index.h:1306</i>
		public static final int CXTUResourceUsage_AST = (int)1;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1307</i>
		public static final int CXTUResourceUsage_Identifiers = (int)2;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1308</i>
		public static final int CXTUResourceUsage_Selectors = (int)3;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1309</i>
		public static final int CXTUResourceUsage_GlobalCompletionResults = (int)4;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1310</i>
		public static final int CXTUResourceUsage_SourceManagerContentCache = (int)5;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1311</i>
		public static final int CXTUResourceUsage_AST_SideTables = (int)6;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1312</i>
		public static final int CXTUResourceUsage_SourceManager_Membuffer_Malloc = (int)7;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1313</i>
		public static final int CXTUResourceUsage_SourceManager_Membuffer_MMap = (int)8;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1314</i>
		public static final int CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = (int)9;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1315</i>
		public static final int CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = (int)10;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1316</i>
		public static final int CXTUResourceUsage_Preprocessor = (int)11;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1317</i>
		public static final int CXTUResourceUsage_PreprocessingRecord = (int)12;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1318</i>
		public static final int CXTUResourceUsage_SourceManager_DataStructures = (int)13;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1319</i>
		public static final int CXTUResourceUsage_Preprocessor_HeaderSearch = (int)14;
		/// <i>native declaration : src/main/c/clang-c/Index.h:1320</i>
		public static final int CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = (int)((int)ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_AST);
		/// <i>native declaration : src/main/c/clang-c/Index.h:1321</i>
		public static final int CXTUResourceUsage_MEMORY_IN_BYTES_END = (int)((int)ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_Preprocessor_HeaderSearch);
		/// <i>native declaration : src/main/c/clang-c/Index.h:1324</i>
		public static final int CXTUResourceUsage_First = (int)((int)ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_AST);
		/// <i>native declaration : src/main/c/clang-c/Index.h:1325</i>
		public static final int CXTUResourceUsage_Last = (int)((int)ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_Preprocessor_HeaderSearch);
	};
	/**
	 * \brief Describes the kind of entity that a cursor refers to.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1374</i><br>
	 * enum values
	 */
    ;
	/**
	 * \brief Describe the linkage of the entity referred to by a cursor.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2158</i><br>
	 * enum values
	 */
	/**
	 * \brief Describe the linkage of the entity referred to by a cursor.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2158</i><br>
	 * enum values
	 */
	public static interface CXLinkageKind {
		/**
		 * \brief This value indicates that no linkage information is available<br>
		 * for a provided CXCursor.<br>
		 * \brief This value indicates that no linkage information is available<br>
		 * for a provided CXCursor.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2161</i>
		 */
		public static final int CXLinkage_Invalid = (int)0;
		/**
		 * \brief This is the linkage for variables, parameters, and so on that<br>
		 *  have automatic storage.  This covers normal (non-extern) local variables.<br>
		 * \brief This is the linkage for variables, parameters, and so on that<br>
		 *  have automatic storage.  This covers normal (non-extern) local variables.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2166</i>
		 */
		public static final int CXLinkage_NoLinkage = (int)1;
		/**
		 * \brief This is the linkage for static variables and static functions.<br>
		 * \brief This is the linkage for static variables and static functions.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2168</i>
		 */
		public static final int CXLinkage_Internal = (int)2;
		/**
		 * \brief This is the linkage for entities with external linkage that live<br>
		 * in C++ anonymous namespaces.<br>
		 * \brief This is the linkage for entities with external linkage that live<br>
		 * in C++ anonymous namespaces.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2171</i>
		 */
		public static final int CXLinkage_UniqueExternal = (int)3;
		/**
		 * \brief This is the linkage for entities with true, external linkage.<br>
		 * \brief This is the linkage for entities with true, external linkage.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2173</i>
		 */
		public static final int CXLinkage_External = (int)4;
	};
	/**
	 * \brief Describe the "language" of the entity referred to by a cursor.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2283</i><br>
	 * enum values
	 */
	/**
	 * \brief Describe the "language" of the entity referred to by a cursor.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2283</i><br>
	 * enum values
	 */
	public static interface CXLanguageKind {
		/// <i>native declaration : src/main/c/clang-c/Index.h:2284</i>
		public static final int CXLanguage_Invalid = (int)0;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2285</i>
		public static final int CXLanguage_C = (int)1;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2286</i>
		public static final int CXLanguage_ObjC = (int)2;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2287</i>
		public static final int CXLanguage_CPlusPlus = (int)3;
	};
	/**
	 * \brief Describes the kind of type<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2532</i><br>
	 * enum values
	 */
	/**
	 * \brief Describes the kind of type<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2532</i><br>
	 * enum values
	 */
	public static interface CXTypeKind {
		/**
		 * \brief Reprents an invalid type (e.g., where no type is available).<br>
		 * \brief Reprents an invalid type (e.g., where no type is available).<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2536</i>
		 */
		public static final int CXType_Invalid = (int)0;
		/**
		 * \brief A type whose specific kind is not exposed via this<br>
		 * interface.<br>
		 * \brief A type whose specific kind is not exposed via this<br>
		 * interface.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2542</i>
		 */
		public static final int CXType_Unexposed = (int)1;
		/**
		 * Builtin types<br>
		 * Builtin types<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2545</i>
		 */
		public static final int CXType_Void = (int)2;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2546</i>
		public static final int CXType_Bool = (int)3;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2547</i>
		public static final int CXType_Char_U = (int)4;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2548</i>
		public static final int CXType_UChar = (int)5;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2549</i>
		public static final int CXType_Char16 = (int)6;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2550</i>
		public static final int CXType_Char32 = (int)7;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2551</i>
		public static final int CXType_UShort = (int)8;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2552</i>
		public static final int CXType_UInt = (int)9;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2553</i>
		public static final int CXType_ULong = (int)10;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2554</i>
		public static final int CXType_ULongLong = (int)11;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2555</i>
		public static final int CXType_UInt128 = (int)12;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2556</i>
		public static final int CXType_Char_S = (int)13;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2557</i>
		public static final int CXType_SChar = (int)14;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2558</i>
		public static final int CXType_WChar = (int)15;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2559</i>
		public static final int CXType_Short = (int)16;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2560</i>
		public static final int CXType_Int = (int)17;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2561</i>
		public static final int CXType_Long = (int)18;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2562</i>
		public static final int CXType_LongLong = (int)19;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2563</i>
		public static final int CXType_Int128 = (int)20;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2564</i>
		public static final int CXType_Float = (int)21;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2565</i>
		public static final int CXType_Double = (int)22;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2566</i>
		public static final int CXType_LongDouble = (int)23;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2567</i>
		public static final int CXType_NullPtr = (int)24;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2568</i>
		public static final int CXType_Overload = (int)25;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2569</i>
		public static final int CXType_Dependent = (int)26;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2570</i>
		public static final int CXType_ObjCId = (int)27;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2571</i>
		public static final int CXType_ObjCClass = (int)28;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2572</i>
		public static final int CXType_ObjCSel = (int)29;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2573</i>
		public static final int CXType_FirstBuiltin = (int)((int)ClangLibrary.CXTypeKind.CXType_Void);
		/// <i>native declaration : src/main/c/clang-c/Index.h:2574</i>
		public static final int CXType_LastBuiltin = (int)((int)ClangLibrary.CXTypeKind.CXType_ObjCSel);
		/// <i>native declaration : src/main/c/clang-c/Index.h:2576</i>
		public static final int CXType_Complex = (int)100;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2577</i>
		public static final int CXType_Pointer = (int)101;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2578</i>
		public static final int CXType_BlockPointer = (int)102;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2579</i>
		public static final int CXType_LValueReference = (int)103;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2580</i>
		public static final int CXType_RValueReference = (int)104;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2581</i>
		public static final int CXType_Record = (int)105;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2582</i>
		public static final int CXType_Enum = (int)106;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2583</i>
		public static final int CXType_Typedef = (int)107;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2584</i>
		public static final int CXType_ObjCInterface = (int)108;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2585</i>
		public static final int CXType_ObjCObjectPointer = (int)109;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2586</i>
		public static final int CXType_FunctionNoProto = (int)110;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2587</i>
		public static final int CXType_FunctionProto = (int)111;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2588</i>
		public static final int CXType_ConstantArray = (int)112;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2589</i>
		public static final int CXType_Vector = (int)113;
	};
	/**
	 * \brief Describes the calling convention of a function type<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2595</i><br>
	 * enum values
	 */
	/**
	 * \brief Describes the calling convention of a function type<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2595</i><br>
	 * enum values
	 */
	public static interface CXCallingConv {
		/// <i>native declaration : src/main/c/clang-c/Index.h:2596</i>
		public static final int CXCallingConv_Default = (int)0;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2597</i>
		public static final int CXCallingConv_C = (int)1;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2598</i>
		public static final int CXCallingConv_X86StdCall = (int)2;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2599</i>
		public static final int CXCallingConv_X86FastCall = (int)3;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2600</i>
		public static final int CXCallingConv_X86ThisCall = (int)4;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2601</i>
		public static final int CXCallingConv_X86Pascal = (int)5;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2602</i>
		public static final int CXCallingConv_AAPCS = (int)6;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2603</i>
		public static final int CXCallingConv_AAPCS_VFP = (int)7;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2604</i>
		public static final int CXCallingConv_PnaclCall = (int)8;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2606</i>
		public static final int CXCallingConv_Invalid = (int)100;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2607</i>
		public static final int CXCallingConv_Unexposed = (int)200;
	};
	/**
	 * \brief Represents the C++ access control level to a base class for a<br>
	 * cursor with kind CX_CXXBaseSpecifier.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2831</i><br>
	 * enum values
	 */
	/**
	 * \brief Represents the C++ access control level to a base class for a<br>
	 * cursor with kind CX_CXXBaseSpecifier.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2831</i><br>
	 * enum values
	 */
	public static interface CX_CXXAccessSpecifier {
		/// <i>native declaration : src/main/c/clang-c/Index.h:2832</i>
		public static final int CX_CXXInvalidAccessSpecifier = (int)0;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2833</i>
		public static final int CX_CXXPublic = (int)1;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2834</i>
		public static final int CX_CXXProtected = (int)2;
		/// <i>native declaration : src/main/c/clang-c/Index.h:2835</i>
		public static final int CX_CXXPrivate = (int)3;
	};
	/**
	 * \brief Describes how the traversal of the children of a particular<br>
	 * cursor should proceed after visiting a particular child cursor.<br>
	 * * A value of this enumeration type should be returned by each<br>
	 * \c CXCursorVisitor to indicate how clang_visitChildren() proceed.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2911</i><br>
	 * enum values
	 */
	/**
	 * \brief Describes how the traversal of the children of a particular<br>
	 * cursor should proceed after visiting a particular child cursor.<br>
	 * * A value of this enumeration type should be returned by each<br>
	 * \c CXCursorVisitor to indicate how clang_visitChildren() proceed.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2911</i><br>
	 * enum values
	 */
	public static interface CXChildVisitResult {
		/**
		 * \brief Terminates the cursor traversal.<br>
		 * \brief Terminates the cursor traversal.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2915</i>
		 */
		public static final int CXChildVisit_Break = (int)0;
		/**
		 * \brief Continues the cursor traversal with the next sibling of<br>
		 * the cursor just visited, without visiting its children.<br>
		 * \brief Continues the cursor traversal with the next sibling of<br>
		 * the cursor just visited, without visiting its children.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2920</i>
		 */
		public static final int CXChildVisit_Continue = (int)1;
		/**
		 * \brief Recursively traverse the children of this cursor, using<br>
		 * the same visitor and client data.<br>
		 * \brief Recursively traverse the children of this cursor, using<br>
		 * the same visitor and client data.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:2925</i>
		 */
		public static final int CXChildVisit_Recurse = (int)2;
	};
	/**
	 * \brief Describes the type of the comment AST node (\c CXComment).  A comment<br>
	 * node can be considered block content (e. g., paragraph), inline content<br>
	 * (plain text) or neither (the root AST node).<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3300</i><br>
	 * enum values
	 */
	/**
	 * \brief Describes the type of the comment AST node (\c CXComment).  A comment<br>
	 * node can be considered block content (e. g., paragraph), inline content<br>
	 * (plain text) or neither (the root AST node).<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3300</i><br>
	 * enum values
	 */
	public static interface CXCommentKind {
		/**
		 * \brief Null comment.  No AST node is constructed at the requested location<br>
		 * because there is no text or a syntax error.<br>
		 * \brief Null comment.  No AST node is constructed at the requested location<br>
		 * because there is no text or a syntax error.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3305</i>
		 */
		public static final int CXComment_Null = (int)0;
		/**
		 * \brief Plain text.  Inline content.<br>
		 * \brief Plain text.  Inline content.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3310</i>
		 */
		public static final int CXComment_Text = (int)1;
		/**
		 * \brief A command with word-like arguments that is considered inline content.<br>
		 * * For example: \\c command.<br>
		 * \brief A command with word-like arguments that is considered inline content.<br>
		 * * For example: \\c command.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3317</i>
		 */
		public static final int CXComment_InlineCommand = (int)2;
		/**
		 * \brief HTML start tag with attributes (name-value pairs).  Considered<br>
		 * inline content.<br>
		 * * For example:<br>
		 * \verbatim<br>
		 * <br> <br /> <a href="http://example.org/"><br>
		 * \endverbatim<br>
		 * \brief HTML start tag with attributes (name-value pairs).  Considered<br>
		 * inline content.<br>
		 * * For example:<br>
		 * \verbatim<br>
		 * <br> <br /> <a href="http://example.org/"><br>
		 * \endverbatim<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3328</i>
		 */
		public static final int CXComment_HTMLStartTag = (int)3;
		/**
		 * \brief HTML end tag.  Considered inline content.<br>
		 * * For example:<br>
		 * \verbatim<br>
		 * </a><br>
		 * \endverbatim<br>
		 * \brief HTML end tag.  Considered inline content.<br>
		 * * For example:<br>
		 * \verbatim<br>
		 * </a><br>
		 * \endverbatim<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3338</i>
		 */
		public static final int CXComment_HTMLEndTag = (int)4;
		/**
		 * \brief A paragraph, contains inline comment.  The paragraph itself is<br>
		 * block content.<br>
		 * \brief A paragraph, contains inline comment.  The paragraph itself is<br>
		 * block content.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3344</i>
		 */
		public static final int CXComment_Paragraph = (int)5;
		/**
		 * \brief A command that has zero or more word-like arguments (number of<br>
		 * word-like arguments depends on command name) and a paragraph as an<br>
		 * argument.  Block command is block content.<br>
		 * * Paragraph argument is also a child of the block command.<br>
		 * * For example: \\brief has 0 word-like arguments and a paragraph argument.<br>
		 * * AST nodes of special kinds that parser knows about (e. g., \\param<br>
		 * command) have their own node kinds.<br>
		 * \brief A command that has zero or more word-like arguments (number of<br>
		 * word-like arguments depends on command name) and a paragraph as an<br>
		 * argument.  Block command is block content.<br>
		 * * Paragraph argument is also a child of the block command.<br>
		 * * For example: \\brief has 0 word-like arguments and a paragraph argument.<br>
		 * * AST nodes of special kinds that parser knows about (e. g., \\param<br>
		 * command) have their own node kinds.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3358</i>
		 */
		public static final int CXComment_BlockCommand = (int)6;
		/**
		 * \brief A \\param or \\arg command that describes the function parameter<br>
		 * (name, passing direction, description).<br>
		 * * For example: \\param [in] ParamName description.<br>
		 * \brief A \\param or \\arg command that describes the function parameter<br>
		 * (name, passing direction, description).<br>
		 * * For example: \\param [in] ParamName description.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3366</i>
		 */
		public static final int CXComment_ParamCommand = (int)7;
		/**
		 * \brief A \\tparam command that describes a template parameter (name and<br>
		 * description).<br>
		 * * For example: \\tparam T description.<br>
		 * \brief A \\tparam command that describes a template parameter (name and<br>
		 * description).<br>
		 * * For example: \\tparam T description.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3374</i>
		 */
		public static final int CXComment_TParamCommand = (int)8;
		/**
		 * \brief A verbatim block command (e. g., preformatted code).  Verbatim<br>
		 * block has an opening and a closing command and contains multiple lines of<br>
		 * text (\c CXComment_VerbatimBlockLine child nodes).<br>
		 * * For example:<br>
		 * \\verbatim<br>
		 * aaa<br>
		 * \\endverbatim<br>
		 * \brief A verbatim block command (e. g., preformatted code).  Verbatim<br>
		 * block has an opening and a closing command and contains multiple lines of<br>
		 * text (\c CXComment_VerbatimBlockLine child nodes).<br>
		 * * For example:<br>
		 * \\verbatim<br>
		 * aaa<br>
		 * \\endverbatim<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3386</i>
		 */
		public static final int CXComment_VerbatimBlockCommand = (int)9;
		/**
		 * \brief A line of text that is contained within a<br>
		 * CXComment_VerbatimBlockCommand node.<br>
		 * \brief A line of text that is contained within a<br>
		 * CXComment_VerbatimBlockCommand node.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3392</i>
		 */
		public static final int CXComment_VerbatimBlockLine = (int)10;
		/**
		 * \brief A verbatim line command.  Verbatim line has an opening command,<br>
		 * a single line of text (up to the newline after the opening command) and<br>
		 * has no closing command.<br>
		 * \brief A verbatim line command.  Verbatim line has an opening command,<br>
		 * a single line of text (up to the newline after the opening command) and<br>
		 * has no closing command.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3399</i>
		 */
		public static final int CXComment_VerbatimLine = (int)11;
		/**
		 * \brief A full comment attached to a declaration, contains block content.<br>
		 * \brief A full comment attached to a declaration, contains block content.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3404</i>
		 */
		public static final int CXComment_FullComment = (int)12;
	};
	/**
	 * \brief The most appropriate rendering mode for an inline command, chosen on<br>
	 * command semantics in Doxygen.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3411</i><br>
	 * enum values
	 */
	/**
	 * \brief The most appropriate rendering mode for an inline command, chosen on<br>
	 * command semantics in Doxygen.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3411</i><br>
	 * enum values
	 */
	public static interface CXCommentInlineCommandRenderKind {
		/**
		 * \brief Command argument should be rendered in a normal font.<br>
		 * \brief Command argument should be rendered in a normal font.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3415</i>
		 */
		public static final int CXCommentInlineCommandRenderKind_Normal = (int)0;
		/**
		 * \brief Command argument should be rendered in a bold font.<br>
		 * \brief Command argument should be rendered in a bold font.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3420</i>
		 */
		public static final int CXCommentInlineCommandRenderKind_Bold = (int)1;
		/**
		 * \brief Command argument should be rendered in a monospaced font.<br>
		 * \brief Command argument should be rendered in a monospaced font.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3425</i>
		 */
		public static final int CXCommentInlineCommandRenderKind_Monospaced = (int)2;
		/**
		 * \brief Command argument should be rendered emphasized (typically italic<br>
		 * font).<br>
		 * \brief Command argument should be rendered emphasized (typically italic<br>
		 * font).<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3431</i>
		 */
		public static final int CXCommentInlineCommandRenderKind_Emphasized = (int)3;
	};
	/**
	 * \brief Describes parameter passing direction for \\param or \\arg command.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3437</i><br>
	 * enum values
	 */
	/**
	 * \brief Describes parameter passing direction for \\param or \\arg command.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3437</i><br>
	 * enum values
	 */
	public static interface CXCommentParamPassDirection {
		/**
		 * \brief The parameter is an input parameter.<br>
		 * \brief The parameter is an input parameter.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3441</i>
		 */
		public static final int CXCommentParamPassDirection_In = (int)0;
		/**
		 * \brief The parameter is an output parameter.<br>
		 * \brief The parameter is an output parameter.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3446</i>
		 */
		public static final int CXCommentParamPassDirection_Out = (int)1;
		/**
		 * \brief The parameter is an input and output parameter.<br>
		 * \brief The parameter is an input and output parameter.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3451</i>
		 */
		public static final int CXCommentParamPassDirection_InOut = (int)2;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h:3887</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h:3887</i><br>
	 * enum values
	 */
	public static interface CXNameRefFlags {
		/**
		 * \brief Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the<br>
		 * range.<br>
		 * \brief Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the<br>
		 * range.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3892</i>
		 */
		public static final int CXNameRange_WantQualifier = (int)1;
		/**
		 * \brief Include the explicit template arguments, e.g. \<int> in x.f<int>,<br>
		 * in the range.<br>
		 * \brief Include the explicit template arguments, e.g. \<int> in x.f<int>,<br>
		 * in the range.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3898</i>
		 */
		public static final int CXNameRange_WantTemplateArgs = (int)2;
		/**
		 * \brief If the name is non-contiguous, return the full spanning range.<br>
		 * * Non-contiguous names occur in Objective-C when a selector with two or more<br>
		 * parameters is used, or in C++ when using an operator:<br>
		 * \code<br>
		 * [object doSomething:here withValue:there]; // ObjC<br>
		 * return some_vector[1]; // C++<br>
		 * \endcode<br>
		 * \brief If the name is non-contiguous, return the full spanning range.<br>
		 * * Non-contiguous names occur in Objective-C when a selector with two or more<br>
		 * parameters is used, or in C++ when using an operator:<br>
		 * \code<br>
		 * [object doSomething:here withValue:there]; // ObjC<br>
		 * return some_vector[1]; // C++<br>
		 * \endcode<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3910</i>
		 */
		public static final int CXNameRange_WantSinglePiece = (int)4;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXTokenKind {
		/**
		 * \brief A token that contains some kind of punctuation.<br>
		 * \brief A token that contains some kind of punctuation.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3934</i>
		 */
		public static final int CXToken_Punctuation = (int)0;
		/**
		 * \brief A language keyword.<br>
		 * \brief A language keyword.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3939</i>
		 */
		public static final int CXToken_Keyword = (int)1;
		/**
		 * \brief An identifier (that is not a keyword).<br>
		 * \brief An identifier (that is not a keyword).<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3944</i>
		 */
		public static final int CXToken_Identifier = (int)2;
		/**
		 * \brief A numeric, string, or character literal.<br>
		 * \brief A numeric, string, or character literal.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3949</i>
		 */
		public static final int CXToken_Literal = (int)3;
		/**
		 * \brief A comment.<br>
		 * \brief A comment.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:3954</i>
		 */
		public static final int CXToken_Comment = (int)4;
	};
	/**
	 * \brief Describes a single piece of text within a code-completion string.<br>
	 * * Each "chunk" within a code-completion string (\c CXCompletionString) is<br>
	 * either a piece of text with a specific "kind" that describes how that text<br>
	 * should be interpreted by the client or is another completion string.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4136</i><br>
	 * enum values
	 */
	/**
	 * \brief Describes a single piece of text within a code-completion string.<br>
	 * * Each "chunk" within a code-completion string (\c CXCompletionString) is<br>
	 * either a piece of text with a specific "kind" that describes how that text<br>
	 * should be interpreted by the client or is another completion string.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4136</i><br>
	 * enum values
	 */
	public static interface CXCompletionChunkKind {
		/**
		 * \brief A code-completion string that describes "optional" text that<br>
		 * could be a part of the template (but is not required).<br>
		 * * The Optional chunk is the only kind of chunk that has a code-completion<br>
		 * string for its representation, which is accessible via<br>
		 * \c clang_getCompletionChunkCompletionString(). The code-completion string<br>
		 * describes an additional part of the template that is completely optional.<br>
		 * For example, optional chunks can be used to describe the placeholders for<br>
		 * arguments that match up with defaulted function parameters, e.g. given:<br>
		 * * \code<br>
		 * void f(int x, float y = 3.14, double z = 2.71828);<br>
		 * \endcode<br>
		 * * The code-completion string for this function would contain:<br>
		 *   - a TypedText chunk for "f".<br>
		 *   - a LeftParen chunk for "(".<br>
		 *   - a Placeholder chunk for "int x"<br>
		 *   - an Optional chunk containing the remaining defaulted arguments, e.g.,<br>
		 *       - a Comma chunk for ","<br>
		 *       - a Placeholder chunk for "float y"<br>
		 *       - an Optional chunk containing the last defaulted argument:<br>
		 *           - a Comma chunk for ","<br>
		 *           - a Placeholder chunk for "double z"<br>
		 *   - a RightParen chunk for ")"<br>
		 * * There are many ways to handle Optional chunks. Two simple approaches are:<br>
		 *   - Completely ignore optional chunks, in which case the template for the<br>
		 *     function "f" would only include the first parameter ("int x").<br>
		 *   - Fully expand all optional chunks, in which case the template for the<br>
		 *     function "f" would have all of the parameters.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4170</i>
		 */
		public static final int CXCompletionChunk_Optional = (int)0;
		/**
		 * \brief Text that a user would be expected to type to get this<br>
		 * code-completion result.<br>
		 * * There will be exactly one "typed text" chunk in a semantic string, which<br>
		 * will typically provide the spelling of a keyword or the name of a<br>
		 * declaration that could be used at the current code point. Clients are<br>
		 * expected to filter the code-completion results based on the text in this<br>
		 * chunk.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4181</i>
		 */
		public static final int CXCompletionChunk_TypedText = (int)1;
		/**
		 * \brief Text that should be inserted as part of a code-completion result.<br>
		 * * A "text" chunk represents text that is part of the template to be<br>
		 * inserted into user code should this particular code-completion result<br>
		 * be selected.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4189</i>
		 */
		public static final int CXCompletionChunk_Text = (int)2;
		/**
		 * \brief Placeholder text that should be replaced by the user.<br>
		 * * A "placeholder" chunk marks a place where the user should insert text<br>
		 * into the code-completion template. For example, placeholders might mark<br>
		 * the function parameters for a function declaration, to indicate that the<br>
		 * user should provide arguments for each of those parameters. The actual<br>
		 * text in a placeholder is a suggestion for the text to display before<br>
		 * the user replaces the placeholder with real code.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4200</i>
		 */
		public static final int CXCompletionChunk_Placeholder = (int)3;
		/**
		 * \brief Informative text that should be displayed but never inserted as<br>
		 * part of the template.<br>
		 * * An "informative" chunk contains annotations that can be displayed to<br>
		 * help the user decide whether a particular code-completion result is the<br>
		 * right option, but which is not part of the actual template to be inserted<br>
		 * by code completion.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4210</i>
		 */
		public static final int CXCompletionChunk_Informative = (int)4;
		/**
		 * \brief Text that describes the current parameter when code-completion is<br>
		 * referring to function call, message send, or template specialization.<br>
		 * * A "current parameter" chunk occurs when code-completion is providing<br>
		 * information about a parameter corresponding to the argument at the<br>
		 * code-completion point. For example, given a function<br>
		 * * \code<br>
		 * int add(int x, int y);<br>
		 * \endcode<br>
		 * * and the source code \c add(, where the code-completion point is after the<br>
		 * "(", the code-completion string will contain a "current parameter" chunk<br>
		 * for "int x", indicating that the current argument will initialize that<br>
		 * parameter. After typing further, to \c add(17, (where the code-completion<br>
		 * point is after the ","), the code-completion string will contain a<br>
		 * "current paremeter" chunk to "int y".<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4230</i>
		 */
		public static final int CXCompletionChunk_CurrentParameter = (int)5;
		/**
		 * \brief A left parenthesis ('('), used to initiate a function call or<br>
		 * signal the beginning of a function parameter list.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4235</i>
		 */
		public static final int CXCompletionChunk_LeftParen = (int)6;
		/**
		 * \brief A right parenthesis (')'), used to finish a function call or<br>
		 * signal the end of a function parameter list.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4240</i>
		 */
		public static final int CXCompletionChunk_RightParen = (int)7;
		/**
		 * \brief A left bracket ('[').<br>

		 * <i>native declaration : src/main/c/clang-c/Index.h:4244</i>
		 */
		public static final int CXCompletionChunk_LeftBracket = (int)8;
		/**
		 * \brief A right bracket (']').<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4248</i>
		 */
		public static final int CXCompletionChunk_RightBracket = (int)9;
		/**
		 * \brief A left brace ('{').<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4252</i>
		 */
		public static final int CXCompletionChunk_LeftBrace = (int)10;
		/**
		 * \brief A right brace ('}').<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4256</i>
		 */
		public static final int CXCompletionChunk_RightBrace = (int)11;
		/**
		 * \brief A left angle bracket ('<').<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4260</i>
		 */
		public static final int CXCompletionChunk_LeftAngle = (int)12;
		/**
		 * \brief A right angle bracket ('>').<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4264</i>
		 */
		public static final int CXCompletionChunk_RightAngle = (int)13;
		/**
		 * \brief A comma separator (',').<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4268</i>
		 */
		public static final int CXCompletionChunk_Comma = (int)14;
		/**

		 * \brief Text that specifies the result type of a given result.<br>
		 * * This special kind of informative chunk is not meant to be inserted into<br>
		 * the text buffer. Rather, it is meant to illustrate the type that an<br>
		 * expression using the given completion string would have.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4276</i>
		 */
		public static final int CXCompletionChunk_ResultType = (int)15;
		/**
		 * \brief A colon (':').<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4280</i>
		 */
		public static final int CXCompletionChunk_Colon = (int)16;
		/**
		 * \brief A semicolon (';').<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4284</i>
		 */
		public static final int CXCompletionChunk_SemiColon = (int)17;
		/**
		 * \brief An '=' sign.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4288</i>
		 */
		public static final int CXCompletionChunk_Equal = (int)18;
		/**
		 * Horizontal space (' ').<br>
		 * Horizontal space (' ').<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4292</i>
		 */
		public static final int CXCompletionChunk_HorizontalSpace = (int)19;
		/**
		 * Vertical space ('\n'), after which it is generally a good idea to<br>
		 * perform indentation.<br>
		 * Vertical space ('\n'), after which it is generally a good idea to<br>
		 * perform indentation.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4297</i>
		 */
		public static final int CXCompletionChunk_VerticalSpace = (int)20;
	};
	/**
	 * \brief Flags that can be passed to \c clang_codeCompleteAt() to<br>
	 * modify its behavior.<br>
	 * * The enumerators in this enumeration can be bitwise-OR'd together to<br>
	 * provide multiple options to \c clang_codeCompleteAt().<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4467</i><br>
	 * enum values
	 */
	public static interface CXCodeComplete_Flags {
		/**
		 * \brief Whether to include macros within the set of code<br>
		 * completions returned.<br>

		 * <i>native declaration : src/main/c/clang-c/Index.h:4472</i>
		 */
		public static final int CXCodeComplete_IncludeMacros = (int)1;
		/**

		 * \brief Whether to include code patterns for language constructs<br>
		 * within the set of code completions, e.g., for loops.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4478</i>
		 */
		public static final int CXCodeComplete_IncludeCodePatterns = (int)2;
		/**

		 * \brief Whether to include brief documentation within the set of code<br>
		 * completions returned.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4484</i>
		 */
		public static final int CXCodeComplete_IncludeBriefComments = (int)4;
	};
	/**
	 * \brief Bits that represent the context under which completion is occurring.<br>
	 * * The enumerators in this enumeration may be bitwise-OR'd together if multiple<br>
	 * contexts are occurring simultaneously.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4493</i><br>
	 * enum values
	 */
	public static interface CXCompletionContext {
		/**
		 * \brief The context for completions is unexposed, as only Clang results<br>
		 * should be included. (This is equivalent to having no context bits set.)<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4498</i>
		 */
		public static final int CXCompletionContext_Unexposed = (int)0;
		/**
		 * \brief Completions for any possible type should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4503</i>
		 */
		public static final int CXCompletionContext_AnyType = (int)(1 << 0);
		/**
		 * \brief Completions for any possible value (variables, function calls, etc.)<br>
		 * should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4509</i>
		 */
		public static final int CXCompletionContext_AnyValue = (int)(1 << 1);
		/**
		 * \brief Completions for values that resolve to an Objective-C object should<br>
		 * be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4514</i>
		 */
		public static final int CXCompletionContext_ObjCObjectValue = (int)(1 << 2);
		/**
		 * \brief Completions for values that resolve to an Objective-C selector<br>
		 * should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4519</i>
		 */
		public static final int CXCompletionContext_ObjCSelectorValue = (int)(1 << 3);
		/**
		 * \brief Completions for values that resolve to a C++ class type should be<br>
		 * included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4524</i>
		 */
		public static final int CXCompletionContext_CXXClassTypeValue = (int)(1 << 4);
		/**
		 * \brief Completions for fields of the member being accessed using the dot<br>
		 * operator should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4530</i>
		 */
		public static final int CXCompletionContext_DotMemberAccess = (int)(1 << 5);
		/**
		 * \brief Completions for fields of the member being accessed using the arrow<br>
		 * operator should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4535</i>
		 */
		public static final int CXCompletionContext_ArrowMemberAccess = (int)(1 << 6);
		/**
		 * \brief Completions for properties of the Objective-C object being accessed<br>
		 * using the dot operator should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4540</i>
		 */
		public static final int CXCompletionContext_ObjCPropertyAccess = (int)(1 << 7);
		/**
		 * \brief Completions for enum tags should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4545</i>
		 */
		public static final int CXCompletionContext_EnumTag = (int)(1 << 8);
		/**
		 * \brief Completions for union tags should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4549</i>
		 */
		public static final int CXCompletionContext_UnionTag = (int)(1 << 9);
		/**
		 * \brief Completions for struct tags should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4553</i>
		 */
		public static final int CXCompletionContext_StructTag = (int)(1 << 10);
		/**
		 * \brief Completions for C++ class names should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4558</i>
		 */
		public static final int CXCompletionContext_ClassTag = (int)(1 << 11);
		/**
		 * \brief Completions for C++ namespaces and namespace aliases should be<br>
		 * included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4563</i>
		 */
		public static final int CXCompletionContext_Namespace = (int)(1 << 12);
		/**
		 * \brief Completions for C++ nested name specifiers should be included in<br>
		 * the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4568</i>
		 */
		public static final int CXCompletionContext_NestedNameSpecifier = (int)(1 << 13);
		/**
		 * \brief Completions for Objective-C interfaces (classes) should be included<br>
		 * in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4574</i>
		 */
		public static final int CXCompletionContext_ObjCInterface = (int)(1 << 14);
		/**
		 * \brief Completions for Objective-C protocols should be included in<br>
		 * the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4579</i>
		 */
		public static final int CXCompletionContext_ObjCProtocol = (int)(1 << 15);
		/**
		 * \brief Completions for Objective-C categories should be included in<br>
		 * the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4584</i>
		 */
		public static final int CXCompletionContext_ObjCCategory = (int)(1 << 16);
		/**
		 * \brief Completions for Objective-C instance messages should be included<br>
		 * in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4589</i>
		 */
		public static final int CXCompletionContext_ObjCInstanceMessage = (int)(1 << 17);
		/**
		 * \brief Completions for Objective-C class messages should be included in<br>
		 * the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4594</i>
		 */
		public static final int CXCompletionContext_ObjCClassMessage = (int)(1 << 18);
		/**
		 * \brief Completions for Objective-C selector names should be included in<br>
		 * the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4599</i>
		 */
		public static final int CXCompletionContext_ObjCSelectorName = (int)(1 << 19);
		/**
		 * \brief Completions for preprocessor macro names should be included in<br>
		 * the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4605</i>
		 */
		public static final int CXCompletionContext_MacroName = (int)(1 << 20);
		/**
		 * \brief Natural language completions should be included in the results.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4610</i>
		 */
		public static final int CXCompletionContext_NaturalLanguage = (int)(1 << 21);
		/**
		 * \brief The current context is unknown, so set all contexts.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:4615</i>
		 */
		public static final int CXCompletionContext_Unknown = (int)((1 << 22) - 1);
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h:4919</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h:4919</i><br>
	 * enum values
	 */
	public static interface CXVisitorResult {
		/// <i>native declaration : src/main/c/clang-c/Index.h:4920</i>
		public static final int CXVisit_Break = (int)0;
		/// <i>native declaration : src/main/c/clang-c/Index.h:4921</i>
		public static final int CXVisit_Continue = (int)1;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxEntityKind {
		/// <i>native declaration : src/main/c/clang-c/Index.h:5037</i>
		public static final int CXIdxEntity_Unexposed = (int)0;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5038</i>
		public static final int CXIdxEntity_Typedef = (int)1;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5039</i>
		public static final int CXIdxEntity_Function = (int)2;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5040</i>
		public static final int CXIdxEntity_Variable = (int)3;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5041</i>
		public static final int CXIdxEntity_Field = (int)4;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5042</i>
		public static final int CXIdxEntity_EnumConstant = (int)5;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5044</i>
		public static final int CXIdxEntity_ObjCClass = (int)6;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5045</i>
		public static final int CXIdxEntity_ObjCProtocol = (int)7;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5046</i>
		public static final int CXIdxEntity_ObjCCategory = (int)8;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5048</i>
		public static final int CXIdxEntity_ObjCInstanceMethod = (int)9;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5049</i>
		public static final int CXIdxEntity_ObjCClassMethod = (int)10;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5050</i>
		public static final int CXIdxEntity_ObjCProperty = (int)11;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5051</i>
		public static final int CXIdxEntity_ObjCIvar = (int)12;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5053</i>
		public static final int CXIdxEntity_Enum = (int)13;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5054</i>
		public static final int CXIdxEntity_Struct = (int)14;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5055</i>
		public static final int CXIdxEntity_Union = (int)15;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5057</i>
		public static final int CXIdxEntity_CXXClass = (int)16;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5058</i>
		public static final int CXIdxEntity_CXXNamespace = (int)17;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5059</i>
		public static final int CXIdxEntity_CXXNamespaceAlias = (int)18;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5060</i>
		public static final int CXIdxEntity_CXXStaticVariable = (int)19;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5061</i>
		public static final int CXIdxEntity_CXXStaticMethod = (int)20;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5062</i>
		public static final int CXIdxEntity_CXXInstanceMethod = (int)21;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5063</i>
		public static final int CXIdxEntity_CXXConstructor = (int)22;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5064</i>
		public static final int CXIdxEntity_CXXDestructor = (int)23;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5065</i>
		public static final int CXIdxEntity_CXXConversionFunction = (int)24;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5066</i>
		public static final int CXIdxEntity_CXXTypeAlias = (int)25;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5067</i>
		public static final int CXIdxEntity_CXXInterface = (int)26;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxEntityLanguage {
		/// <i>native declaration : src/main/c/clang-c/Index.h:5072</i>
		public static final int CXIdxEntityLang_None = (int)0;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5073</i>
		public static final int CXIdxEntityLang_C = (int)1;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5074</i>
		public static final int CXIdxEntityLang_ObjC = (int)2;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5075</i>
		public static final int CXIdxEntityLang_CXX = (int)3;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxEntityCXXTemplateKind {
		/// <i>native declaration : src/main/c/clang-c/Index.h:5089</i>
		public static final int CXIdxEntity_NonTemplate = (int)0;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5090</i>
		public static final int CXIdxEntity_Template = (int)1;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5091</i>
		public static final int CXIdxEntity_TemplatePartialSpecialization = (int)2;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5092</i>
		public static final int CXIdxEntity_TemplateSpecialization = (int)3;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxAttrKind {
		/// <i>native declaration : src/main/c/clang-c/Index.h:5096</i>
		public static final int CXIdxAttr_Unexposed = (int)0;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5097</i>
		public static final int CXIdxAttr_IBAction = (int)1;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5098</i>
		public static final int CXIdxAttr_IBOutlet = (int)2;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5099</i>
		public static final int CXIdxAttr_IBOutletCollection = (int)3;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxDeclInfoFlags {
		/// <i>native declaration : src/main/c/clang-c/Index.h:5131</i>
		public static final int CXIdxDeclFlag_Skipped = (int)1;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxObjCContainerKind {
		/// <i>native declaration : src/main/c/clang-c/Index.h:5161</i>
		public static final int CXIdxObjCContainer_ForwardRef = (int)0;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5162</i>
		public static final int CXIdxObjCContainer_Interface = (int)1;
		/// <i>native declaration : src/main/c/clang-c/Index.h:5163</i>
		public static final int CXIdxObjCContainer_Implementation = (int)2;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxEntityRefKind {
		/**
		 * \brief The entity is referenced directly in user's code.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:5221</i>
		 */
		public static final int CXIdxEntityRef_Direct = (int)1;
		/**
		 * \brief An implicit reference, e.g. a reference of an ObjC method via the<br>
		 * dot syntax.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:5226</i>
		 */
		public static final int CXIdxEntityRef_Implicit = (int)2;
	};
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : src/main/c/clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIndexOptFlags {
		/**
		 * \brief Used to indicate that no special indexing options are needed.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:5390</i>
		 */
		public static final int CXIndexOpt_None = (int)0;
		/**
		 * \brief Used to indicate that IndexerCallbacks#indexEntityReference should<br>
		 * be invoked for only one reference of an entity per source file that does<br>
		 * not also include a declaration/definition of the entity.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:5397</i>
		 */
		public static final int CXIndexOpt_SuppressRedundantRefs = (int)1;
		/**
		 * \brief Function-local symbols should be indexed. If this is not set<br>
		 * function-local symbols will be ignored.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:5403</i>
		 */
		public static final int CXIndexOpt_IndexFunctionLocalSymbols = (int)2;
		/**
		 * \brief Implicit function/class template instantiations should be indexed.<br>
		 * If this is not set, implicit instantiations will be ignored.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:5409</i>
		 */
		public static final int CXIndexOpt_IndexImplicitTemplateInstantiations = (int)4;
		/**
		 * \brief Suppress all compiler warnings when parsing for indexing.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:5414</i>
		 */
		public static final int CXIndexOpt_SuppressWarnings = (int)8;
		/**
		 * \brief Skip a function/method body that was already parsed during an<br>
		 * indexing session assosiated with a \c CXIndexAction object.<br>
		 * Bodies in system headers are always skipped.<br>
		 * <i>native declaration : src/main/c/clang-c/Index.h:5421</i>
		 */
		public static final int CXIndexOpt_SkipParsedBodiesInSession = (int)16;
	};
	/// <i>native declaration : src/main/c/clang-c/Index.h</i>
	public static final int CINDEX_VERSION_MINOR = (int)9;
	/// <i>native declaration : src/main/c/clang-c/Index.h</i>
	public static final int CINDEX_VERSION = (int)(((0) * 10000) + ((9) * 1));
	/// <i>native declaration : src/main/c/clang-c/Index.h</i>
	public static final String CINDEX_VERSION_STRING = (String)"0";
	/// <i>native declaration : src/main/c/clang-c/Index.h</i>
	public static final int CINDEX_VERSION_MAJOR = (int)0;
	/**
	 * Type of a signal handler.<br>
	 * <i>native declaration : src/main/c/clang-c/Platform.h</i>
	 */
	/**
	 * Type of a signal handler.<br>
	 * <i>native declaration : src/main/c/clang-c/Platform.h</i>
	 */
	public interface __kernel_sighandler_t extends Callback {
		void apply(int int1);
	};
	/**
	 * \brief Visitor invoked for each cursor found by a traversal.<br>
	 * * This visitor function will be invoked for each cursor found by<br>
	 * clang_visitCursorChildren(). Its first argument is the cursor being<br>
	 * visited, its second argument is the parent visitor for that cursor,<br>
	 * and its third argument is the client data provided to<br>
	 * clang_visitCursorChildren().<br>
	 * * The visitor should return one of the \c CXChildVisitResult values<br>
	 * to direct clang_visitCursorChildren().<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h</i>
	 */
	public interface CXCursorVisitor extends Callback {
		int apply(CXCursor.ByValue cursor, CXCursor.ByValue parent, Pointer client_data);
	};
	/**
	 * \brief Visitor invoked for each file in a translation unit<br>
	 *        (used with clang_getInclusions()).<br>
	 * * This visitor function will be invoked by clang_getInclusions() for each<br>
	 * file included (either at the top-level or by \#include directives) within<br>
	 * a translation unit.  The first argument is the file being included, and<br>
	 * the second and third arguments provide the inclusion stack.  The<br>
	 * array is sorted in order of immediate inclusion.  For example,<br>
	 * the first element refers to the location that included 'included_file'.<br>
	 * <i>native declaration : src/main/c/clang-c/Index.h</i>
	 */
	public interface CXInclusionVisitor extends Callback {
		void apply(Pointer included_file, CXSourceLocation inclusion_stack, ClangLibrary.include_len include_len1, Pointer client_data);
	};
	/// <i>native declaration : src/main/c/clang-c/Index.h:4072</i>
	/// <i>native declaration : src/main/c/clang-c/Index.h:4072</i>
	public interface clang_executeOnThread_fn_callback extends Callback {
		void apply(Pointer voidPtr1);
	};
	/**
	 * \brief Retrieve the character data associated with the given string.<br>
	 * Original signature : <code>char* clang_getCString(CXString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/CXString.h:29</i>
	 */
	String clang_getCString(CXString.ByValue string);
	/**
	 * \brief Free the given string,<br>
	 * Original signature : <code>void clang_disposeString(CXString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/CXString.h:34</i>
	 */
	void clang_disposeString(CXString.ByValue string);
	/**
	 * \brief Provides a shared context for creating translation units.<br>
	 * * It provides two options:<br>
	 * * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of "local"<br>
	 * declarations (when loading any new translation units). A "local" declaration<br>
	 * is one that belongs in the translation unit itself and not in a precompiled<br>
	 * header that was used by the translation unit. If zero, all declarations<br>
	 * will be enumerated.<br>
	 * * Here is an example:<br>
	 * * \code<br>
	 *   // excludeDeclsFromPCH = 1, displayDiagnostics=1<br>
	 *   Idx = clang_createIndex(1, 1);<br>
	 * *   // IndexTest.pch was produced with the following command:<br>
	 *   // "clang -x c IndexTest.h -emit-ast -o IndexTest.pch"<br>
	 *   TU = clang_createTranslationUnit(Idx, "IndexTest.pch");<br>
	 * *   // This will load all the symbols from 'IndexTest.pch'<br>
	 *   clang_visitChildren(clang_getTranslationUnitCursor(TU),<br>
	 *                       TranslationUnitVisitor, 0);<br>
	 *   clang_disposeTranslationUnit(TU);<br>
	 * *   // This will load all the symbols from 'IndexTest.c', excluding symbols<br>
	 *   // from 'IndexTest.pch'.<br>
	 *   char *args[] = { "-Xclang", "-include-pch=IndexTest.pch" };<br>
	 *   TU = clang_createTranslationUnitFromSourceFile(Idx, "IndexTest.c", 2, args,<br>
	 *                                                  0, 0);<br>
	 *   clang_visitChildren(clang_getTranslationUnitCursor(TU),<br>
	 *                       TranslationUnitVisitor, 0);<br>
	 *   clang_disposeTranslationUnit(TU);<br>
	 * \endcode<br>
	 * * This process of creating the 'pch', loading it separately, and using it (via<br>
	 * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks<br>
	 * (which gives the indexer the same performance benefit as the compiler).<br>
	 * Original signature : <code>CXIndex clang_createIndex(int, int)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:185</i>
	 */
	Pointer clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics);
	/**
	 * \brief Destroy the given index.<br>
	 * * The index must not be destroyed until all of the translation units created<br>
	 * within that index have been destroyed.<br>
	 * Original signature : <code>void clang_disposeIndex(CXIndex)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:194</i>
	 */
	void clang_disposeIndex(Pointer index);
	/**
	 * \brief Sets general options associated with a CXIndex.<br>
	 * * For example:<br>
	 * \code<br>
	 * CXIndex idx = ...;<br>
	 * clang_CXIndex_setGlobalOptions(idx,<br>
	 *     clang_CXIndex_getGlobalOptions(idx) |<br>
	 *     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);<br>
	 * \endcode<br>
	 * * \param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.<br>
	 * Original signature : <code>void clang_CXIndex_setGlobalOptions(CXIndex, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:243</i>
	 */
	void clang_CXIndex_setGlobalOptions(Pointer CXIndex1, int options);
	/**
	 * \brief Gets the general options associated with a CXIndex.<br>
	 * * \returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that<br>
	 * are associated with the given CXIndex object.<br>
	 * Original signature : <code>int clang_CXIndex_getGlobalOptions(CXIndex)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:251</i>
	 */
	int clang_CXIndex_getGlobalOptions(Pointer CXIndex1);
	/**
	 * \brief Retrieve the complete file and path name of the given file.<br>
	 * Original signature : <code>CXString clang_getFileName(CXFile)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:268</i>
	 */
	CXString.ByValue clang_getFileName(Pointer SFile);
	/**
	 * \brief Retrieve the last modification time of the given file.<br>
	 * Original signature : <code>time_t clang_getFileTime(CXFile)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:273</i>
	 */
	ClangLibrary.time_t clang_getFileTime(Pointer SFile);
	/**
	 * \brief Determine whether the given header is guarded against<br>
	 * multiple inclusions, either with the conventional<br>
	 * \#ifndef/\#define/\#endif macro guards or with \#pragma once.<br>
	 * Original signature : <code>int clang_isFileMultipleIncludeGuarded(CXTranslationUnit, CXFile)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:280</i>
	 */
	int clang_isFileMultipleIncludeGuarded(ClangLibrary.CXTranslationUnit tu, Pointer file);
	/**
	 * \brief Retrieve a file handle within the given translation unit.<br>
	 * * \param tu the translation unit<br>
	 * * \param file_name the name of the file.<br>
	 * * \returns the file handle for the named file in the translation unit \p tu,<br>
	 * or a NULL file handle if the file was not a part of this translation unit.<br>
	 * Original signature : <code>CXFile clang_getFile(CXTranslationUnit, const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:293</i><br>
	 * @deprecated use the safer methods {@link #clang_getFile(clang.ClangLibrary.CXTranslationUnit, java.lang.String)} and {@link #clang_getFile(clang.ClangLibrary.CXTranslationUnit, com.sun.jna.Pointer)} instead
	 */
	@Deprecated
	Pointer clang_getFile(ClangLibrary.CXTranslationUnit tu, Pointer file_name);
	/**
	 * \brief Retrieve a file handle within the given translation unit.<br>
	 * * \param tu the translation unit<br>
	 * * \param file_name the name of the file.<br>
	 * * \returns the file handle for the named file in the translation unit \p tu,<br>
	 * or a NULL file handle if the file was not a part of this translation unit.<br>
	 * Original signature : <code>CXFile clang_getFile(CXTranslationUnit, const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:293</i>
	 */
	Pointer clang_getFile(ClangLibrary.CXTranslationUnit tu, String file_name);
	/**
	 * \brief Retrieve a NULL (invalid) source location.<br>
	 * Original signature : <code>CXSourceLocation clang_getNullLocation()</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:340</i>
	 */
	CXSourceLocation.ByValue clang_getNullLocation();
	/**
	 * \brief Determine whether two source locations, which must refer into<br>
	 * the same translation unit, refer to exactly the same point in the source<br>
	 * code.<br>
	 * * \returns non-zero if the source locations refer to the same location, zero<br>
	 * if they refer to different locations.<br>
	 * Original signature : <code>int clang_equalLocations(CXSourceLocation, CXSourceLocation)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:350</i>
	 */
	int clang_equalLocations(CXSourceLocation.ByValue loc1, CXSourceLocation.ByValue loc2);
	/**
	 * \brief Retrieves the source location associated with a given file/line/column<br>
	 * in a particular translation unit.<br>
	 * Original signature : <code>CXSourceLocation clang_getLocation(CXTranslationUnit, CXFile, unsigned, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:357</i>
	 */
	CXSourceLocation.ByValue clang_getLocation(ClangLibrary.CXTranslationUnit tu, Pointer file, int line, int column);
	/**
	 * \brief Retrieves the source location associated with a given character offset<br>
	 * in a particular translation unit.<br>
	 * Original signature : <code>CXSourceLocation clang_getLocationForOffset(CXTranslationUnit, CXFile, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:365</i>
	 */
	CXSourceLocation.ByValue clang_getLocationForOffset(ClangLibrary.CXTranslationUnit tu, Pointer file, int offset);
	/**
	 * \brief Retrieve a NULL (invalid) source range.<br>
	 * Original signature : <code>CXSourceRange clang_getNullRange()</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:372</i>
	 */
	CXSourceRange.ByValue clang_getNullRange();
	/**
	 * \brief Retrieve a source range given the beginning and ending source<br>
	 * locations.<br>
	 * Original signature : <code>CXSourceRange clang_getRange(CXSourceLocation, CXSourceLocation)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:378</i>
	 */
	CXSourceRange.ByValue clang_getRange(CXSourceLocation.ByValue begin, CXSourceLocation.ByValue end);
	/**
	 * \brief Determine whether two ranges are equivalent.<br>
	 * * \returns non-zero if the ranges are the same, zero if they differ.<br>
	 * Original signature : <code>int clang_equalRanges(CXSourceRange, CXSourceRange)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:386</i>
	 */
	int clang_equalRanges(CXSourceRange.ByValue range1, CXSourceRange.ByValue range2);
	/**
	 * \brief Returns non-zero if \p range is null.<br>
	 * Original signature : <code>int clang_Range_isNull(CXSourceRange)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:392</i>
	 */
	int clang_Range_isNull(CXSourceRange.ByValue range);
	/**
	 * \brief Retrieve the file, line, column, and offset represented by<br>
	 * the given source location.<br>
	 * * If the location refers into a macro expansion, retrieves the<br>
	 * location of the macro expansion.<br>
	 * * \param location the location within a source file that will be decomposed<br>
	 * into its parts.<br>
	 * * \param file [out] if non-NULL, will be set to the file to which the given<br>
	 * source location points.<br>
	 * * \param line [out] if non-NULL, will be set to the line to which the given<br>
	 * source location points.<br>
	 * * \param column [out] if non-NULL, will be set to the column to which the given<br>
	 * source location points.<br>
	 * * \param offset [out] if non-NULL, will be set to the offset into the<br>
	 * buffer to which the given source location points.<br>
	 * Original signature : <code>void clang_getExpansionLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:416</i><br>
	 * @deprecated use the safer methods {@link #clang_getExpansionLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_getExpansionLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	void clang_getExpansionLocation(CXSourceLocation.ByValue location, Pointer file, IntByReference line, IntByReference column, IntByReference offset);
	/**
	 * \brief Retrieve the file, line, column, and offset represented by<br>
	 * the given source location.<br>
	 * * If the location refers into a macro expansion, retrieves the<br>
	 * location of the macro expansion.<br>
	 * * \param location the location within a source file that will be decomposed<br>
	 * into its parts.<br>
	 * * \param file [out] if non-NULL, will be set to the file to which the given<br>
	 * source location points.<br>
	 * * \param line [out] if non-NULL, will be set to the line to which the given<br>
	 * source location points.<br>
	 * * \param column [out] if non-NULL, will be set to the column to which the given<br>
	 * source location points.<br>
	 * * \param offset [out] if non-NULL, will be set to the offset into the<br>
	 * buffer to which the given source location points.<br>
	 * Original signature : <code>void clang_getExpansionLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:416</i>
	 */
	void clang_getExpansionLocation(CXSourceLocation.ByValue location, Pointer file, IntBuffer line, IntBuffer column, IntBuffer offset);
	/**
	 * \brief Retrieve the file, line, column, and offset represented by<br>
	 * the given source location, as specified in a # line directive.<br>
	 * * Example: given the following source code in a file somefile.c<br>
	 * * \code<br>
	 * #123 "dummy.c" 1<br>
	 * * static int func(void)<br>
	 * {<br>
	 *     return 0;<br>
	 * }<br>
	 * \endcode<br>
	 * * the location information returned by this function would be<br>
	 * * File: dummy.c Line: 124 Column: 12<br>
	 * * whereas clang_getExpansionLocation would have returned<br>
	 * * File: somefile.c Line: 3 Column: 12<br>
	 * * \param location the location within a source file that will be decomposed<br>
	 * into its parts.<br>
	 * * \param filename [out] if non-NULL, will be set to the filename of the<br>
	 * source location. Note that filenames returned will be for "virtual" files,<br>
	 * which don't necessarily exist on the machine running clang - e.g. when<br>
	 * parsing preprocessed output obtained from a different environment. If<br>
	 * a non-NULL value is passed in, remember to dispose of the returned value<br>
	 * using \c clang_disposeString() once you've finished with it. For an invalid<br>
	 * source location, an empty string is returned.<br>
	 * * \param line [out] if non-NULL, will be set to the line number of the<br>
	 * source location. For an invalid source location, zero is returned.<br>
	 * * \param column [out] if non-NULL, will be set to the column number of the<br>
	 * source location. For an invalid source location, zero is returned.<br>
	 * Original signature : <code>void clang_getPresumedLocation(CXSourceLocation, CXString*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:462</i><br>
	 * @deprecated use the safer methods {@link #clang_getPresumedLocation(clang.CXSourceLocation.ByValue, clang.CXString, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_getPresumedLocation(clang.CXSourceLocation.ByValue, clang.CXString, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	void clang_getPresumedLocation(CXSourceLocation.ByValue location, CXString filename, IntByReference line, IntByReference column);
	/**
	 * \brief Retrieve the file, line, column, and offset represented by<br>
	 * the given source location, as specified in a # line directive.<br>
	 * * Example: given the following source code in a file somefile.c<br>
	 * * \code<br>
	 * #123 "dummy.c" 1<br>
	 * * static int func(void)<br>
	 * {<br>
	 *     return 0;<br>
	 * }<br>
	 * \endcode<br>
	 * * the location information returned by this function would be<br>
	 * * File: dummy.c Line: 124 Column: 12<br>
	 * * whereas clang_getExpansionLocation would have returned<br>
	 * * File: somefile.c Line: 3 Column: 12<br>
	 * * \param location the location within a source file that will be decomposed<br>
	 * into its parts.<br>
	 * * \param filename [out] if non-NULL, will be set to the filename of the<br>
	 * source location. Note that filenames returned will be for "virtual" files,<br>
	 * which don't necessarily exist on the machine running clang - e.g. when<br>
	 * parsing preprocessed output obtained from a different environment. If<br>
	 * a non-NULL value is passed in, remember to dispose of the returned value<br>
	 * using \c clang_disposeString() once you've finished with it. For an invalid<br>
	 * source location, an empty string is returned.<br>
	 * * \param line [out] if non-NULL, will be set to the line number of the<br>
	 * source location. For an invalid source location, zero is returned.<br>
	 * * \param column [out] if non-NULL, will be set to the column number of the<br>
	 * source location. For an invalid source location, zero is returned.<br>
	 * Original signature : <code>void clang_getPresumedLocation(CXSourceLocation, CXString*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:462</i>
	 */
	void clang_getPresumedLocation(CXSourceLocation.ByValue location, CXString filename, IntBuffer line, IntBuffer column);
	/**
	 * \brief Legacy API to retrieve the file, line, column, and offset represented<br>
	 * by the given source location.<br>
	 * * This interface has been replaced by the newer interface<br>
	 * #clang_getExpansionLocation(). See that interface's documentation for<br>
	 * details.<br>
	 * Original signature : <code>void clang_getInstantiationLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:475</i><br>
	 * @deprecated use the safer methods {@link #clang_getInstantiationLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_getInstantiationLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	void clang_getInstantiationLocation(CXSourceLocation.ByValue location, Pointer file, IntByReference line, IntByReference column, IntByReference offset);
	/**
	 * \brief Legacy API to retrieve the file, line, column, and offset represented<br>
	 * by the given source location.<br>
	 * * This interface has been replaced by the newer interface<br>
	 * #clang_getExpansionLocation(). See that interface's documentation for<br>
	 * details.<br>
	 * Original signature : <code>void clang_getInstantiationLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:475</i>
	 */
	void clang_getInstantiationLocation(CXSourceLocation.ByValue location, Pointer file, IntBuffer line, IntBuffer column, IntBuffer offset);
	/**
	 * \brief Retrieve the file, line, column, and offset represented by<br>
	 * the given source location.<br>
	 * * If the location refers into a macro instantiation, return where the<br>
	 * location was originally spelled in the source file.<br>
	 * * \param location the location within a source file that will be decomposed<br>
	 * into its parts.<br>
	 * * \param file [out] if non-NULL, will be set to the file to which the given<br>
	 * source location points.<br>
	 * * \param line [out] if non-NULL, will be set to the line to which the given<br>
	 * source location points.<br>
	 * * \param column [out] if non-NULL, will be set to the column to which the given<br>
	 * source location points.<br>
	 * * \param offset [out] if non-NULL, will be set to the offset into the<br>
	 * buffer to which the given source location points.<br>
	 * Original signature : <code>void clang_getSpellingLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:503</i><br>
	 * @deprecated use the safer methods {@link #clang_getSpellingLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_getSpellingLocation(clang.CXSourceLocation.ByValue, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	void clang_getSpellingLocation(CXSourceLocation.ByValue location, Pointer file, IntByReference line, IntByReference column, IntByReference offset);
	/**
	 * \brief Retrieve the file, line, column, and offset represented by<br>
	 * the given source location.<br>
	 * * If the location refers into a macro instantiation, return where the<br>
	 * location was originally spelled in the source file.<br>
	 * * \param location the location within a source file that will be decomposed<br>
	 * into its parts.<br>
	 * * \param file [out] if non-NULL, will be set to the file to which the given<br>
	 * source location points.<br>
	 * * \param line [out] if non-NULL, will be set to the line to which the given<br>
	 * source location points.<br>
	 * * \param column [out] if non-NULL, will be set to the column to which the given<br>
	 * source location points.<br>
	 * * \param offset [out] if non-NULL, will be set to the offset into the<br>
	 * buffer to which the given source location points.<br>
	 * Original signature : <code>void clang_getSpellingLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:503</i>
	 */
	void clang_getSpellingLocation(CXSourceLocation.ByValue location, Pointer file, IntBuffer line, IntBuffer column, IntBuffer offset);
	/**
	 * \brief Retrieve a source location representing the first character within a<br>
	 * source range.<br>
	 * Original signature : <code>CXSourceLocation clang_getRangeStart(CXSourceRange)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:513</i>
	 */
	CXSourceLocation.ByValue clang_getRangeStart(CXSourceRange.ByValue range);
	/**
	 * \brief Retrieve a source location representing the last character within a<br>
	 * source range.<br>
	 * Original signature : <code>CXSourceLocation clang_getRangeEnd(CXSourceRange)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:519</i>
	 */
	CXSourceLocation.ByValue clang_getRangeEnd(CXSourceRange.ByValue range);
	/**
	 * \brief Determine the number of diagnostics in a CXDiagnosticSet.<br>
	 * Original signature : <code>int clang_getNumDiagnosticsInSet(CXDiagnosticSet)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:580</i>
	 */
	int clang_getNumDiagnosticsInSet(Pointer Diags);
	/**
	 * \brief Retrieve a diagnostic associated with the given CXDiagnosticSet.<br>
	 * * \param Diags the CXDiagnosticSet to query.<br>
	 * \param Index the zero-based diagnostic number to retrieve.<br>
	 * * \returns the requested diagnostic. This diagnostic must be freed<br>
	 * via a call to \c clang_disposeDiagnostic().<br>
	 * Original signature : <code>CXDiagnostic clang_getDiagnosticInSet(CXDiagnosticSet, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:591</i>
	 */
	Pointer clang_getDiagnosticInSet(Pointer Diags, int Index);
	/**
	 * \brief Deserialize a set of diagnostics from a Clang diagnostics bitcode<br>
	 * file.<br>
	 * * \param file The name of the file to deserialize.<br>
	 * \param error A pointer to a enum value recording if there was a problem<br>
	 *        deserializing the diagnostics.<br>
	 * \param errorString A pointer to a CXString for recording the error string<br>
	 *        if the file was not successfully loaded.<br>
	 * * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These<br>
	 * diagnostics should be released using clang_disposeDiagnosticSet().<br>
	 * Original signature : <code>CXDiagnosticSet clang_loadDiagnostics(const char*, CXLoadDiag_Error*, CXString*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:637</i><br>
	 * @deprecated use the safer methods {@link #clang_loadDiagnostics(java.lang.String, java.nio.IntBuffer, clang.CXString)} and {@link #clang_loadDiagnostics(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, clang.CXString)} instead
	 */
	@Deprecated
	Pointer clang_loadDiagnostics(Pointer file, IntByReference error, CXString errorString);
	/**
	 * \brief Deserialize a set of diagnostics from a Clang diagnostics bitcode<br>
	 * file.<br>
	 * * \param file The name of the file to deserialize.<br>
	 * \param error A pointer to a enum value recording if there was a problem<br>
	 *        deserializing the diagnostics.<br>
	 * \param errorString A pointer to a CXString for recording the error string<br>
	 *        if the file was not successfully loaded.<br>
	 * * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These<br>
	 * diagnostics should be released using clang_disposeDiagnosticSet().<br>
	 * Original signature : <code>CXDiagnosticSet clang_loadDiagnostics(const char*, CXLoadDiag_Error*, CXString*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:637</i>
	 */
	Pointer clang_loadDiagnostics(String file, IntBuffer error, CXString errorString);
	/**
	 * \brief Release a CXDiagnosticSet and all of its contained diagnostics.<br>
	 * Original signature : <code>void clang_disposeDiagnosticSet(CXDiagnosticSet)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:644</i>
	 */
	void clang_disposeDiagnosticSet(Pointer Diags);
	/**
	 * \brief Retrieve the child diagnostics of a CXDiagnostic. <br>
	 * * This CXDiagnosticSet does not need to be released by<br>
	 * clang_diposeDiagnosticSet.<br>
	 * Original signature : <code>CXDiagnosticSet clang_getChildDiagnostics(CXDiagnostic)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:652</i>
	 */
	Pointer clang_getChildDiagnostics(Pointer D);
	/**
	 * \brief Determine the number of diagnostics produced for the given<br>
	 * translation unit.<br>
	 * Original signature : <code>int clang_getNumDiagnostics(CXTranslationUnit)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:658</i>
	 */
	int clang_getNumDiagnostics(ClangLibrary.CXTranslationUnit Unit);
	/**
	 * \brief Retrieve a diagnostic associated with the given translation unit.<br>
	 * * \param Unit the translation unit to query.<br>
	 * \param Index the zero-based diagnostic number to retrieve.<br>
	 * * \returns the requested diagnostic. This diagnostic must be freed<br>
	 * via a call to \c clang_disposeDiagnostic().<br>
	 * Original signature : <code>CXDiagnostic clang_getDiagnostic(CXTranslationUnit, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:669</i>
	 */
	Pointer clang_getDiagnostic(ClangLibrary.CXTranslationUnit Unit, int Index);
	/**
	 * \brief Retrieve the complete set of diagnostics associated with a<br>
	 *        translation unit.<br>
	 * * \param Unit the translation unit to query.<br>
	 * Original signature : <code>CXDiagnosticSet clang_getDiagnosticSetFromTU(CXTranslationUnit)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:678</i>
	 */
	Pointer clang_getDiagnosticSetFromTU(ClangLibrary.CXTranslationUnit Unit);
	/**
	 * \brief Destroy a diagnostic.<br>
	 * Original signature : <code>void clang_disposeDiagnostic(CXDiagnostic)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:684</i>
	 */
	void clang_disposeDiagnostic(Pointer Diagnostic);
	/**
	 * \brief Format the given diagnostic in a manner that is suitable for display.<br>
	 * * This routine will format the given diagnostic to a string, rendering<br>
	 * the diagnostic according to the various options given. The<br>
	 * \c clang_defaultDiagnosticDisplayOptions() function returns the set of<br>
	 * options that most closely mimics the behavior of the clang compiler.<br>
	 * * \param Diagnostic The diagnostic to print.<br>
	 * * \param Options A set of options that control the diagnostic display,<br>
	 * created by combining \c CXDiagnosticDisplayOptions values.<br>
	 * * \returns A new string containing for formatted diagnostic.<br>
	 * Original signature : <code>CXString clang_formatDiagnostic(CXDiagnostic, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:769</i>
	 */
	CXString.ByValue clang_formatDiagnostic(Pointer Diagnostic, int Options);
	/**
	 * \brief Retrieve the set of display options most similar to the<br>
	 * default behavior of the clang compiler.<br>
	 * * \returns A set of display options suitable for use with \c<br>
	 * clang_displayDiagnostic().<br>
	 * Original signature : <code>int clang_defaultDiagnosticDisplayOptions()</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:779</i>
	 */
	int clang_defaultDiagnosticDisplayOptions();
	/**
	 * \brief Determine the severity of the given diagnostic.<br>
	 * Original signature : <code>CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:784</i>
	 */
	int clang_getDiagnosticSeverity(Pointer CXDiagnostic1);
	/**
	 * \brief Retrieve the source location of the given diagnostic.<br>
	 * * This location is where Clang would print the caret ('^') when<br>
	 * displaying the diagnostic on the command line.<br>
	 * Original signature : <code>CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:793</i>
	 */
	CXSourceLocation.ByValue clang_getDiagnosticLocation(Pointer CXDiagnostic1);
	/**
	 * \brief Retrieve the text of the given diagnostic.<br>
	 * Original signature : <code>CXString clang_getDiagnosticSpelling(CXDiagnostic)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:798</i>
	 */
	CXString.ByValue clang_getDiagnosticSpelling(Pointer CXDiagnostic1);
	/**
	 * \brief Retrieve the name of the command-line option that enabled this<br>
	 * diagnostic.<br>
	 * * \param Diag The diagnostic to be queried.<br>
	 * * \param Disable If non-NULL, will be set to the option that disables this<br>
	 * diagnostic (if any).<br>
	 * * \returns A string that contains the command-line option used to enable this<br>
	 * warning, such as "-Wconversion" or "-pedantic".<br>
	 * Original signature : <code>CXString clang_getDiagnosticOption(CXDiagnostic, CXString*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:812</i>
	 */
	CXString.ByValue clang_getDiagnosticOption(Pointer Diag, CXString Disable);
	/**
	 * \brief Retrieve the category number for this diagnostic.<br>
	 * * Diagnostics can be categorized into groups along with other, related<br>
	 * diagnostics (e.g., diagnostics under the same warning flag). This routine <br>
	 * retrieves the category number for the given diagnostic.<br>
	 * * \returns The number of the category that contains this diagnostic, or zero<br>
	 * if this diagnostic is uncategorized.<br>
	 * Original signature : <code>int clang_getDiagnosticCategory(CXDiagnostic)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:825</i>
	 */
	int clang_getDiagnosticCategory(Pointer CXDiagnostic1);
	/**
	 * Original signature : <code>CXString clang_getDiagnosticCategoryName(unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:838</i>
	 */
	CXString.ByValue clang_getDiagnosticCategoryName(int Category);
	/**
	 * \brief Retrieve the diagnostic category text for a given diagnostic.<br>
	 * * \returns The text of the given diagnostic category.<br>
	 * Original signature : <code>CXString clang_getDiagnosticCategoryText(CXDiagnostic)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:845</i>
	 */
	CXString.ByValue clang_getDiagnosticCategoryText(Pointer CXDiagnostic1);
	/**
	 * \brief Determine the number of source ranges associated with the given<br>
	 * diagnostic.<br>
	 * Original signature : <code>int clang_getDiagnosticNumRanges(CXDiagnostic)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:851</i>
	 */
	int clang_getDiagnosticNumRanges(Pointer CXDiagnostic1);
	/**
	 * \brief Retrieve a source range associated with the diagnostic.<br>
	 * * A diagnostic's source ranges highlight important elements in the source<br>
	 * code. On the command line, Clang displays source ranges by<br>
	 * underlining them with '~' characters.<br>
	 * * \param Diagnostic the diagnostic whose range is being extracted.<br>
	 * * \param Range the zero-based index specifying which range to<br>
	 * * \returns the requested source range.<br>
	 * Original signature : <code>CXSourceRange clang_getDiagnosticRange(CXDiagnostic, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:866</i>
	 */
	CXSourceRange.ByValue clang_getDiagnosticRange(Pointer Diagnostic, int Range);
	/**
	 * \brief Determine the number of fix-it hints associated with the<br>
	 * given diagnostic.<br>
	 * Original signature : <code>int clang_getDiagnosticNumFixIts(CXDiagnostic)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:873</i>
	 */
	int clang_getDiagnosticNumFixIts(Pointer Diagnostic);
	/**
	 * \brief Retrieve the replacement information for a given fix-it.<br>
	 * * Fix-its are described in terms of a source range whose contents<br>
	 * should be replaced by a string. This approach generalizes over<br>
	 * three kinds of operations: removal of source code (the range covers<br>
	 * the code to be removed and the replacement string is empty),<br>
	 * replacement of source code (the range covers the code to be<br>
	 * replaced and the replacement string provides the new code), and<br>
	 * insertion (both the start and end of the range point at the<br>
	 * insertion location, and the replacement string provides the text to<br>
	 * insert).<br>
	 * * \param Diagnostic The diagnostic whose fix-its are being queried.<br>
	 * * \param FixIt The zero-based index of the fix-it.<br>
	 * * \param ReplacementRange The source range whose contents will be<br>
	 * replaced with the returned replacement string. Note that source<br>
	 * ranges are half-open ranges [a, b), so the source code should be<br>
	 * replaced from a and up to (but not including) b.<br>
	 * * \returns A string containing text that should be replace the source<br>
	 * code indicated by the \c ReplacementRange.<br>
	 * Original signature : <code>CXString clang_getDiagnosticFixIt(CXDiagnostic, unsigned, CXSourceRange*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:900</i>
	 */
	CXString.ByValue clang_getDiagnosticFixIt(Pointer Diagnostic, int FixIt, CXSourceRange ReplacementRange);
	/**
	 * \brief Get the original translation unit source file name.<br>
	 * Original signature : <code>CXString clang_getTranslationUnitSpelling(CXTranslationUnit)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:921</i>
	 */
	CXString.ByValue clang_getTranslationUnitSpelling(ClangLibrary.CXTranslationUnit CTUnit);
	/**
	 * \brief Return the CXTranslationUnit for a given source file and the provided<br>
	 * command line arguments one would pass to the compiler.<br>
	 * * Note: The 'source_filename' argument is optional.  If the caller provides a<br>
	 * NULL pointer, the name of the source file is expected to reside in the<br>
	 * specified command line arguments.<br>
	 * * Note: When encountered in 'clang_command_line_args', the following options<br>
	 * are ignored:<br>
	 * *   '-c'<br>
	 *   '-emit-ast'<br>
	 *   '-fsyntax-only'<br>
	 *   '-o \<output file>'  (both '-o' and '\<output file>' are ignored)<br>
	 * * \param CIdx The index object with which the translation unit will be<br>
	 * associated.<br>
	 * * \param source_filename The name of the source file to load, or NULL if the<br>
	 * source file is included in \p clang_command_line_args.<br>
	 * * \param num_clang_command_line_args The number of command-line arguments in<br>
	 * \p clang_command_line_args.<br>
	 * * \param clang_command_line_args The command-line arguments that would be<br>
	 * passed to the \c clang executable if it were being invoked out-of-process.<br>
	 * These command-line options will be parsed and will affect how the translation<br>
	 * unit is parsed. Note that the following options are ignored: '-c',<br>
	 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
	 * * \param num_unsaved_files the number of unsaved file entries in \p<br>
	 * unsaved_files.<br>
	 * * \param unsaved_files the files that have not yet been saved to disk<br>
	 * but may be required for code completion, including the contents of<br>
	 * those files.  The contents and name of these files (as specified by<br>
	 * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
	 * guarantee their validity until the call to this function returns.<br>
	 * Original signature : <code>CXTranslationUnit clang_createTranslationUnitFromSourceFile(CXIndex, const char*, int, const const char**, unsigned, CXUnsavedFile*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:964</i><br>
	 * @deprecated use the safer methods {@link #clang_createTranslationUnitFromSourceFile(com.sun.jna.Pointer, java.lang.String, int, byte[][], int, clang.CXUnsavedFile)} and {@link #clang_createTranslationUnitFromSourceFile(com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.ptr.PointerByReference, int, clang.CXUnsavedFile)} instead
	 */
	@Deprecated
	ClangLibrary.CXTranslationUnit clang_createTranslationUnitFromSourceFile(Pointer CIdx, Pointer source_filename, int num_clang_command_line_args, PointerByReference clang_command_line_args, int num_unsaved_files, CXUnsavedFile unsaved_files);
	/**
	 * \brief Return the CXTranslationUnit for a given source file and the provided<br>
	 * command line arguments one would pass to the compiler.<br>
	 * * Note: The 'source_filename' argument is optional.  If the caller provides a<br>
	 * NULL pointer, the name of the source file is expected to reside in the<br>
	 * specified command line arguments.<br>
	 * * Note: When encountered in 'clang_command_line_args', the following options<br>
	 * are ignored:<br>
	 * *   '-c'<br>
	 *   '-emit-ast'<br>
	 *   '-fsyntax-only'<br>
	 *   '-o \<output file>'  (both '-o' and '\<output file>' are ignored)<br>
	 * * \param CIdx The index object with which the translation unit will be<br>
	 * associated.<br>
	 * * \param source_filename The name of the source file to load, or NULL if the<br>
	 * source file is included in \p clang_command_line_args.<br>
	 * * \param num_clang_command_line_args The number of command-line arguments in<br>
	 * \p clang_command_line_args.<br>
	 * * \param clang_command_line_args The command-line arguments that would be<br>
	 * passed to the \c clang executable if it were being invoked out-of-process.<br>
	 * These command-line options will be parsed and will affect how the translation<br>
	 * unit is parsed. Note that the following options are ignored: '-c',<br>
	 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
	 * * \param num_unsaved_files the number of unsaved file entries in \p<br>
	 * unsaved_files.<br>
	 * * \param unsaved_files the files that have not yet been saved to disk<br>
	 * but may be required for code completion, including the contents of<br>
	 * those files.  The contents and name of these files (as specified by<br>
	 * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
	 * guarantee their validity until the call to this function returns.<br>
	 * Original signature : <code>CXTranslationUnit clang_createTranslationUnitFromSourceFile(CXIndex, const char*, int, const const char**, unsigned, CXUnsavedFile*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:964</i>
	 */
	ClangLibrary.CXTranslationUnit clang_createTranslationUnitFromSourceFile(Pointer CIdx, String source_filename, int num_clang_command_line_args, byte[] clang_command_line_args[], int num_unsaved_files, CXUnsavedFile unsaved_files);
	/**
	 * \brief Create a translation unit from an AST file (-emit-ast).<br>
	 * Original signature : <code>CXTranslationUnit clang_createTranslationUnit(CXIndex, const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:975</i><br>
	 * @deprecated use the safer methods {@link #clang_createTranslationUnit(com.sun.jna.Pointer, java.lang.String)} and {@link #clang_createTranslationUnit(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated
	ClangLibrary.CXTranslationUnit clang_createTranslationUnit(Pointer CXIndex1, Pointer ast_filename);
	/**
	 * \brief Create a translation unit from an AST file (-emit-ast).<br>
	 * Original signature : <code>CXTranslationUnit clang_createTranslationUnit(CXIndex, const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:975</i>
	 */
	ClangLibrary.CXTranslationUnit clang_createTranslationUnit(Pointer CXIndex1, String ast_filename);
	/**
	 * \brief Returns the set of flags that is suitable for parsing a translation<br>
	 * unit that is being edited.<br>
	 * * The set of flags returned provide options for \c clang_parseTranslationUnit()<br>
	 * to indicate that the translation unit is likely to be reparsed many times,<br>
	 * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly<br>
	 * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag<br>
	 * set contains an unspecified set of optimizations (e.g., the precompiled <br>
	 * preamble) geared toward improving the performance of these routines. The<br>
	 * set of optimizations enabled may change from one version to the next.<br>
	 * Original signature : <code>int clang_defaultEditingTranslationUnitOptions()</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1089</i>
	 */
	int clang_defaultEditingTranslationUnitOptions();
	/**
	 * \brief Parse the given source file and the translation unit corresponding<br>
	 * to that file.<br>
	 * * This routine is the main entry point for the Clang C API, providing the<br>
	 * ability to parse a source file into a translation unit that can then be<br>
	 * queried by other functions in the API. This routine accepts a set of<br>
	 * command-line arguments so that the compilation can be configured in the same<br>
	 * way that the compiler is configured on the command line.<br>
	 * * \param CIdx The index object with which the translation unit will be <br>
	 * associated.<br>
	 * * \param source_filename The name of the source file to load, or NULL if the<br>
	 * source file is included in \p command_line_args.<br>
	 * * \param command_line_args The command-line arguments that would be<br>
	 * passed to the \c clang executable if it were being invoked out-of-process.<br>
	 * These command-line options will be parsed and will affect how the translation<br>
	 * unit is parsed. Note that the following options are ignored: '-c', <br>
	 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
	 * * \param num_command_line_args The number of command-line arguments in<br>
	 * \p command_line_args.<br>
	 * * \param unsaved_files the files that have not yet been saved to disk<br>
	 * but may be required for parsing, including the contents of<br>
	 * those files.  The contents and name of these files (as specified by<br>
	 * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
	 * guarantee their validity until the call to this function returns.<br>
	 * * \param num_unsaved_files the number of unsaved file entries in \p<br>
	 * unsaved_files.<br>
	 * * \param options A bitmask of options that affects how the translation unit<br>
	 * is managed but not its compilation. This should be a bitwise OR of the<br>
	 * CXTranslationUnit_XXX flags.<br>
	 * * \returns A new translation unit describing the parsed code and containing<br>
	 * any diagnostics produced by the compiler. If there is a failure from which<br>
	 * the compiler cannot recover, returns NULL.<br>
	 * Original signature : <code>CXTranslationUnit clang_parseTranslationUnit(CXIndex, const char*, const const char**, int, CXUnsavedFile*, unsigned, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1133</i><br>
	 * @deprecated use the safer methods {@link #clang_parseTranslationUnit(com.sun.jna.Pointer, java.lang.String, byte[][], int, clang.CXUnsavedFile, int, int)} and {@link #clang_parseTranslationUnit(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, int, clang.CXUnsavedFile, int, int)} instead
	 */
	@Deprecated
	ClangLibrary.CXTranslationUnit clang_parseTranslationUnit(Pointer CIdx, Pointer source_filename, PointerByReference command_line_args, int num_command_line_args, CXUnsavedFile unsaved_files, int num_unsaved_files, int options);
	/**
	 * \brief Parse the given source file and the translation unit corresponding<br>
	 * to that file.<br>
	 * * This routine is the main entry point for the Clang C API, providing the<br>
	 * ability to parse a source file into a translation unit that can then be<br>
	 * queried by other functions in the API. This routine accepts a set of<br>
	 * command-line arguments so that the compilation can be configured in the same<br>
	 * way that the compiler is configured on the command line.<br>
	 * * \param CIdx The index object with which the translation unit will be <br>
	 * associated.<br>
	 * * \param source_filename The name of the source file to load, or NULL if the<br>
	 * source file is included in \p command_line_args.<br>
	 * * \param command_line_args The command-line arguments that would be<br>
	 * passed to the \c clang executable if it were being invoked out-of-process.<br>
	 * These command-line options will be parsed and will affect how the translation<br>
	 * unit is parsed. Note that the following options are ignored: '-c', <br>
	 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
	 * * \param num_command_line_args The number of command-line arguments in<br>
	 * \p command_line_args.<br>
	 * * \param unsaved_files the files that have not yet been saved to disk<br>
	 * but may be required for parsing, including the contents of<br>
	 * those files.  The contents and name of these files (as specified by<br>
	 * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
	 * guarantee their validity until the call to this function returns.<br>
	 * * \param num_unsaved_files the number of unsaved file entries in \p<br>
	 * unsaved_files.<br>
	 * * \param options A bitmask of options that affects how the translation unit<br>
	 * is managed but not its compilation. This should be a bitwise OR of the<br>
	 * CXTranslationUnit_XXX flags.<br>
	 * * \returns A new translation unit describing the parsed code and containing<br>
	 * any diagnostics produced by the compiler. If there is a failure from which<br>
	 * the compiler cannot recover, returns NULL.<br>
	 * Original signature : <code>CXTranslationUnit clang_parseTranslationUnit(CXIndex, const char*, const const char**, int, CXUnsavedFile*, unsigned, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1133</i>
	 */
	ClangLibrary.CXTranslationUnit clang_parseTranslationUnit(Pointer CIdx, String source_filename, byte[] command_line_args[], int num_command_line_args, CXUnsavedFile unsaved_files, int num_unsaved_files, int options);
	/**
	 * \brief Returns the set of flags that is suitable for saving a translation<br>
	 * unit.<br>
	 * * The set of flags returned provide options for<br>
	 * \c clang_saveTranslationUnit() by default. The returned flag<br>
	 * set contains an unspecified set of options that save translation units with<br>
	 * the most commonly-requested data.<br>
	 * Original signature : <code>int clang_defaultSaveOptions(CXTranslationUnit)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1164</i>
	 */
	int clang_defaultSaveOptions(ClangLibrary.CXTranslationUnit TU);
	/**
	 * \brief Saves a translation unit into a serialized representation of<br>
	 * that translation unit on disk.<br>
	 * * Any translation unit that was parsed without error can be saved<br>
	 * into a file. The translation unit can then be deserialized into a<br>
	 * new \c CXTranslationUnit with \c clang_createTranslationUnit() or,<br>
	 * if it is an incomplete translation unit that corresponds to a<br>
	 * header, used as a precompiled header when parsing other translation<br>
	 * units.<br>
	 * * \param TU The translation unit to save.<br>
	 * * \param FileName The file to which the translation unit will be saved.<br>
	 * * \param options A bitmask of options that affects how the translation unit<br>
	 * is saved. This should be a bitwise OR of the<br>
	 * CXSaveTranslationUnit_XXX flags.<br>
	 * * \returns A value that will match one of the enumerators of the CXSaveError<br>
	 * enumeration. Zero (CXSaveError_None) indicates that the translation unit was <br>
	 * saved successfully, while a non-zero value indicates that a problem occurred.<br>
	 * Original signature : <code>int clang_saveTranslationUnit(CXTranslationUnit, const char*, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1224</i><br>
	 * @deprecated use the safer methods {@link #clang_saveTranslationUnit(clang.ClangLibrary.CXTranslationUnit, java.lang.String, int)} and {@link #clang_saveTranslationUnit(clang.ClangLibrary.CXTranslationUnit, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated
	int clang_saveTranslationUnit(ClangLibrary.CXTranslationUnit TU, Pointer FileName, int options);
	/**
	 * \brief Saves a translation unit into a serialized representation of<br>
	 * that translation unit on disk.<br>
	 * * Any translation unit that was parsed without error can be saved<br>
	 * into a file. The translation unit can then be deserialized into a<br>
	 * new \c CXTranslationUnit with \c clang_createTranslationUnit() or,<br>
	 * if it is an incomplete translation unit that corresponds to a<br>
	 * header, used as a precompiled header when parsing other translation<br>
	 * units.<br>
	 * * \param TU The translation unit to save.<br>
	 * * \param FileName The file to which the translation unit will be saved.<br>
	 * * \param options A bitmask of options that affects how the translation unit<br>
	 * is saved. This should be a bitwise OR of the<br>
	 * CXSaveTranslationUnit_XXX flags.<br>
	 * * \returns A value that will match one of the enumerators of the CXSaveError<br>
	 * enumeration. Zero (CXSaveError_None) indicates that the translation unit was <br>
	 * saved successfully, while a non-zero value indicates that a problem occurred.<br>
	 * Original signature : <code>int clang_saveTranslationUnit(CXTranslationUnit, const char*, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1224</i>
	 */
	int clang_saveTranslationUnit(ClangLibrary.CXTranslationUnit TU, String FileName, int options);
	/**
	 * \brief Destroy the specified CXTranslationUnit object.<br>
	 * Original signature : <code>void clang_disposeTranslationUnit(CXTranslationUnit)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1231</i>
	 */
	void clang_disposeTranslationUnit(ClangLibrary.CXTranslationUnit CXTranslationUnit1);
	/**
	 * \brief Returns the set of flags that is suitable for reparsing a translation<br>
	 * unit.<br>
	 * * The set of flags returned provide options for<br>
	 * \c clang_reparseTranslationUnit() by default. The returned flag<br>
	 * set contains an unspecified set of optimizations geared toward common uses<br>
	 * of reparsing. The set of optimizations enabled may change from one version <br>
	 * to the next.<br>
	 * Original signature : <code>int clang_defaultReparseOptions(CXTranslationUnit)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1257</i>
	 */
	int clang_defaultReparseOptions(ClangLibrary.CXTranslationUnit TU);
	/**
	 * \brief Reparse the source files that produced this translation unit.<br>
	 * * This routine can be used to re-parse the source files that originally<br>
	 * created the given translation unit, for example because those source files<br>
	 * have changed (either on disk or as passed via \p unsaved_files). The<br>
	 * source code will be reparsed with the same command-line options as it<br>
	 * was originally parsed. <br>
	 * * Reparsing a translation unit invalidates all cursors and source locations<br>
	 * that refer into that translation unit. This makes reparsing a translation<br>
	 * unit semantically equivalent to destroying the translation unit and then<br>
	 * creating a new translation unit with the same command-line arguments.<br>
	 * However, it may be more efficient to reparse a translation <br>
	 * unit using this routine.<br>
	 * * \param TU The translation unit whose contents will be re-parsed. The<br>
	 * translation unit must originally have been built with <br>
	 * \c clang_createTranslationUnitFromSourceFile().<br>
	 * * \param num_unsaved_files The number of unsaved file entries in \p<br>
	 * unsaved_files.<br>
	 * * \param unsaved_files The files that have not yet been saved to disk<br>
	 * but may be required for parsing, including the contents of<br>
	 * those files.  The contents and name of these files (as specified by<br>
	 * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
	 * guarantee their validity until the call to this function returns.<br>
	 * <br>
	 * \param options A bitset of options composed of the flags in CXReparse_Flags.<br>
	 * The function \c clang_defaultReparseOptions() produces a default set of<br>
	 * options recommended for most uses, based on the translation unit.<br>
	 * * \returns 0 if the sources could be reparsed. A non-zero value will be<br>
	 * returned if reparsing was impossible, such that the translation unit is<br>
	 * invalid. In such cases, the only valid call for \p TU is <br>
	 * \c clang_disposeTranslationUnit(TU).<br>
	 * Original signature : <code>int clang_reparseTranslationUnit(CXTranslationUnit, unsigned, CXUnsavedFile*, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1297</i>
	 */
	int clang_reparseTranslationUnit(ClangLibrary.CXTranslationUnit TU, int num_unsaved_files, CXUnsavedFile unsaved_files, int options);
	/**
	 * Original signature : <code>char* clang_getTUResourceUsageName(CXTUResourceUsageKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1333</i>
	 */
	String clang_getTUResourceUsageName(int kind);
	/**
	 * \brief Return the memory usage of a translation unit.  This object<br>
	 *  should be released with clang_disposeCXTUResourceUsage().<br>
	 * Original signature : <code>CXTUResourceUsage clang_getCXTUResourceUsage(CXTranslationUnit)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1363</i>
	 */
	clang.CXTUResourceUsage.ByValue clang_getCXTUResourceUsage(ClangLibrary.CXTranslationUnit TU);
	/**
	 * Original signature : <code>void clang_disposeCXTUResourceUsage(CXTUResourceUsage)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:1365</i>
	 */
	void clang_disposeCXTUResourceUsage(clang.CXTUResourceUsage.ByValue usage);
	/**
	 * \brief Retrieve the NULL cursor, which represents no entity.<br>
	 * Original signature : <code>CXCursor clang_getNullCursor()</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2071</i>
	 */
	CXCursor.ByValue clang_getNullCursor();
	/**
	 * \brief Retrieve the cursor that represents the given translation unit.<br>
	 * * The translation unit cursor can be used to start traversing the<br>
	 * various declarations within the given translation unit.<br>
	 * Original signature : <code>CXCursor clang_getTranslationUnitCursor(CXTranslationUnit)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2079</i>
	 */
	CXCursor.ByValue clang_getTranslationUnitCursor(ClangLibrary.CXTranslationUnit CXTranslationUnit1);
	/**
	 * \brief Determine whether two cursors are equivalent.<br>
	 * Original signature : <code>int clang_equalCursors(CXCursor, CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2084</i>
	 */
	int clang_equalCursors(CXCursor.ByValue CXCursor1, CXCursor.ByValue CXCursor2);
	/**
	 * \brief Returns non-zero if \p cursor is null.<br>
	 * Original signature : <code>int clang_Cursor_isNull(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2089</i>
	 */
	int clang_Cursor_isNull(CXCursor.ByValue cursor);
	/**
	 * \brief Compute a hash value for the given cursor.<br>
	 * Original signature : <code>int clang_hashCursor(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2094</i>
	 */
	int clang_hashCursor(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Retrieve the kind of the given cursor.<br>
	 * Original signature : <code>CXCursorKind clang_getCursorKind(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2099</i>
	 */
	int clang_getCursorKind(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Determine whether the given cursor kind represents a declaration.<br>
	 * Original signature : <code>int clang_isDeclaration(CXCursorKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2104</i>
	 */
	int clang_isDeclaration(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents a simple<br>
	 * reference.<br>
	 * * Note that other kinds of cursors (such as expressions) can also refer to<br>
	 * other cursors. Use clang_getCursorReferenced() to determine whether a<br>
	 * particular cursor refers to another entity.<br>
	 * Original signature : <code>int clang_isReference(CXCursorKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2114</i>
	 */
	int clang_isReference(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents an expression.<br>
	 * Original signature : <code>int clang_isExpression(CXCursorKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2119</i>
	 */
	int clang_isExpression(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents a statement.<br>
	 * Original signature : <code>int clang_isStatement(CXCursorKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2124</i>
	 */
	int clang_isStatement(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents an attribute.<br>
	 * Original signature : <code>int clang_isAttribute(CXCursorKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2129</i>
	 */
	int clang_isAttribute(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents an invalid<br>
	 * cursor.<br>
	 * Original signature : <code>int clang_isInvalid(CXCursorKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2135</i>
	 */
	int clang_isInvalid(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents a translation<br>
	 * unit.<br>
	 * Original signature : <code>int clang_isTranslationUnit(CXCursorKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2141</i>
	 */
	int clang_isTranslationUnit(int arg1);
	/**
	 * \brief Determine whether the given cursor represents a preprocessing<br>
	 * element, such as a preprocessor directive or macro instantiation.<br>
	 * Original signature : <code>int clang_isPreprocessing(CXCursorKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2147</i>
	 */
	int clang_isPreprocessing(int arg1);
	/**
	 * \brief Determine whether the given cursor represents a currently<br>
	 *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).<br>
	 * Original signature : <code>int clang_isUnexposed(CXCursorKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2153</i>
	 */
	int clang_isUnexposed(int arg1);
	/**
	 * \brief Determine the linkage of the entity referred to by a given cursor.<br>
	 * Original signature : <code>CXLinkageKind clang_getCursorLinkage(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2179</i>
	 */
	int clang_getCursorLinkage(CXCursor.ByValue cursor);
	/**
	 * \brief Determine the availability of the entity that this cursor refers to,<br>
	 * taking the current target platform into account.<br>
	 * * \param cursor The cursor to query.<br>
	 * * \returns The availability of the cursor.<br>
	 * Original signature : <code>CXAvailabilityKind clang_getCursorAvailability(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2189</i>
	 */
	int clang_getCursorAvailability(CXCursor.ByValue cursor);
	/**
	 * \brief Determine the availability of the entity that this cursor refers to<br>
	 * on any platforms for which availability information is known.<br>
	 * * \param cursor The cursor to query.<br>
	 * * \param always_deprecated If non-NULL, will be set to indicate whether the <br>
	 * entity is deprecated on all platforms.<br>
	 * * \param deprecated_message If non-NULL, will be set to the message text <br>
	 * provided along with the unconditional deprecation of this entity. The client<br>
	 * is responsible for deallocating this string.<br>
	 * * \param always_unavailable If non-NULL, will be set to indicate whether the<br>
	 * entity is unavailable on all platforms.<br>
	 * * \param unavailable_message If non-NULL, will be set to the message text<br>
	 * provided along with the unconditional unavailability of this entity. The <br>
	 * client is responsible for deallocating this string.<br>
	 * * \param availability If non-NULL, an array of CXPlatformAvailability instances<br>
	 * that will be populated with platform availability information, up to either<br>
	 * the number of platforms for which availability information is available (as<br>
	 * returned by this function) or \c availability_size, whichever is smaller.<br>
	 * * \param availability_size The number of elements available in the <br>
	 * \c availability array.<br>
	 * * \returns The number of platforms (N) for which availability information is<br>
	 * available (which is unrelated to \c availability_size).<br>
	 * * Note that the client is responsible for calling <br>
	 * \c clang_disposeCXPlatformAvailability to free each of the <br>
	 * platform-availability structures returned. There are <br>
	 * \c min(N, availability_size) such structures.<br>
	 * Original signature : <code>int clang_getCursorPlatformAvailability(CXCursor, int*, CXString*, int*, CXString*, CXPlatformAvailability*, int)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2265</i><br>
	 * @deprecated use the safer methods {@link #clang_getCursorPlatformAvailability(clang.CXCursor.ByValue, java.nio.IntBuffer, clang.CXString, java.nio.IntBuffer, clang.CXString, clang.CXPlatformAvailability, int)} and {@link #clang_getCursorPlatformAvailability(clang.CXCursor.ByValue, com.sun.jna.ptr.IntByReference, clang.CXString, com.sun.jna.ptr.IntByReference, clang.CXString, clang.CXPlatformAvailability, int)} instead
	 */
	@Deprecated
	int clang_getCursorPlatformAvailability(CXCursor.ByValue cursor, IntByReference always_deprecated, CXString deprecated_message, IntByReference always_unavailable, CXString unavailable_message, CXPlatformAvailability availability, int availability_size);
	/**
	 * \brief Determine the availability of the entity that this cursor refers to<br>
	 * on any platforms for which availability information is known.<br>
	 * * \param cursor The cursor to query.<br>
	 * * \param always_deprecated If non-NULL, will be set to indicate whether the <br>
	 * entity is deprecated on all platforms.<br>
	 * * \param deprecated_message If non-NULL, will be set to the message text <br>
	 * provided along with the unconditional deprecation of this entity. The client<br>
	 * is responsible for deallocating this string.<br>
	 * * \param always_unavailable If non-NULL, will be set to indicate whether the<br>
	 * entity is unavailable on all platforms.<br>
	 * * \param unavailable_message If non-NULL, will be set to the message text<br>
	 * provided along with the unconditional unavailability of this entity. The <br>
	 * client is responsible for deallocating this string.<br>
	 * * \param availability If non-NULL, an array of CXPlatformAvailability instances<br>
	 * that will be populated with platform availability information, up to either<br>
	 * the number of platforms for which availability information is available (as<br>
	 * returned by this function) or \c availability_size, whichever is smaller.<br>
	 * * \param availability_size The number of elements available in the <br>
	 * \c availability array.<br>
	 * * \returns The number of platforms (N) for which availability information is<br>
	 * available (which is unrelated to \c availability_size).<br>
	 * * Note that the client is responsible for calling <br>
	 * \c clang_disposeCXPlatformAvailability to free each of the <br>
	 * platform-availability structures returned. There are <br>
	 * \c min(N, availability_size) such structures.<br>
	 * Original signature : <code>int clang_getCursorPlatformAvailability(CXCursor, int*, CXString*, int*, CXString*, CXPlatformAvailability*, int)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2265</i>
	 */
	int clang_getCursorPlatformAvailability(CXCursor.ByValue cursor, IntBuffer always_deprecated, CXString deprecated_message, IntBuffer always_unavailable, CXString unavailable_message, CXPlatformAvailability availability, int availability_size);
	/**
	 * \brief Free the memory associated with a \c CXPlatformAvailability structure.<br>
	 * Original signature : <code>void clang_disposeCXPlatformAvailability(CXPlatformAvailability*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2277</i>
	 */
	void clang_disposeCXPlatformAvailability(CXPlatformAvailability availability);
	/**
	 * \brief Determine the "language" of the entity referred to by a given cursor.<br>
	 * Original signature : <code>CXLanguageKind clang_getCursorLanguage(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2293</i>
	 */
	int clang_getCursorLanguage(CXCursor.ByValue cursor);
	/**
	 * \brief Returns the translation unit that a cursor originated from.<br>
	 * Original signature : <code>CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2298</i>
	 */
	ClangLibrary.CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Creates an empty CXCursorSet.<br>
	 * Original signature : <code>CXCursorSet clang_createCXCursorSet()</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2309</i>
	 */
	ClangLibrary.CXCursorSet clang_createCXCursorSet();
	/**
	 * \brief Disposes a CXCursorSet and releases its associated memory.<br>
	 * Original signature : <code>void clang_disposeCXCursorSet(CXCursorSet)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2314</i>
	 */
	void clang_disposeCXCursorSet(ClangLibrary.CXCursorSet cset);
	/**
	 * \brief Queries a CXCursorSet to see if it contains a specific CXCursor.<br>
	 * * \returns non-zero if the set contains the specified cursor.<br>
	 * Original signature : <code>int clang_CXCursorSet_contains(CXCursorSet, CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2321</i>
	 */
	int clang_CXCursorSet_contains(ClangLibrary.CXCursorSet cset, CXCursor.ByValue cursor);
	/**
	 * \brief Inserts a CXCursor into a CXCursorSet.<br>
	 * * \returns zero if the CXCursor was already in the set, and non-zero otherwise.<br>
	 * Original signature : <code>int clang_CXCursorSet_insert(CXCursorSet, CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2329</i>
	 */
	int clang_CXCursorSet_insert(ClangLibrary.CXCursorSet cset, CXCursor.ByValue cursor);
	/**
	 * \brief Determine the semantic parent of the given cursor.<br>
	 * * The semantic parent of a cursor is the cursor that semantically contains<br>
	 * the given \p cursor. For many declarations, the lexical and semantic parents<br>
	 * are equivalent (the lexical parent is returned by <br>
	 * \c clang_getCursorLexicalParent()). They diverge when declarations or<br>
	 * definitions are provided out-of-line. For example:<br>
	 * * \code<br>
	 * class C {<br>
	 *  void f();<br>
	 * };<br>
	 * * void C::f() { }<br>
	 * \endcode<br>
	 * * In the out-of-line definition of \c C::f, the semantic parent is the <br>
	 * the class \c C, of which this function is a member. The lexical parent is<br>
	 * the place where the declaration actually occurs in the source code; in this<br>
	 * case, the definition occurs in the translation unit. In general, the <br>
	 * lexical parent for a given entity can change without affecting the semantics<br>
	 * of the program, and the lexical parent of different declarations of the<br>
	 * same entity may be different. Changing the semantic parent of a declaration,<br>
	 * on the other hand, can have a major impact on semantics, and redeclarations<br>
	 * of a particular entity should all have the same semantic context.<br>
	 * * In the example above, both declarations of \c C::f have \c C as their<br>
	 * semantic context, while the lexical context of the first \c C::f is \c C<br>
	 * and the lexical context of the second \c C::f is the translation unit.<br>
	 * * For global declarations, the semantic parent is the translation unit.<br>
	 * Original signature : <code>CXCursor clang_getCursorSemanticParent(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2365</i>
	 */
	CXCursor.ByValue clang_getCursorSemanticParent(CXCursor.ByValue cursor);
	/**
	 * \brief Determine the lexical parent of the given cursor.<br>
	 * * The lexical parent of a cursor is the cursor in which the given \p cursor<br>
	 * was actually written. For many declarations, the lexical and semantic parents<br>
	 * are equivalent (the semantic parent is returned by <br>
	 * \c clang_getCursorSemanticParent()). They diverge when declarations or<br>
	 * definitions are provided out-of-line. For example:<br>
	 * * \code<br>
	 * class C {<br>
	 *  void f();<br>
	 * };<br>
	 * * void C::f() { }<br>
	 * \endcode<br>
	 * * In the out-of-line definition of \c C::f, the semantic parent is the <br>
	 * the class \c C, of which this function is a member. The lexical parent is<br>
	 * the place where the declaration actually occurs in the source code; in this<br>
	 * case, the definition occurs in the translation unit. In general, the <br>
	 * lexical parent for a given entity can change without affecting the semantics<br>
	 * of the program, and the lexical parent of different declarations of the<br>
	 * same entity may be different. Changing the semantic parent of a declaration,<br>
	 * on the other hand, can have a major impact on semantics, and redeclarations<br>
	 * of a particular entity should all have the same semantic context.<br>
	 * * In the example above, both declarations of \c C::f have \c C as their<br>
	 * semantic context, while the lexical context of the first \c C::f is \c C<br>
	 * and the lexical context of the second \c C::f is the translation unit.<br>
	 * * For declarations written in the global scope, the lexical parent is<br>
	 * the translation unit.<br>
	 * Original signature : <code>CXCursor clang_getCursorLexicalParent(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2401</i>
	 */
	CXCursor.ByValue clang_getCursorLexicalParent(CXCursor.ByValue cursor);
	/**
	 * \brief Determine the set of methods that are overridden by the given<br>
	 * method.<br>
	 * * In both Objective-C and C++, a method (aka virtual member function,<br>
	 * in C++) can override a virtual method in a base class. For<br>
	 * Objective-C, a method is said to override any method in the class's<br>
	 * base class, its protocols, or its categories' protocols, that has the same<br>
	 * selector and is of the same kind (class or instance).<br>
	 * If no such method exists, the search continues to the class's superclass,<br>
	 * its protocols, and its categories, and so on. A method from an Objective-C<br>
	 * implementation is considered to override the same methods as its<br>
	 * corresponding method in the interface.<br>
	 * * For C++, a virtual member function overrides any virtual member<br>
	 * function with the same signature that occurs in its base<br>
	 * classes. With multiple inheritance, a virtual member function can<br>
	 * override several virtual member functions coming from different<br>
	 * base classes.<br>
	 * * In all cases, this function determines the immediate overridden<br>
	 * method, rather than all of the overridden methods. For example, if<br>
	 * a method is originally declared in a class A, then overridden in B<br>
	 * (which in inherits from A) and also in C (which inherited from B),<br>
	 * then the only overridden method returned from this function when<br>
	 * invoked on C's method will be B's method. The client may then<br>
	 * invoke this function again, given the previously-found overridden<br>
	 * methods, to map out the complete method-override set.<br>
	 * * \param cursor A cursor representing an Objective-C or C++<br>
	 * method. This routine will compute the set of methods that this<br>
	 * method overrides.<br>
	 * <br>
	 * \param overridden A pointer whose pointee will be replaced with a<br>
	 * pointer to an array of cursors, representing the set of overridden<br>
	 * methods. If there are no overridden methods, the pointee will be<br>
	 * set to NULL. The pointee must be freed via a call to <br>
	 * \c clang_disposeOverriddenCursors().<br>
	 * * \param num_overridden A pointer to the number of overridden<br>
	 * functions, will be set to the number of overridden functions in the<br>
	 * array pointed to by \p overridden.<br>
	 * Original signature : <code>void clang_getOverriddenCursors(CXCursor, CXCursor**, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2446</i><br>
	 * @deprecated use the safer methods {@link #clang_getOverriddenCursors(clang.CXCursor.ByValue, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer)} and {@link #clang_getOverriddenCursors(clang.CXCursor.ByValue, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	void clang_getOverriddenCursors(CXCursor.ByValue cursor, PointerByReference overridden, IntByReference num_overridden);
	/**
	 * \brief Determine the set of methods that are overridden by the given<br>
	 * method.<br>
	 * * In both Objective-C and C++, a method (aka virtual member function,<br>
	 * in C++) can override a virtual method in a base class. For<br>
	 * Objective-C, a method is said to override any method in the class's<br>
	 * base class, its protocols, or its categories' protocols, that has the same<br>
	 * selector and is of the same kind (class or instance).<br>
	 * If no such method exists, the search continues to the class's superclass,<br>
	 * its protocols, and its categories, and so on. A method from an Objective-C<br>
	 * implementation is considered to override the same methods as its<br>
	 * corresponding method in the interface.<br>
	 * * For C++, a virtual member function overrides any virtual member<br>
	 * function with the same signature that occurs in its base<br>
	 * classes. With multiple inheritance, a virtual member function can<br>
	 * override several virtual member functions coming from different<br>
	 * base classes.<br>
	 * * In all cases, this function determines the immediate overridden<br>
	 * method, rather than all of the overridden methods. For example, if<br>
	 * a method is originally declared in a class A, then overridden in B<br>
	 * (which in inherits from A) and also in C (which inherited from B),<br>
	 * then the only overridden method returned from this function when<br>
	 * invoked on C's method will be B's method. The client may then<br>
	 * invoke this function again, given the previously-found overridden<br>
	 * methods, to map out the complete method-override set.<br>
	 * * \param cursor A cursor representing an Objective-C or C++<br>
	 * method. This routine will compute the set of methods that this<br>
	 * method overrides.<br>
	 * <br>
	 * \param overridden A pointer whose pointee will be replaced with a<br>
	 * pointer to an array of cursors, representing the set of overridden<br>
	 * methods. If there are no overridden methods, the pointee will be<br>
	 * set to NULL. The pointee must be freed via a call to <br>
	 * \c clang_disposeOverriddenCursors().<br>
	 * * \param num_overridden A pointer to the number of overridden<br>
	 * functions, will be set to the number of overridden functions in the<br>
	 * array pointed to by \p overridden.<br>
	 * Original signature : <code>void clang_getOverriddenCursors(CXCursor, CXCursor**, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2446</i>
	 */
	void clang_getOverriddenCursors(CXCursor.ByValue cursor, PointerByReference overridden, IntBuffer num_overridden);
	/**
	 * \brief Free the set of overridden cursors returned by \c<br>
	 * clang_getOverriddenCursors().<br>
	 * Original signature : <code>void clang_disposeOverriddenCursors(CXCursor*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2454</i>
	 */
	void clang_disposeOverriddenCursors(CXCursor overridden);
	/**
	 * \brief Retrieve the file that is included by the given inclusion directive<br>
	 * cursor.<br>
	 * Original signature : <code>CXFile clang_getIncludedFile(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2460</i>
	 */
	Pointer clang_getIncludedFile(CXCursor.ByValue cursor);
	/**
	 * \brief Map a source location to the cursor that describes the entity at that<br>
	 * location in the source code.<br>
	 * * clang_getCursor() maps an arbitrary source location within a translation<br>
	 * unit down to the most specific cursor that describes the entity at that<br>
	 * location. For example, given an expression \c x + y, invoking<br>
	 * clang_getCursor() with a source location pointing to "x" will return the<br>
	 * cursor for "x"; similarly for "y". If the cursor points anywhere between<br>
	 * "x" or "y" (e.g., on the + or the whitespace around it), clang_getCursor()<br>
	 * will return a cursor referring to the "+" expression.<br>
	 * * \returns a cursor representing the entity at the given source location, or<br>
	 * a NULL cursor if no such entity can be found.<br>
	 * Original signature : <code>CXCursor clang_getCursor(CXTranslationUnit, CXSourceLocation)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2492</i>
	 */
	CXCursor.ByValue clang_getCursor(ClangLibrary.CXTranslationUnit CXTranslationUnit1, CXSourceLocation.ByValue CXSourceLocation1);
	/**
	 * \brief Retrieve the physical location of the source constructor referenced<br>
	 * by the given cursor.<br>
	 * * The location of a declaration is typically the location of the name of that<br>
	 * declaration, where the name of that declaration would occur if it is<br>
	 * unnamed, or some keyword that introduces that particular declaration.<br>
	 * The location of a reference is where that reference occurs within the<br>
	 * source code.<br>
	 * Original signature : <code>CXSourceLocation clang_getCursorLocation(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2504</i>
	 */
	CXSourceLocation.ByValue clang_getCursorLocation(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Retrieve the physical extent of the source construct referenced by<br>
	 * the given cursor.<br>
	 * * The extent of a cursor starts with the file/line/column pointing at the<br>
	 * first character within the source construct that the cursor refers to and<br>
	 * ends with the last character withinin that source construct. For a<br>
	 * declaration, the extent covers the declaration itself. For a reference,<br>
	 * the extent covers the location of the reference (e.g., where the referenced<br>
	 * entity was actually used).<br>
	 * Original signature : <code>CXSourceRange clang_getCursorExtent(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2517</i>
	 */
	CXSourceRange.ByValue clang_getCursorExtent(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Retrieve the type of a CXCursor (if any).<br>
	 * Original signature : <code>CXType clang_getCursorType(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2623</i>
	 */
	clang.CXType.ByValue clang_getCursorType(CXCursor.ByValue C);
	/**
	 * \brief Retrieve the underlying type of a typedef declaration.<br>
	 * * If the cursor does not reference a typedef declaration, an invalid type is<br>
	 * returned.<br>
	 * Original signature : <code>CXType clang_getTypedefDeclUnderlyingType(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2631</i>
	 */
	clang.CXType.ByValue clang_getTypedefDeclUnderlyingType(CXCursor.ByValue C);
	/**
	 * \brief Retrieve the integer type of an enum declaration.<br>
	 * * If the cursor does not reference an enum declaration, an invalid type is<br>
	 * returned.<br>
	 * Original signature : <code>CXType clang_getEnumDeclIntegerType(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2639</i>
	 */
	clang.CXType.ByValue clang_getEnumDeclIntegerType(CXCursor.ByValue C);
	/**
	 * \brief Retrieve the integer value of an enum constant declaration as a signed<br>
	 *  long long.<br>
	 * * If the cursor does not reference an enum constant declaration, LLONG_MIN is returned.<br>
	 * Since this is also potentially a valid constant value, the kind of the cursor<br>
	 * must be verified before calling this function.<br>
	 * Original signature : <code>long long clang_getEnumConstantDeclValue(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2649</i>
	 */
	long clang_getEnumConstantDeclValue(CXCursor.ByValue C);
	/**
	 * \brief Retrieve the integer value of an enum constant declaration as an unsigned<br>
	 *  long long.<br>
	 * * If the cursor does not reference an enum constant declaration, ULLONG_MAX is returned.<br>
	 * Since this is also potentially a valid constant value, the kind of the cursor<br>
	 * must be verified before calling this function.<br>
	 * Original signature : <code>long long clang_getEnumConstantDeclUnsignedValue(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2659</i>
	 */
	long clang_getEnumConstantDeclUnsignedValue(CXCursor.ByValue C);
	/**
	 * \brief Retrieve the bit width of a bit field declaration as an integer.<br>
	 * * If a cursor that is not a bit field declaration is passed in, -1 is returned.<br>
	 * Original signature : <code>int clang_getFieldDeclBitWidth(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2666</i>
	 */
	int clang_getFieldDeclBitWidth(CXCursor.ByValue C);
	/**
	 * \brief Retrieve the number of non-variadic arguments associated with a given<br>
	 * cursor.<br>
	 * * If a cursor that is not a function or method is passed in, -1 is returned.<br>
	 * Original signature : <code>int clang_Cursor_getNumArguments(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2674</i>
	 */
	int clang_Cursor_getNumArguments(CXCursor.ByValue C);
	/**
	 * \brief Retrieve the argument cursor of a function or method.<br>
	 * * If a cursor that is not a function or method is passed in or the index<br>
	 * exceeds the number of arguments, an invalid cursor is returned.<br>
	 * Original signature : <code>CXCursor clang_Cursor_getArgument(CXCursor, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2682</i>
	 */
	CXCursor.ByValue clang_Cursor_getArgument(CXCursor.ByValue C, int i);
	/**
	 * \brief Determine whether two CXTypes represent the same type.<br>
	 * * \returns non-zero if the CXTypes represent the same type and<br>
	 *          zero otherwise.<br>
	 * Original signature : <code>int clang_equalTypes(CXType, CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2690</i>
	 */
	int clang_equalTypes(clang.CXType.ByValue A, clang.CXType.ByValue B);
	/**
	 * \brief Return the canonical type for a CXType.<br>
	 * * Clang's type system explicitly models typedefs and all the ways<br>
	 * a specific type can be represented.  The canonical type is the underlying<br>
	 * type with all the "sugar" removed.  For example, if 'T' is a typedef<br>
	 * for 'int', the canonical type for 'T' would be 'int'.<br>
	 * Original signature : <code>CXType clang_getCanonicalType(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2700</i>
	 */
	clang.CXType.ByValue clang_getCanonicalType(clang.CXType.ByValue T);
	/**
	 * \brief Determine whether a CXType has the "const" qualifier set,<br>
	 * without looking through typedefs that may have added "const" at a<br>
	 * different level.<br>
	 * Original signature : <code>int clang_isConstQualifiedType(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2707</i>
	 */
	int clang_isConstQualifiedType(clang.CXType.ByValue T);
	/**
	 * \brief Determine whether a CXType has the "volatile" qualifier set,<br>
	 * without looking through typedefs that may have added "volatile" at<br>
	 * a different level.<br>
	 * Original signature : <code>int clang_isVolatileQualifiedType(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2714</i>
	 */
	int clang_isVolatileQualifiedType(clang.CXType.ByValue T);
	/**
	 * \brief Determine whether a CXType has the "restrict" qualifier set,<br>
	 * without looking through typedefs that may have added "restrict" at a<br>
	 * different level.<br>
	 * Original signature : <code>int clang_isRestrictQualifiedType(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2721</i>
	 */
	int clang_isRestrictQualifiedType(clang.CXType.ByValue T);
	/**
	 * \brief For pointer types, returns the type of the pointee.<br>
	 * Original signature : <code>CXType clang_getPointeeType(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2726</i>
	 */
	clang.CXType.ByValue clang_getPointeeType(clang.CXType.ByValue T);
	/**
	 * \brief Return the cursor for the declaration of the given type.<br>
	 * Original signature : <code>CXCursor clang_getTypeDeclaration(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2731</i>
	 */
	CXCursor.ByValue clang_getTypeDeclaration(clang.CXType.ByValue T);
	/**
	 * Returns the Objective-C type encoding for the specified declaration.<br>
	 * Original signature : <code>CXString clang_getDeclObjCTypeEncoding(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2736</i>
	 */
	CXString.ByValue clang_getDeclObjCTypeEncoding(CXCursor.ByValue C);
	/**
	 * \brief Retrieve the spelling of a given CXTypeKind.<br>
	 * Original signature : <code>CXString clang_getTypeKindSpelling(CXTypeKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2741</i>
	 */
	CXString.ByValue clang_getTypeKindSpelling(int K);
	/**
	 * \brief Retrieve the calling convention associated with a function type.<br>
	 * * If a non-function type is passed in, CXCallingConv_Invalid is returned.<br>
	 * Original signature : <code>CXCallingConv clang_getFunctionTypeCallingConv(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2748</i>
	 */
	int clang_getFunctionTypeCallingConv(clang.CXType.ByValue T);
	/**
	 * \brief Retrieve the result type associated with a function type.<br>
	 * * If a non-function type is passed in, an invalid type is returned.<br>
	 * Original signature : <code>CXType clang_getResultType(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2755</i>
	 */
	clang.CXType.ByValue clang_getResultType(clang.CXType.ByValue T);
	/**
	 * \brief Retrieve the number of non-variadic arguments associated with a<br>
	 * function type.<br>
	 * * If a non-function type is passed in, -1 is returned.<br>
	 * Original signature : <code>int clang_getNumArgTypes(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2763</i>
	 */
	int clang_getNumArgTypes(clang.CXType.ByValue T);
	/**
	 * \brief Retrieve the type of an argument of a function type.<br>
	 * * If a non-function type is passed in or the function does not have enough<br>
	 * parameters, an invalid type is returned.<br>
	 * Original signature : <code>CXType clang_getArgType(CXType, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2771</i>
	 */
	clang.CXType.ByValue clang_getArgType(clang.CXType.ByValue T, int i);
	/**
	 * \brief Return 1 if the CXType is a variadic function type, and 0 otherwise.<br>
	 * Original signature : <code>int clang_isFunctionTypeVariadic(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2776</i>
	 */
	int clang_isFunctionTypeVariadic(clang.CXType.ByValue T);
	/**
	 * \brief Retrieve the result type associated with a given cursor.<br>
	 * * This only returns a valid type if the cursor refers to a function or method.<br>
	 * Original signature : <code>CXType clang_getCursorResultType(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2783</i>
	 */
	clang.CXType.ByValue clang_getCursorResultType(CXCursor.ByValue C);
	/**
	 * \brief Return 1 if the CXType is a POD (plain old data) type, and 0<br>
	 *  otherwise.<br>
	 * Original signature : <code>int clang_isPODType(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2789</i>
	 */
	int clang_isPODType(clang.CXType.ByValue T);
	/**
	 * \brief Return the element type of an array, complex, or vector type.<br>
	 * * If a type is passed in that is not an array, complex, or vector type,<br>
	 * an invalid type is returned.<br>
	 * Original signature : <code>CXType clang_getElementType(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2797</i>
	 */
	clang.CXType.ByValue clang_getElementType(clang.CXType.ByValue T);
	/**
	 * \brief Return the number of elements of an array or vector type.<br>
	 * * If a type is passed in that is not an array or vector type,<br>
	 * -1 is returned.<br>
	 * Original signature : <code>long long clang_getNumElements(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2805</i>
	 */
	long clang_getNumElements(clang.CXType.ByValue T);
	/**
	 * \brief Return the element type of an array type.<br>
	 * * If a non-array type is passed in, an invalid type is returned.<br>
	 * Original signature : <code>CXType clang_getArrayElementType(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2812</i>
	 */
	clang.CXType.ByValue clang_getArrayElementType(clang.CXType.ByValue T);
	/**
	 * \brief Return the array size of a constant array.<br>
	 * * If a non-array type is passed in, -1 is returned.<br>
	 * Original signature : <code>long long clang_getArraySize(CXType)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2819</i>
	 */
	long clang_getArraySize(clang.CXType.ByValue T);
	/**
	 * \brief Returns 1 if the base class specified by the cursor with kind<br>
	 *   CX_CXXBaseSpecifier is virtual.<br>
	 * Original signature : <code>int clang_isVirtualBase(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2825</i>
	 */
	int clang_isVirtualBase(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Returns the access control level for the C++ base specifier<br>
	 * represented by a cursor with kind CXCursor_CXXBaseSpecifier or<br>
	 * CXCursor_AccessSpecifier.<br>
	 * Original signature : <code>CX_CXXAccessSpecifier clang_getCXXAccessSpecifier(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2843</i>
	 */
	int clang_getCXXAccessSpecifier(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Determine the number of overloaded declarations referenced by a <br>
	 * \c CXCursor_OverloadedDeclRef cursor.<br>
	 * * \param cursor The cursor whose overloaded declarations are being queried.<br>
	 * * \returns The number of overloaded declarations referenced by \c cursor. If it<br>
	 * is not a \c CXCursor_OverloadedDeclRef cursor, returns 0.<br>
	 * Original signature : <code>int clang_getNumOverloadedDecls(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2854</i>
	 */
	int clang_getNumOverloadedDecls(CXCursor.ByValue cursor);
	/**
	 * \brief Retrieve a cursor for one of the overloaded declarations referenced<br>
	 * by a \c CXCursor_OverloadedDeclRef cursor.<br>
	 * * \param cursor The cursor whose overloaded declarations are being queried.<br>
	 * * \param index The zero-based index into the set of overloaded declarations in<br>
	 * the cursor.<br>
	 * * \returns A cursor representing the declaration referenced by the given <br>
	 * \c cursor at the specified \c index. If the cursor does not have an <br>
	 * associated set of overloaded declarations, or if the index is out of bounds,<br>
	 * returns \c clang_getNullCursor();<br>
	 * Original signature : <code>CXCursor clang_getOverloadedDecl(CXCursor, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2870</i>
	 */
	CXCursor.ByValue clang_getOverloadedDecl(CXCursor.ByValue cursor, int index);
	/**
	 * \brief For cursors representing an iboutletcollection attribute,<br>
	 *  this function returns the collection element type.<br>
	 * Original signature : <code>CXType clang_getIBOutletCollectionType(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2889</i>
	 */
	clang.CXType.ByValue clang_getIBOutletCollectionType(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Visit the children of a particular cursor.<br>
	 * * This function visits all the direct children of the given cursor,<br>
	 * invoking the given \p visitor function with the cursors of each<br>
	 * visited child. The traversal may be recursive, if the visitor returns<br>
	 * \c CXChildVisit_Recurse. The traversal may also be ended prematurely, if<br>
	 * the visitor returns \c CXChildVisit_Break.<br>
	 * * \param parent the cursor whose child may be visited. All kinds of<br>
	 * cursors can be visited, including invalid cursors (which, by<br>
	 * definition, have no children).<br>
	 * * \param visitor the visitor function that will be invoked for each<br>
	 * child of \p parent.<br>
	 * * \param client_data pointer data supplied by the client, which will<br>
	 * be passed to the visitor each time it is invoked.<br>
	 * * \returns a non-zero value if the traversal was terminated<br>
	 * prematurely by the visitor returning \c CXChildVisit_Break.<br>
	 * Original signature : <code>int clang_visitChildren(CXCursor, CXCursorVisitor, CXClientData)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:2966</i>
	 */
	int clang_visitChildren(CXCursor.ByValue parent, ClangLibrary.CXCursorVisitor visitor, Pointer client_data);
	/**
	 * \brief Retrieve a Unified Symbol Resolution (USR) for the entity referenced<br>
	 * by the given cursor.<br>
	 * * A Unified Symbol Resolution (USR) is a string that identifies a particular<br>
	 * entity (function, class, variable, etc.) within a program. USRs can be<br>
	 * compared across translation units to determine, e.g., when references in<br>
	 * one translation refer to an entity defined in another translation unit.<br>
	 * Original signature : <code>CXString clang_getCursorUSR(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3017</i>
	 */
	CXString.ByValue clang_getCursorUSR(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Construct a USR for a specified Objective-C class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCClass(const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3022</i><br>
	 * @deprecated use the safer methods {@link #clang_constructUSR_ObjCClass(java.lang.String)} and {@link #clang_constructUSR_ObjCClass(com.sun.jna.Pointer)} instead
	 */
	@Deprecated
	CXString.ByValue clang_constructUSR_ObjCClass(Pointer class_name);
	/**
	 * \brief Construct a USR for a specified Objective-C class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCClass(const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3022</i>
	 */
	CXString.ByValue clang_constructUSR_ObjCClass(String class_name);
	/**
	 * \brief Construct a USR for a specified Objective-C category.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCCategory(const char*, const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3027</i><br>
	 * @deprecated use the safer methods {@link #clang_constructUSR_ObjCCategory(java.lang.String, java.lang.String)} and {@link #clang_constructUSR_ObjCCategory(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated
	CXString.ByValue clang_constructUSR_ObjCCategory(Pointer class_name, Pointer category_name);
	/**
	 * \brief Construct a USR for a specified Objective-C category.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCCategory(const char*, const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3027</i>
	 */
	CXString.ByValue clang_constructUSR_ObjCCategory(String class_name, String category_name);
	/**
	 * \brief Construct a USR for a specified Objective-C protocol.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCProtocol(const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3034</i><br>
	 * @deprecated use the safer methods {@link #clang_constructUSR_ObjCProtocol(java.lang.String)} and {@link #clang_constructUSR_ObjCProtocol(com.sun.jna.Pointer)} instead
	 */
	@Deprecated
	CXString.ByValue clang_constructUSR_ObjCProtocol(Pointer protocol_name);
	/**
	 * \brief Construct a USR for a specified Objective-C protocol.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCProtocol(const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3034</i>
	 */
	CXString.ByValue clang_constructUSR_ObjCProtocol(String protocol_name);
	/**
	 * \brief Construct a USR for a specified Objective-C instance variable and<br>
	 *   the USR for its containing class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCIvar(const char*, CXString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3042</i><br>
	 * @deprecated use the safer methods {@link #clang_constructUSR_ObjCIvar(java.lang.String, clang.CXString.ByValue)} and {@link #clang_constructUSR_ObjCIvar(com.sun.jna.Pointer, clang.CXString.ByValue)} instead
	 */
	@Deprecated
	CXString.ByValue clang_constructUSR_ObjCIvar(Pointer name, CXString.ByValue classUSR);
	/**
	 * \brief Construct a USR for a specified Objective-C instance variable and<br>
	 *   the USR for its containing class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCIvar(const char*, CXString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3042</i>
	 */
	CXString.ByValue clang_constructUSR_ObjCIvar(String name, CXString.ByValue classUSR);
	/**
	 * \brief Construct a USR for a specified Objective-C method and<br>
	 *   the USR for its containing class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCMethod(const char*, unsigned, CXString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3049</i><br>
	 * @deprecated use the safer methods {@link #clang_constructUSR_ObjCMethod(java.lang.String, int, clang.CXString.ByValue)} and {@link #clang_constructUSR_ObjCMethod(com.sun.jna.Pointer, int, clang.CXString.ByValue)} instead
	 */
	@Deprecated
	CXString.ByValue clang_constructUSR_ObjCMethod(Pointer name, int isInstanceMethod, CXString.ByValue classUSR);
	/**
	 * \brief Construct a USR for a specified Objective-C method and<br>
	 *   the USR for its containing class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCMethod(const char*, unsigned, CXString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3049</i>
	 */
	CXString.ByValue clang_constructUSR_ObjCMethod(String name, int isInstanceMethod, CXString.ByValue classUSR);
	/**
	 * \brief Construct a USR for a specified Objective-C property and the USR<br>
	 *  for its containing class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCProperty(const char*, CXString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3057</i><br>
	 * @deprecated use the safer methods {@link #clang_constructUSR_ObjCProperty(java.lang.String, clang.CXString.ByValue)} and {@link #clang_constructUSR_ObjCProperty(com.sun.jna.Pointer, clang.CXString.ByValue)} instead
	 */
	@Deprecated
	CXString.ByValue clang_constructUSR_ObjCProperty(Pointer property, CXString.ByValue classUSR);
	/**
	 * \brief Construct a USR for a specified Objective-C property and the USR<br>
	 *  for its containing class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCProperty(const char*, CXString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3057</i>
	 */
	CXString.ByValue clang_constructUSR_ObjCProperty(String property, CXString.ByValue classUSR);
	/**
	 * \brief Retrieve a name for the entity referenced by this cursor.<br>
	 * Original signature : <code>CXString clang_getCursorSpelling(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3063</i>
	 */
	CXString.ByValue clang_getCursorSpelling(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Retrieve a range for a piece that forms the cursors spelling name.<br>
	 * Most of the times there is only one range for the complete spelling but for<br>
	 * objc methods and objc message expressions, there are multiple pieces for each<br>
	 * selector identifier.<br>
	 * <br>
	 * \param pieceIndex the index of the spelling name piece. If this is greater<br>
	 * than the actual number of pieces, it will return a NULL (invalid) range.<br>
	 *  <br>
	 * \param options Reserved.<br>
	 * Original signature : <code>CXSourceRange clang_Cursor_getSpellingNameRange(CXCursor, unsigned, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3076</i>
	 */
	CXSourceRange.ByValue clang_Cursor_getSpellingNameRange(CXCursor.ByValue CXCursor1, int pieceIndex, int options);
	/**
	 * \brief Retrieve the display name for the entity referenced by this cursor.<br>
	 * * The display name contains extra information that helps identify the cursor,<br>
	 * such as the parameters of a function or template or the arguments of a <br>
	 * class template specialization.<br>
	 * Original signature : <code>CXString clang_getCursorDisplayName(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3087</i>
	 */
	CXString.ByValue clang_getCursorDisplayName(CXCursor.ByValue CXCursor1);
	/**
	 * \brief For a cursor that is a reference, retrieve a cursor representing the<br>
	 * entity that it references.<br>
	 * * Reference cursors refer to other entities in the AST. For example, an<br>
	 * Objective-C superclass reference cursor refers to an Objective-C class.<br>
	 * This function produces the cursor for the Objective-C class from the<br>
	 * cursor for the superclass reference. If the input cursor is a declaration or<br>
	 * definition, it returns that declaration or definition unchanged.<br>
	 * Otherwise, returns the NULL cursor.<br>
	 * Original signature : <code>CXCursor clang_getCursorReferenced(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3099</i>
	 */
	CXCursor.ByValue clang_getCursorReferenced(CXCursor.ByValue CXCursor1);
	/**
	 * \brief For a cursor that is either a reference to or a declaration<br>
	 *  of some entity, retrieve a cursor that describes the definition of<br>
	 *  that entity.<br>
	 * *  Some entities can be declared multiple times within a translation<br>
	 *  unit, but only one of those declarations can also be a<br>
	 *  definition. For example, given:<br>
	 * *  \code<br>
	 *  int f(int, int);<br>
	 *  int g(int x, int y) { return f(x, y); }<br>
	 *  int f(int a, int b) { return a + b; }<br>
	 *  int f(int, int);<br>
	 *  \endcode<br>
	 * *  there are three declarations of the function "f", but only the<br>
	 *  second one is a definition. The clang_getCursorDefinition()<br>
	 *  function will take any cursor pointing to a declaration of "f"<br>
	 *  (the first or fourth lines of the example) or a cursor referenced<br>
	 *  that uses "f" (the call to "f' inside "g") and will return a<br>
	 *  declaration cursor pointing to the definition (the second "f"<br>
	 *  declaration).<br>
	 * *  If given a cursor for which there is no corresponding definition,<br>
	 *  e.g., because there is no definition of that entity within this<br>
	 *  translation unit, returns a NULL cursor.<br>
	 * Original signature : <code>CXCursor clang_getCursorDefinition(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3129</i>
	 */
	CXCursor.ByValue clang_getCursorDefinition(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Determine whether the declaration pointed to by this cursor<br>
	 * is also a definition of that entity.<br>
	 * Original signature : <code>int clang_isCursorDefinition(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3135</i>
	 */
	int clang_isCursorDefinition(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Retrieve the canonical cursor corresponding to the given cursor.<br>
	 * * In the C family of languages, many kinds of entities can be declared several<br>
	 * times within a single translation unit. For example, a structure type can<br>
	 * be forward-declared (possibly multiple times) and later defined:<br>
	 * * \code<br>
	 * struct X;<br>
	 * struct X;<br>
	 * struct X {<br>
	 *   int member;<br>
	 * };<br>
	 * \endcode<br>
	 * * The declarations and the definition of \c X are represented by three <br>
	 * different cursors, all of which are declarations of the same underlying <br>
	 * entity. One of these cursor is considered the "canonical" cursor, which<br>
	 * is effectively the representative for the underlying entity. One can <br>
	 * determine if two cursors are declarations of the same underlying entity by<br>
	 * comparing their canonical cursors.<br>
	 * * \returns The canonical cursor for the entity referred to by the given cursor.<br>
	 * Original signature : <code>CXCursor clang_getCanonicalCursor(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3161</i>
	 */
	CXCursor.ByValue clang_getCanonicalCursor(CXCursor.ByValue CXCursor1);
	/**
	 * \brief If the cursor points to a selector identifier in a objc method or<br>
	 * message expression, this returns the selector index.<br>
	 * * After getting a cursor with #clang_getCursor, this can be called to<br>
	 * determine if the location points to a selector identifier.<br>
	 * * \returns The selector index if the cursor is an objc method or message<br>
	 * expression and the cursor is pointing to a selector identifier, or -1<br>
	 * otherwise.<br>
	 * Original signature : <code>int clang_Cursor_getObjCSelectorIndex(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3175</i>
	 */
	int clang_Cursor_getObjCSelectorIndex(CXCursor.ByValue CXCursor1);
	/**
	 * \brief Given a cursor pointing to a C++ method call or an ObjC message,<br>
	 * returns non-zero if the method/message is "dynamic", meaning:<br>
	 * <br>
	 * For a C++ method: the call is virtual.<br>
	 * For an ObjC message: the receiver is an object instance, not 'super' or a<br>
	 * specific class.<br>
	 * <br>
	 * If the method/message is "static" or the cursor does not point to a<br>
	 * method/message, it will return zero.<br>
	 * Original signature : <code>int clang_Cursor_isDynamicCall(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3188</i>
	 */
	int clang_Cursor_isDynamicCall(CXCursor.ByValue C);
	/**
	 * \brief Given a cursor pointing to an ObjC message, returns the CXType of the<br>
	 * receiver.<br>
	 * Original signature : <code>CXType clang_Cursor_getReceiverType(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3194</i>
	 */
	clang.CXType.ByValue clang_Cursor_getReceiverType(CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents a declaration, return the associated<br>
	 * comment's source range.  The range may include multiple consecutive comments<br>
	 * with whitespace in between.<br>
	 * Original signature : <code>CXSourceRange clang_Cursor_getCommentRange(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3201</i>
	 */
	CXSourceRange.ByValue clang_Cursor_getCommentRange(CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents a declaration, return the associated<br>
	 * comment text, including comment markers.<br>
	 * Original signature : <code>CXString clang_Cursor_getRawCommentText(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3207</i>
	 */
	CXString.ByValue clang_Cursor_getRawCommentText(CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents a documentable entity (e.g.,<br>
	 * declaration), return the associated \\brief paragraph; otherwise return the<br>
	 * first paragraph.<br>
	 * Original signature : <code>CXString clang_Cursor_getBriefCommentText(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3214</i>
	 */
	CXString.ByValue clang_Cursor_getBriefCommentText(CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents a documentable entity (e.g.,<br>
	 * declaration), return the associated parsed comment as a<br>
	 * \c CXComment_FullComment AST node.<br>
	 * Original signature : <code>CXComment clang_Cursor_getParsedComment(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3221</i>
	 */
	clang.CXComment.ByValue clang_Cursor_getParsedComment(CXCursor.ByValue C);
	/**
	 * \brief Given a CXCursor_ModuleImportDecl cursor, return the associated module.<br>
	 * Original signature : <code>CXModule clang_Cursor_getModule(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3240</i>
	 */
	Pointer clang_Cursor_getModule(CXCursor.ByValue C);
	/**
	 * \param Module a module object.<br>
	 * * \returns the parent of a sub-module or NULL if the given module is top-level,<br>
	 * e.g. for 'std.vector' it will return the 'std' module.<br>
	 * Original signature : <code>CXModule clang_Module_getParent(CXModule)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3248</i>
	 */
	Pointer clang_Module_getParent(Pointer Module);
	/**
	 * \param Module a module object.<br>
	 * * \returns the name of the module, e.g. for the 'std.vector' sub-module it<br>
	 * will return "vector".<br>
	 * Original signature : <code>CXString clang_Module_getName(CXModule)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3256</i>
	 */
	CXString.ByValue clang_Module_getName(Pointer Module);
	/**
	 * \param Module a module object.<br>
	 * * \returns the full name of the module, e.g. "std.vector".<br>
	 * Original signature : <code>CXString clang_Module_getFullName(CXModule)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3263</i>
	 */
	CXString.ByValue clang_Module_getFullName(Pointer Module);
	/**
	 * \param Module a module object.<br>
	 * * \returns the number of top level headers associated with this module.<br>
	 * Original signature : <code>int clang_Module_getNumTopLevelHeaders(CXModule)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3270</i>
	 */
	int clang_Module_getNumTopLevelHeaders(Pointer Module);
	/**
	 * Original signature : <code>CXFile clang_Module_getTopLevelHeader(CXModule, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3280</i>
	 */
	Pointer clang_Module_getTopLevelHeader(Pointer Module, int Index);
	/**
	 * \param Comment AST node of any kind.<br>
	 * * \returns the type of the AST node.<br>
	 * Original signature : <code>CXCommentKind clang_Comment_getKind(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3459</i>
	 */
	int clang_Comment_getKind(clang.CXComment.ByValue Comment);
	/**
	 * \param Comment AST node of any kind.<br>
	 * * \returns number of children of the AST node.<br>
	 * Original signature : <code>int clang_Comment_getNumChildren(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3466</i>
	 */
	int clang_Comment_getNumChildren(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>CXComment clang_Comment_getChild(CXComment, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3476</i>
	 */
	clang.CXComment.ByValue clang_Comment_getChild(clang.CXComment.ByValue Comment, int ChildIdx);
	/**
	 * \brief A \c CXComment_Paragraph node is considered whitespace if it contains<br>
	 * only \c CXComment_Text nodes that are empty or whitespace.<br>
	 * * Other AST nodes (except \c CXComment_Paragraph and \c CXComment_Text) are<br>
	 * never considered whitespace.<br>
	 * * \returns non-zero if \c Comment is whitespace.<br>
	 * Original signature : <code>int clang_Comment_isWhitespace(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3487</i>
	 */
	int clang_Comment_isWhitespace(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>int clang_InlineContentComment_hasTrailingNewline(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3495</i>
	 */
	int clang_InlineContentComment_hasTrailingNewline(clang.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_Text AST node.<br>
	 * * \returns text contained in the AST node.<br>
	 * Original signature : <code>CXString clang_TextComment_getText(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3502</i>
	 */
	CXString.ByValue clang_TextComment_getText(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>CXString clang_InlineCommandComment_getCommandName(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3510</i>
	 */
	CXString.ByValue clang_InlineCommandComment_getCommandName(clang.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_InlineCommand AST node.<br>
	 * * \returns the most appropriate rendering mode, chosen on command<br>
	 * semantics in Doxygen.<br>
	 * Original signature : <code>CXCommentInlineCommandRenderKind clang_InlineCommandComment_getRenderKind(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3518</i>
	 */
	int clang_InlineCommandComment_getRenderKind(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>int clang_InlineCommandComment_getNumArgs(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3527</i>
	 */
	int clang_InlineCommandComment_getNumArgs(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>CXString clang_InlineCommandComment_getArgText(CXComment, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3537</i>
	 */
	CXString.ByValue clang_InlineCommandComment_getArgText(clang.CXComment.ByValue Comment, int ArgIdx);
	/**
	 * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST<br>
	 * node.<br>
	 * * \returns HTML tag name.<br>
	 * Original signature : <code>CXString clang_HTMLTagComment_getTagName(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3546</i>
	 */
	CXString.ByValue clang_HTMLTagComment_getTagName(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>int clang_HTMLStartTagComment_isSelfClosing(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3554</i>
	 */
	int clang_HTMLStartTagComment_isSelfClosing(clang.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_HTMLStartTag AST node.<br>
	 * * \returns number of attributes (name-value pairs) attached to the start tag.<br>
	 * Original signature : <code>int clang_HTMLStartTag_getNumAttrs(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3561</i>
	 */
	int clang_HTMLStartTag_getNumAttrs(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>CXString clang_HTMLStartTag_getAttrName(CXComment, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3571</i>
	 */
	CXString.ByValue clang_HTMLStartTag_getAttrName(clang.CXComment.ByValue Comment, int AttrIdx);
	/**
	 * Original signature : <code>CXString clang_HTMLStartTag_getAttrValue(CXComment, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3581</i>
	 */
	CXString.ByValue clang_HTMLStartTag_getAttrValue(clang.CXComment.ByValue Comment, int AttrIdx);
	/**
	 * Original signature : <code>CXString clang_BlockCommandComment_getCommandName(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3589</i>
	 */
	CXString.ByValue clang_BlockCommandComment_getCommandName(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>int clang_BlockCommandComment_getNumArgs(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3597</i>
	 */
	int clang_BlockCommandComment_getNumArgs(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>CXString clang_BlockCommandComment_getArgText(CXComment, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3607</i>
	 */
	CXString.ByValue clang_BlockCommandComment_getArgText(clang.CXComment.ByValue Comment, int ArgIdx);
	/**
	 * Original signature : <code>CXComment clang_BlockCommandComment_getParagraph(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3617</i>
	 */
	clang.CXComment.ByValue clang_BlockCommandComment_getParagraph(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>CXString clang_ParamCommandComment_getParamName(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3625</i>
	 */
	CXString.ByValue clang_ParamCommandComment_getParamName(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>int clang_ParamCommandComment_isParamIndexValid(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3635</i>
	 */
	int clang_ParamCommandComment_isParamIndexValid(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>int clang_ParamCommandComment_getParamIndex(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3643</i>
	 */
	int clang_ParamCommandComment_getParamIndex(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>int clang_ParamCommandComment_isDirectionExplicit(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3652</i>
	 */
	int clang_ParamCommandComment_isDirectionExplicit(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>CXCommentParamPassDirection clang_ParamCommandComment_getDirection(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3660</i>
	 */
	int clang_ParamCommandComment_getDirection(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>CXString clang_TParamCommandComment_getParamName(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3669</i>
	 */
	CXString.ByValue clang_TParamCommandComment_getParamName(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>int clang_TParamCommandComment_isParamPositionValid(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3681</i>
	 */
	int clang_TParamCommandComment_isParamPositionValid(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>int clang_TParamCommandComment_getDepth(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3697</i>
	 */
	int clang_TParamCommandComment_getDepth(clang.CXComment.ByValue Comment);
	/**
	 * Original signature : <code>int clang_TParamCommandComment_getIndex(CXComment, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3718</i>
	 */
	int clang_TParamCommandComment_getIndex(clang.CXComment.ByValue Comment, int Depth);
	/**
	 * Original signature : <code>CXString clang_VerbatimBlockLineComment_getText(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3726</i>
	 */
	CXString.ByValue clang_VerbatimBlockLineComment_getText(clang.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_VerbatimLine AST node.<br>
	 * * \returns text contained in the AST node.<br>
	 * Original signature : <code>CXString clang_VerbatimLineComment_getText(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3733</i>
	 */
	CXString.ByValue clang_VerbatimLineComment_getText(clang.CXComment.ByValue Comment);
	/**
	 * \brief Convert an HTML tag AST node to string.<br>
	 * * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST<br>
	 * node.<br>
	 * * \returns string containing an HTML tag.<br>
	 * Original signature : <code>CXString clang_HTMLTagComment_getAsString(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3743</i>
	 */
	CXString.ByValue clang_HTMLTagComment_getAsString(clang.CXComment.ByValue Comment);
	/**
	 * \brief Convert a given full parsed comment to an HTML fragment.<br>
	 * * Specific details of HTML layout are subject to change.  Don't try to parse<br>
	 * this HTML back into an AST, use other APIs instead.<br>
	 * * Currently the following CSS classes are used:<br>
	 * \li "para-brief" for \\brief paragraph and equivalent commands;<br>
	 * \li "para-returns" for \\returns paragraph and equivalent commands;<br>
	 * \li "word-returns" for the "Returns" word in \\returns paragraph.<br>
	 * * Function argument documentation is rendered as a \<dl\> list with arguments<br>
	 * sorted in function prototype order.  CSS classes used:<br>
	 * \li "param-name-index-NUMBER" for parameter name (\<dt\>);<br>
	 * \li "param-descr-index-NUMBER" for parameter description (\<dd\>);<br>
	 * \li "param-name-index-invalid" and "param-descr-index-invalid" are used if<br>
	 * parameter index is invalid.<br>
	 * * Template parameter documentation is rendered as a \<dl\> list with<br>
	 * parameters sorted in template parameter list order.  CSS classes used:<br>
	 * \li "tparam-name-index-NUMBER" for parameter name (\<dt\>);<br>
	 * \li "tparam-descr-index-NUMBER" for parameter description (\<dd\>);<br>
	 * \li "tparam-name-index-other" and "tparam-descr-index-other" are used for<br>
	 * names inside template template parameters;<br>
	 * \li "tparam-name-index-invalid" and "tparam-descr-index-invalid" are used if<br>
	 * parameter position is invalid.<br>
	 * * \param Comment a \c CXComment_FullComment AST node.<br>
	 * * \returns string containing an HTML fragment.<br>
	 * Original signature : <code>CXString clang_FullComment_getAsHTML(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3776</i>
	 */
	CXString.ByValue clang_FullComment_getAsHTML(clang.CXComment.ByValue Comment);
	/**
	 * \brief Convert a given full parsed comment to an XML document.<br>
	 * * A Relax NG schema for the XML can be found in comment-xml-schema.rng file<br>
	 * inside clang source tree.<br>
	 * * \param Comment a \c CXComment_FullComment AST node.<br>
	 * * \returns string containing an XML document.<br>
	 * Original signature : <code>CXString clang_FullComment_getAsXML(CXComment)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3788</i>
	 */
	CXString.ByValue clang_FullComment_getAsXML(clang.CXComment.ByValue Comment);
	/**
	 * \brief Determine if a C++ member function or member function template is <br>
	 * declared 'static'.<br>
	 * Original signature : <code>int clang_CXXMethod_isStatic(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3807</i>
	 */
	int clang_CXXMethod_isStatic(CXCursor.ByValue C);
	/**
	 * \brief Determine if a C++ member function or member function template is<br>
	 * explicitly declared 'virtual' or if it overrides a virtual method from<br>
	 * one of the base classes.<br>
	 * Original signature : <code>int clang_CXXMethod_isVirtual(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3814</i>
	 */
	int clang_CXXMethod_isVirtual(CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents a template, determine<br>
	 * the cursor kind of the specializations would be generated by instantiating<br>
	 * the template.<br>
	 * * This routine can be used to determine what flavor of function template,<br>
	 * class template, or class template partial specialization is stored in the<br>
	 * cursor. For example, it can describe whether a class template cursor is<br>
	 * declared with "struct", "class" or "union".<br>
	 * * \param C The cursor to query. This cursor should represent a template<br>
	 * declaration.<br>
	 * * \returns The cursor kind of the specializations that would be generated<br>
	 * by instantiating the template \p C. If \p C is not a template, returns<br>
	 * \c CXCursor_NoDeclFound.<br>
	 * Original signature : <code>CXCursorKind clang_getTemplateCursorKind(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3833</i>
	 */
	int clang_getTemplateCursorKind(CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that may represent a specialization or instantiation<br>
	 * of a template, retrieve the cursor that represents the template that it<br>
	 * specializes or from which it was instantiated.<br>
	 * * This routine determines the template involved both for explicit <br>
	 * specializations of templates and for implicit instantiations of the template,<br>
	 * both of which are referred to as "specializations". For a class template<br>
	 * specialization (e.g., \c std::vector<bool>), this routine will return <br>
	 * either the primary template (\c std::vector) or, if the specialization was<br>
	 * instantiated from a class template partial specialization, the class template<br>
	 * partial specialization. For a class template partial specialization and a<br>
	 * function template specialization (including instantiations), this<br>
	 * this routine will return the specialized template.<br>
	 * * For members of a class template (e.g., member functions, member classes, or<br>
	 * static data members), returns the specialized or instantiated member. <br>
	 * Although not strictly "templates" in the C++ language, members of class<br>
	 * templates have the same notions of specializations and instantiations that<br>
	 * templates do, so this routine treats them similarly.<br>
	 * * \param C A cursor that may be a specialization of a template or a member<br>
	 * of a template.<br>
	 * * \returns If the given cursor is a specialization or instantiation of a <br>
	 * template or a member thereof, the template or member that it specializes or<br>
	 * from which it was instantiated. Otherwise, returns a NULL cursor.<br>
	 * Original signature : <code>CXCursor clang_getSpecializedCursorTemplate(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3863</i>
	 */
	CXCursor.ByValue clang_getSpecializedCursorTemplate(CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that references something else, return the source range<br>
	 * covering that reference.<br>
	 * * \param C A cursor pointing to a member reference, a declaration reference, or<br>
	 * an operator call.<br>
	 * \param NameFlags A bitset with three independent flags: <br>
	 * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and<br>
	 * CXNameRange_WantSinglePiece.<br>
	 * \param PieceIndex For contiguous names or when passing the flag <br>
	 * CXNameRange_WantSinglePiece, only one piece with index 0 is <br>
	 * available. When the CXNameRange_WantSinglePiece flag is not passed for a<br>
	 * non-contiguous names, this index can be used to retrieve the individual<br>
	 * pieces of the name. See also CXNameRange_WantSinglePiece.<br>
	 * * \returns The piece of the name pointed to by the given cursor. If there is no<br>
	 * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.<br>
	 * Original signature : <code>CXSourceRange clang_getCursorReferenceNameRange(CXCursor, unsigned, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3883</i>
	 */
	CXSourceRange.ByValue clang_getCursorReferenceNameRange(CXCursor.ByValue C, int NameFlags, int PieceIndex);
	/**
	 * \brief Determine the kind of the given token.<br>
	 * Original signature : <code>CXTokenKind clang_getTokenKind(CXToken)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3968</i>
	 */
	int clang_getTokenKind(CXToken.ByValue CXToken1);
	/**
	 * \brief Determine the spelling of the given token.<br>
	 * * The spelling of a token is the textual representation of that token, e.g.,<br>
	 * the text of an identifier or keyword.<br>
	 * Original signature : <code>CXString clang_getTokenSpelling(CXTranslationUnit, CXToken)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3976</i>
	 */
	CXString.ByValue clang_getTokenSpelling(ClangLibrary.CXTranslationUnit CXTranslationUnit1, CXToken.ByValue CXToken1);
	/**
	 * \brief Retrieve the source location of the given token.<br>
	 * Original signature : <code>CXSourceLocation clang_getTokenLocation(CXTranslationUnit, CXToken)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3981</i>
	 */
	CXSourceLocation.ByValue clang_getTokenLocation(ClangLibrary.CXTranslationUnit CXTranslationUnit1, CXToken.ByValue CXToken1);
	/**
	 * \brief Retrieve a source range that covers the given token.<br>
	 * Original signature : <code>CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:3987</i>
	 */
	CXSourceRange.ByValue clang_getTokenExtent(ClangLibrary.CXTranslationUnit CXTranslationUnit1, CXToken.ByValue CXToken1);
	/**
	 * \brief Tokenize the source code described by the given range into raw<br>
	 * lexical tokens.<br>
	 * * \param TU the translation unit whose text is being tokenized.<br>
	 * * \param Range the source range in which text should be tokenized. All of the<br>
	 * tokens produced by tokenization will fall within this source range,<br>
	 * * \param Tokens this pointer will be set to point to the array of tokens<br>
	 * that occur within the given source range. The returned pointer must be<br>
	 * freed with clang_disposeTokens() before the translation unit is destroyed.<br>
	 * * \param NumTokens will be set to the number of tokens in the \c *Tokens<br>
	 * array.<br>
	 * Original signature : <code>void clang_tokenize(CXTranslationUnit, CXSourceRange, CXToken**, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4006</i><br>
	 * @deprecated use the safer methods {@link #clang_tokenize(clang.ClangLibrary.CXTranslationUnit, clang.CXSourceRange.ByValue, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer)} and {@link #clang_tokenize(clang.ClangLibrary.CXTranslationUnit, clang.CXSourceRange.ByValue, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	void clang_tokenize(ClangLibrary.CXTranslationUnit TU, CXSourceRange.ByValue Range, PointerByReference Tokens, IntByReference NumTokens);
	/**
	 * \brief Tokenize the source code described by the given range into raw<br>
	 * lexical tokens.<br>
	 * * \param TU the translation unit whose text is being tokenized.<br>
	 * * \param Range the source range in which text should be tokenized. All of the<br>
	 * tokens produced by tokenization will fall within this source range,<br>
	 * * \param Tokens this pointer will be set to point to the array of tokens<br>
	 * that occur within the given source range. The returned pointer must be<br>
	 * freed with clang_disposeTokens() before the translation unit is destroyed.<br>
	 * * \param NumTokens will be set to the number of tokens in the \c *Tokens<br>
	 * array.<br>
	 * Original signature : <code>void clang_tokenize(CXTranslationUnit, CXSourceRange, CXToken**, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4006</i>
	 */
	void clang_tokenize(ClangLibrary.CXTranslationUnit TU, CXSourceRange.ByValue Range, PointerByReference Tokens, IntBuffer NumTokens);
	/**
	 * \brief Annotate the given set of tokens by providing cursors for each token<br>
	 * that can be mapped to a specific entity within the abstract syntax tree.<br>
	 * * This token-annotation routine is equivalent to invoking<br>
	 * clang_getCursor() for the source locations of each of the<br>
	 * tokens. The cursors provided are filtered, so that only those<br>
	 * cursors that have a direct correspondence to the token are<br>
	 * accepted. For example, given a function call \c f(x),<br>
	 * clang_getCursor() would provide the following cursors:<br>
	 * *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.<br>
	 *   * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.<br>
	 *   * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.<br>
	 * * Only the first and last of these cursors will occur within the<br>
	 * annotate, since the tokens "f" and "x' directly refer to a function<br>
	 * and a variable, respectively, but the parentheses are just a small<br>
	 * part of the full syntax of the function call expression, which is<br>
	 * not provided as an annotation.<br>
	 * * \param TU the translation unit that owns the given tokens.<br>
	 * * \param Tokens the set of tokens to annotate.<br>
	 * * \param NumTokens the number of tokens in \p Tokens.<br>
	 * * \param Cursors an array of \p NumTokens cursors, whose contents will be<br>
	 * replaced with the cursors corresponding to each token.<br>
	 * Original signature : <code>void clang_annotateTokens(CXTranslationUnit, CXToken*, unsigned, CXCursor*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4039</i>
	 */
	void clang_annotateTokens(ClangLibrary.CXTranslationUnit TU, CXToken Tokens, int NumTokens, CXCursor Cursors);
	/**
	 * \brief Free the given set of tokens.<br>
	 * Original signature : <code>void clang_disposeTokens(CXTranslationUnit, CXToken*, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4046</i>
	 */
	void clang_disposeTokens(ClangLibrary.CXTranslationUnit TU, CXToken Tokens, int NumTokens);
	/**
	 * for debug/testing<br>
	 * Original signature : <code>CXString clang_getCursorKindSpelling(CXCursorKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4063</i>
	 */
	CXString.ByValue clang_getCursorKindSpelling(int Kind);
	/**
	 * Original signature : <code>void clang_getDefinitionSpellingAndExtent(CXCursor, const char**, const char**, unsigned*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4064</i><br>
	 * @deprecated use the safer methods {@link #clang_getDefinitionSpellingAndExtent(clang.CXCursor.ByValue, java.lang.String[], java.lang.String[], java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_getDefinitionSpellingAndExtent(clang.CXCursor.ByValue, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	void clang_getDefinitionSpellingAndExtent(CXCursor.ByValue CXCursor1, PointerByReference startBuf, PointerByReference endBuf, IntByReference startLine, IntByReference startColumn, IntByReference endLine, IntByReference endColumn);
	/**
	 * Original signature : <code>void clang_getDefinitionSpellingAndExtent(CXCursor, const char**, const char**, unsigned*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4064</i>
	 */
	void clang_getDefinitionSpellingAndExtent(CXCursor.ByValue CXCursor1, String startBuf[], String endBuf[], IntBuffer startLine, IntBuffer startColumn, IntBuffer endLine, IntBuffer endColumn);
	/**
	 * Original signature : <code>void clang_enableStackTraces()</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4071</i>
	 */
	void clang_enableStackTraces();
	/**
	 * Original signature : <code>void clang_executeOnThread(clang_executeOnThread_fn_callback, void*, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4072</i>
	 */
	void clang_executeOnThread(ClangLibrary.clang_executeOnThread_fn_callback arg, Pointer user_data, int stack_size);
	/**
	 * \brief Determine the kind of a particular chunk within a completion string.<br>
	 * * \param completion_string the completion string to query.<br>
	 * * \param chunk_number the 0-based index of the chunk in the completion string.<br>
	 * * \returns the kind of the chunk at the index \c chunk_number.<br>
	 * Original signature : <code>CXCompletionChunkKind clang_getCompletionChunkKind(CXCompletionString, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4309</i>
	 */
	int clang_getCompletionChunkKind(Pointer completion_string, int chunk_number);
	/**
	 * \brief Retrieve the text associated with a particular chunk within a<br>
	 * completion string.<br>
	 * * \param completion_string the completion string to query.<br>
	 * * \param chunk_number the 0-based index of the chunk in the completion string.<br>
	 * * \returns the text associated with the chunk at index \c chunk_number.<br>
	 * Original signature : <code>CXString clang_getCompletionChunkText(CXCompletionString, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4323</i>
	 */
	CXString.ByValue clang_getCompletionChunkText(Pointer completion_string, int chunk_number);
	/**
	 * \brief Retrieve the completion string associated with a particular chunk<br>
	 * within a completion string.<br>
	 * * \param completion_string the completion string to query.<br>
	 * * \param chunk_number the 0-based index of the chunk in the completion string.<br>
	 * * \returns the completion string associated with the chunk at index<br>
	 * \c chunk_number.<br>
	 * Original signature : <code>CXCompletionString clang_getCompletionChunkCompletionString(CXCompletionString, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4338</i>
	 */
	Pointer clang_getCompletionChunkCompletionString(Pointer completion_string, int chunk_number);
	/**
	 * \brief Retrieve the number of chunks in the given code-completion string.<br>
	 * Original signature : <code>int clang_getNumCompletionChunks(CXCompletionString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4345</i>
	 */
	int clang_getNumCompletionChunks(Pointer completion_string);
	/**
	 * \brief Determine the priority of this code completion.<br>
	 * * The priority of a code completion indicates how likely it is that this <br>
	 * particular completion is the completion that the user will select. The<br>
	 * priority is selected by various internal heuristics.<br>
	 * * \param completion_string The completion string to query.<br>
	 * * \returns The priority of this completion string. Smaller values indicate<br>
	 * higher-priority (more likely) completions.<br>
	 * Original signature : <code>int clang_getCompletionPriority(CXCompletionString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4360</i>
	 */
	int clang_getCompletionPriority(Pointer completion_string);
	/**
	 * \brief Determine the availability of the entity that this code-completion<br>
	 * string refers to.<br>
	 * * \param completion_string The completion string to query.<br>
	 * * \returns The availability of the completion string.<br>
	 * Original signature : <code>CXAvailabilityKind clang_getCompletionAvailability(CXCompletionString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4371</i>
	 */
	int clang_getCompletionAvailability(Pointer completion_string);
	/**
	 * \brief Retrieve the number of annotations associated with the given<br>
	 * completion string.<br>
	 * * \param completion_string the completion string to query.<br>
	 * * \returns the number of annotations associated with the given completion<br>
	 * string.<br>
	 * Original signature : <code>int clang_getCompletionNumAnnotations(CXCompletionString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4383</i>
	 */
	int clang_getCompletionNumAnnotations(Pointer completion_string);
	/**
	 * \brief Retrieve the annotation associated with the given completion string.<br>
	 * * \param completion_string the completion string to query.<br>
	 * * \param annotation_number the 0-based index of the annotation of the<br>
	 * completion string.<br>
	 * * \returns annotation string associated with the completion at index<br>
	 * \c annotation_number, or a NULL string if that annotation is not available.<br>
	 * Original signature : <code>CXString clang_getCompletionAnnotation(CXCompletionString, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4397</i>
	 */
	CXString.ByValue clang_getCompletionAnnotation(Pointer completion_string, int annotation_number);
	/**
	 * \brief Retrieve the parent context of the given completion string.<br>
	 * * The parent context of a completion string is the semantic parent of <br>
	 * the declaration (if any) that the code completion represents. For example,<br>
	 * a code completion for an Objective-C method would have the method's class<br>
	 * or protocol as its context.<br>
	 * * \param completion_string The code completion string whose parent is<br>
	 * being queried.<br>
	 * * \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.<br>
	 * * \returns The name of the completion parent, e.g., "NSObject" if<br>
	 * the completion string represents a method in the NSObject class.<br>
	 * Original signature : <code>CXString clang_getCompletionParent(CXCompletionString, CXCursorKind*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4417</i><br>
	 * @deprecated use the safer methods {@link #clang_getCompletionParent(com.sun.jna.Pointer, java.nio.IntBuffer)} and {@link #clang_getCompletionParent(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	CXString.ByValue clang_getCompletionParent(Pointer completion_string, IntByReference kind);
	/**
	 * \brief Retrieve the parent context of the given completion string.<br>
	 * * The parent context of a completion string is the semantic parent of <br>
	 * the declaration (if any) that the code completion represents. For example,<br>
	 * a code completion for an Objective-C method would have the method's class<br>
	 * or protocol as its context.<br>
	 * * \param completion_string The code completion string whose parent is<br>
	 * being queried.<br>
	 * * \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.<br>
	 * * \returns The name of the completion parent, e.g., "NSObject" if<br>
	 * the completion string represents a method in the NSObject class.<br>
	 * Original signature : <code>CXString clang_getCompletionParent(CXCompletionString, CXCursorKind*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4417</i>
	 */
	CXString.ByValue clang_getCompletionParent(Pointer completion_string, IntBuffer kind);
	/**
	 * \brief Retrieve the brief documentation comment attached to the declaration<br>
	 * that corresponds to the given completion string.<br>
	 * Original signature : <code>CXString clang_getCompletionBriefComment(CXCompletionString)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4425</i>
	 */
	CXString.ByValue clang_getCompletionBriefComment(Pointer completion_string);
	/**
	 * \brief Retrieve a completion string for an arbitrary declaration or macro<br>
	 * definition cursor.<br>
	 * * \param cursor The cursor to query.<br>
	 * * \returns A non-context-sensitive completion string for declaration and macro<br>
	 * definition cursors, or NULL for other kinds of cursors.<br>
	 * Original signature : <code>CXCompletionString clang_getCursorCompletionString(CXCursor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4437</i>
	 */
	Pointer clang_getCursorCompletionString(CXCursor.ByValue cursor);
	/**
	 * \brief Returns a default set of code-completion options that can be<br>
	 * passed to\c clang_codeCompleteAt().<br>
	 * Original signature : <code>int clang_defaultCodeCompleteOptions()</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4622</i>
	 */
	int clang_defaultCodeCompleteOptions();
	/**
	 * Original signature : <code>CXCodeCompleteResults* clang_codeCompleteAt(CXTranslationUnit, const char*, unsigned, unsigned, CXUnsavedFile*, unsigned, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4693</i><br>
	 * @deprecated use the safer methods {@link #clang_codeCompleteAt(clang.ClangLibrary.CXTranslationUnit, java.lang.String, int, int, clang.CXUnsavedFile, int, int)} and {@link #clang_codeCompleteAt(clang.ClangLibrary.CXTranslationUnit, com.sun.jna.Pointer, int, int, clang.CXUnsavedFile, int, int)} instead
	 */
	@Deprecated
	CXCodeCompleteResults clang_codeCompleteAt(ClangLibrary.CXTranslationUnit TU, Pointer complete_filename, int complete_line, int complete_column, CXUnsavedFile unsaved_files, int num_unsaved_files, int options);
	/**
	 * Original signature : <code>CXCodeCompleteResults* clang_codeCompleteAt(CXTranslationUnit, const char*, unsigned, unsigned, CXUnsavedFile*, unsigned, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4693</i>
	 */
	CXCodeCompleteResults clang_codeCompleteAt(ClangLibrary.CXTranslationUnit TU, String complete_filename, int complete_line, int complete_column, CXUnsavedFile unsaved_files, int num_unsaved_files, int options);
	/**
	 * Original signature : <code>void clang_sortCodeCompletionResults(CXCompletionResult*, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4709</i>
	 */
	void clang_sortCodeCompletionResults(CXCompletionResult Results, int NumResults);
	/**
	 * Original signature : <code>void clang_disposeCodeCompleteResults(CXCodeCompleteResults*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4716</i>
	 */
	void clang_disposeCodeCompleteResults(CXCodeCompleteResults Results);
	/**
	 * Original signature : <code>int clang_codeCompleteGetNumDiagnostics(CXCodeCompleteResults*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4723</i>
	 */
	int clang_codeCompleteGetNumDiagnostics(CXCodeCompleteResults Results);
	/**
	 * Original signature : <code>CXDiagnostic clang_codeCompleteGetDiagnostic(CXCodeCompleteResults*, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4735</i>
	 */
	Pointer clang_codeCompleteGetDiagnostic(CXCodeCompleteResults Results, int Index);
	/**
	 * Original signature : <code>long long clang_codeCompleteGetContexts(CXCodeCompleteResults*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4748</i>
	 */
	long clang_codeCompleteGetContexts(CXCodeCompleteResults Results);
	/**
	 * Original signature : <code>CXCursorKind clang_codeCompleteGetContainerKind(CXCodeCompleteResults*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4768</i><br>
	 * @deprecated use the safer methods {@link #clang_codeCompleteGetContainerKind(clang.CXCodeCompleteResults, java.nio.IntBuffer)} and {@link #clang_codeCompleteGetContainerKind(clang.CXCodeCompleteResults, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	int clang_codeCompleteGetContainerKind(CXCodeCompleteResults Results, IntByReference IsIncomplete);
	/**
	 * Original signature : <code>CXCursorKind clang_codeCompleteGetContainerKind(CXCodeCompleteResults*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4768</i>
	 */
	int clang_codeCompleteGetContainerKind(CXCodeCompleteResults Results, IntBuffer IsIncomplete);
	/**
	 * Original signature : <code>CXString clang_codeCompleteGetContainerUSR(CXCodeCompleteResults*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4782</i>
	 */
	CXString.ByValue clang_codeCompleteGetContainerUSR(CXCodeCompleteResults Results);
	/**
	 * Original signature : <code>CXString clang_codeCompleteGetObjCSelector(CXCodeCompleteResults*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4797</i>
	 */
	CXString.ByValue clang_codeCompleteGetObjCSelector(CXCodeCompleteResults Results);
	/**
	 * \brief Return a version string, suitable for showing to a user, but not<br>
	 *        intended to be parsed (the format is not guaranteed to be stable).<br>
	 * Original signature : <code>CXString clang_getClangVersion()</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4814</i>
	 */
	CXString.ByValue clang_getClangVersion();
	/**
	 * \brief Enable/disable crash recovery.<br>
	 * * \param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero<br>
	 *        value enables crash recovery, while 0 disables it.<br>
	 * Original signature : <code>void clang_toggleCrashRecovery(unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4823</i>
	 */
	void clang_toggleCrashRecovery(int isEnabled);
	/**
	 * \brief Visit the set of preprocessor inclusions in a translation unit.<br>
	 *   The visitor function is called with the provided data for every included<br>
	 *   file.  This does not include headers included by the PCH file (unless one<br>
	 *   is inspecting the inclusions in the PCH file itself).<br>
	 * Original signature : <code>void clang_getInclusions(CXTranslationUnit, CXInclusionVisitor, CXClientData)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4847</i>
	 */
	void clang_getInclusions(ClangLibrary.CXTranslationUnit tu, ClangLibrary.CXInclusionVisitor visitor, Pointer client_data);
	/**
	 * \brief Retrieve a remapping.<br>
	 * * \param path the path that contains metadata about remappings.<br>
	 * * \returns the requested remapping. This remapping must be freed<br>
	 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.<br>
	 * Original signature : <code>CXRemapping clang_getRemappings(const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4873</i><br>
	 * @deprecated use the safer methods {@link #clang_getRemappings(java.lang.String)} and {@link #clang_getRemappings(com.sun.jna.Pointer)} instead
	 */
	@Deprecated
	Pointer clang_getRemappings(Pointer path);
	/**
	 * \brief Retrieve a remapping.<br>
	 * * \param path the path that contains metadata about remappings.<br>
	 * * \returns the requested remapping. This remapping must be freed<br>
	 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.<br>
	 * Original signature : <code>CXRemapping clang_getRemappings(const char*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4873</i>
	 */
	Pointer clang_getRemappings(String path);
	/**
	 * Original signature : <code>CXRemapping clang_getRemappingsFromFileList(const char**, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4886</i><br>
	 * @deprecated use the safer methods {@link #clang_getRemappingsFromFileList(java.lang.String[], int)} and {@link #clang_getRemappingsFromFileList(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated
	Pointer clang_getRemappingsFromFileList(PointerByReference filePaths, int numFiles);
	/**
	 * Original signature : <code>CXRemapping clang_getRemappingsFromFileList(const char**, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4886</i>
	 */
	Pointer clang_getRemappingsFromFileList(String filePaths[], int numFiles);
	/**
	 * \brief Determine the number of remappings.<br>
	 * Original signature : <code>int clang_remap_getNumFiles(CXRemapping)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4892</i>
	 */
	int clang_remap_getNumFiles(Pointer CXRemapping1);
	/**
	 * \brief Get the original and the associated filename from the remapping.<br>
	 * <br>
	 * \param original If non-NULL, will be set to the original filename.<br>
	 * * \param transformed If non-NULL, will be set to the filename that the original<br>
	 * is associated with.<br>
	 * Original signature : <code>void clang_remap_getFilenames(CXRemapping, unsigned, CXString*, CXString*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4902</i>
	 */
	void clang_remap_getFilenames(Pointer CXRemapping1, int index, CXString original, CXString transformed);
	/**
	 * \brief Dispose the remapping.<br>
	 * Original signature : <code>void clang_remap_dispose(CXRemapping)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4908</i>
	 */
	void clang_remap_dispose(Pointer CXRemapping1);
	/**
	 * \brief Find references of a declaration in a specific file.<br>
	 * <br>
	 * \param cursor pointing to a declaration or a reference of one.<br>
	 * * \param file to search for references.<br>
	 * * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for<br>
	 * each reference found.<br>
	 * The CXSourceRange will point inside the file; if the reference is inside<br>
	 * a macro (and not a macro argument) the CXSourceRange will be invalid.<br>
	 * Original signature : <code>void clang_findReferencesInFile(CXCursor, CXFile, CXCursorAndRangeVisitor)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:4941</i>
	 */
	void clang_findReferencesInFile(CXCursor.ByValue cursor, Pointer file, clang.CXCursorAndRangeVisitor.ByValue visitor);
	/**
	 * Original signature : <code>int clang_index_isEntityObjCContainerKind(CXIdxEntityKind)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5315</i>
	 */
	int clang_index_isEntityObjCContainerKind(int CXIdxEntityKind1);
	/**
	 * Original signature : <code>CXIdxObjCContainerDeclInfo* clang_index_getObjCContainerDeclInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5316</i>
	 */
	CXIdxObjCContainerDeclInfo clang_index_getObjCContainerDeclInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * Original signature : <code>CXIdxObjCInterfaceDeclInfo* clang_index_getObjCInterfaceDeclInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5319</i>
	 */
	CXIdxObjCInterfaceDeclInfo clang_index_getObjCInterfaceDeclInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * Original signature : <code>CXIdxObjCCategoryDeclInfo* clang_index_getObjCCategoryDeclInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5323</i>
	 */
	CXIdxObjCCategoryDeclInfo clang_index_getObjCCategoryDeclInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * Original signature : <code>CXIdxObjCProtocolRefListInfo* clang_index_getObjCProtocolRefListInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5326</i>
	 */
	CXIdxObjCProtocolRefListInfo clang_index_getObjCProtocolRefListInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * Original signature : <code>CXIdxObjCPropertyDeclInfo* clang_index_getObjCPropertyDeclInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5329</i>
	 */
	CXIdxObjCPropertyDeclInfo clang_index_getObjCPropertyDeclInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * Original signature : <code>CXIdxIBOutletCollectionAttrInfo* clang_index_getIBOutletCollectionAttrInfo(const CXIdxAttrInfo*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5332</i>
	 */
	CXIdxIBOutletCollectionAttrInfo clang_index_getIBOutletCollectionAttrInfo(CXIdxAttrInfo CXIdxAttrInfoPtr1);
	/**
	 * Original signature : <code>CXIdxCXXClassDeclInfo* clang_index_getCXXClassDeclInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5335</i>
	 */
	CXIdxCXXClassDeclInfo clang_index_getCXXClassDeclInfo(CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * \brief For retrieving a custom CXIdxClientContainer attached to a<br>
	 * container.<br>
	 * Original signature : <code>CXIdxClientContainer clang_index_getClientContainer(const CXIdxContainerInfo*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5342</i>
	 */
	Pointer clang_index_getClientContainer(CXIdxContainerInfo CXIdxContainerInfoPtr1);
	/**
	 * \brief For setting a custom CXIdxClientContainer attached to a<br>
	 * container.<br>
	 * Original signature : <code>void clang_index_setClientContainer(const CXIdxContainerInfo*, CXIdxClientContainer)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5349</i>
	 */
	void clang_index_setClientContainer(CXIdxContainerInfo CXIdxContainerInfoPtr1, Pointer CXIdxClientContainer1);
	/**
	 * \brief For retrieving a custom CXIdxClientEntity attached to an entity.<br>
	 * Original signature : <code>CXIdxClientEntity clang_index_getClientEntity(const CXIdxEntityInfo*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5355</i>
	 */
	Pointer clang_index_getClientEntity(CXIdxEntityInfo CXIdxEntityInfoPtr1);
	/**
	 * \brief For setting a custom CXIdxClientEntity attached to an entity.<br>
	 * Original signature : <code>void clang_index_setClientEntity(const CXIdxEntityInfo*, CXIdxClientEntity)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5361</i>
	 */
	void clang_index_setClientEntity(CXIdxEntityInfo CXIdxEntityInfoPtr1, Pointer CXIdxClientEntity1);
	/**
	 * \brief An indexing action/session, to be applied to one or multiple<br>
	 * translation units.<br>
	 * * \param CIdx The index object with which the index action will be associated.<br>
	 * Original signature : <code>CXIndexAction clang_IndexAction_create(CXIndex)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5376</i>
	 */
	Pointer clang_IndexAction_create(Pointer CIdx);
	/**
	 * \brief Destroy the given index action.<br>
	 * * The index action must not be destroyed until all of the translation units<br>
	 * created within that index action have been destroyed.<br>
	 * Original signature : <code>void clang_IndexAction_dispose(CXIndexAction)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5384</i>
	 */
	void clang_IndexAction_dispose(Pointer CXIndexAction1);
	/**
	 * \brief Index the given source file and the translation unit corresponding<br>
	 * to that file via callbacks implemented through #IndexerCallbacks.<br>
	 * * \param client_data pointer data supplied by the client, which will<br>
	 * be passed to the invoked callbacks.<br>
	 * * \param index_callbacks Pointer to indexing callbacks that the client<br>
	 * implements.<br>
	 * * \param index_callbacks_size Size of #IndexerCallbacks structure that gets<br>
	 * passed in index_callbacks.<br>
	 * * \param index_options A bitmask of options that affects how indexing is<br>
	 * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.<br>
	 * * \param out_TU [out] pointer to store a CXTranslationUnit that can be reused<br>
	 * after indexing is finished. Set to NULL if you do not require it.<br>
	 * * \returns If there is a failure from which the there is no recovery, returns<br>
	 * non-zero, otherwise returns 0.<br>
	 * * The rest of the parameters are the same as #clang_parseTranslationUnit.<br>
	 * Original signature : <code>int clang_indexSourceFile(CXIndexAction, CXClientData, IndexerCallbacks*, unsigned, unsigned, const char*, const const char**, int, CXUnsavedFile*, unsigned, CXTranslationUnit*, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5449</i><br>
	 * @deprecated use the safer methods {@link #clang_indexSourceFile(com.sun.jna.Pointer, com.sun.jna.Pointer, clang.IndexerCallbacks, int, int, java.lang.String, byte[][], int, clang.CXUnsavedFile, int, clang.ClangLibrary.CXTranslationUnit, int)} and {@link #clang_indexSourceFile(com.sun.jna.Pointer, com.sun.jna.Pointer, clang.IndexerCallbacks, int, int, com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, int, clang.CXUnsavedFile, int, clang.ClangLibrary.CXTranslationUnit, int)} instead
	 */
	@Deprecated
	int clang_indexSourceFile(Pointer CXIndexAction1, Pointer client_data, IndexerCallbacks index_callbacks, int index_callbacks_size, int index_options, Pointer source_filename, PointerByReference command_line_args, int num_command_line_args, CXUnsavedFile unsaved_files, int num_unsaved_files, ClangLibrary.CXTranslationUnit out_TU, int TU_options);
	/**
	 * \brief Index the given source file and the translation unit corresponding<br>
	 * to that file via callbacks implemented through #IndexerCallbacks.<br>
	 * * \param client_data pointer data supplied by the client, which will<br>
	 * be passed to the invoked callbacks.<br>
	 * * \param index_callbacks Pointer to indexing callbacks that the client<br>
	 * implements.<br>
	 * * \param index_callbacks_size Size of #IndexerCallbacks structure that gets<br>
	 * passed in index_callbacks.<br>
	 * * \param index_options A bitmask of options that affects how indexing is<br>
	 * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.<br>
	 * * \param out_TU [out] pointer to store a CXTranslationUnit that can be reused<br>
	 * after indexing is finished. Set to NULL if you do not require it.<br>
	 * * \returns If there is a failure from which the there is no recovery, returns<br>
	 * non-zero, otherwise returns 0.<br>
	 * * The rest of the parameters are the same as #clang_parseTranslationUnit.<br>
	 * Original signature : <code>int clang_indexSourceFile(CXIndexAction, CXClientData, IndexerCallbacks*, unsigned, unsigned, const char*, const const char**, int, CXUnsavedFile*, unsigned, CXTranslationUnit*, unsigned)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5449</i>
	 */
	int clang_indexSourceFile(Pointer CXIndexAction1, Pointer client_data, IndexerCallbacks index_callbacks, int index_callbacks_size, int index_options, String source_filename, byte[] command_line_args[], int num_command_line_args, CXUnsavedFile unsaved_files, int num_unsaved_files, ClangLibrary.CXTranslationUnit out_TU, int TU_options);
	/**
	 * \brief Index the given translation unit via callbacks implemented through<br>
	 * #IndexerCallbacks.<br>
	 * <br>
	 * The order of callback invocations is not guaranteed to be the same as<br>
	 * when indexing a source file. The high level order will be:<br>
	 * <br>
	 *   -Preprocessor callbacks invocations<br>
	 *   -Declaration/reference callbacks invocations<br>
	 *   -Diagnostic callback invocations<br>
	 * * The parameters are the same as #clang_indexSourceFile.<br>
	 * <br>
	 * \returns If there is a failure from which the there is no recovery, returns<br>
	 * non-zero, otherwise returns 0.<br>
	 * Original signature : <code>int clang_indexTranslationUnit(CXIndexAction, CXClientData, IndexerCallbacks*, unsigned, unsigned, CXTranslationUnit)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5478</i>
	 */
	int clang_indexTranslationUnit(Pointer CXIndexAction1, Pointer client_data, IndexerCallbacks index_callbacks, int index_callbacks_size, int index_options, ClangLibrary.CXTranslationUnit CXTranslationUnit1);
	/**
	 * \brief Retrieve the CXIdxFile, file, line, column, and offset represented by<br>
	 * the given CXIdxLoc.<br>
	 * * If the location refers into a macro expansion, retrieves the<br>
	 * location of the macro expansion and if it refers into a macro argument<br>
	 * retrieves the location of the argument.<br>
	 * Original signature : <code>void clang_indexLoc_getFileLocation(CXIdxLoc, CXIdxClientFile*, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5493</i><br>
	 * @deprecated use the safer methods {@link #clang_indexLoc_getFileLocation(clang.CXIdxLoc.ByValue, com.sun.jna.Pointer, com.sun.jna.Pointer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clang_indexLoc_getFileLocation(clang.CXIdxLoc.ByValue, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	void clang_indexLoc_getFileLocation(clang.CXIdxLoc.ByValue loc, Pointer indexFile, Pointer file, IntByReference line, IntByReference column, IntByReference offset);
	/**
	 * \brief Retrieve the CXIdxFile, file, line, column, and offset represented by<br>
	 * the given CXIdxLoc.<br>
	 * * If the location refers into a macro expansion, retrieves the<br>
	 * location of the macro expansion and if it refers into a macro argument<br>
	 * retrieves the location of the argument.<br>
	 * Original signature : <code>void clang_indexLoc_getFileLocation(CXIdxLoc, CXIdxClientFile*, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5493</i>
	 */
	void clang_indexLoc_getFileLocation(clang.CXIdxLoc.ByValue loc, Pointer indexFile, Pointer file, IntBuffer line, IntBuffer column, IntBuffer offset);
	/**
	 * Original signature : <code>CXSourceLocation clang_indexLoc_getCXSourceLocation(CXIdxLoc)</code><br>
	 * <i>native declaration : src/main/c/clang-c/Index.h:5504</i>
	 */
	CXSourceLocation.ByValue clang_indexLoc_getCXSourceLocation(clang.CXIdxLoc.ByValue loc);
	public static class CXTranslationUnit extends PointerType {
		public CXTranslationUnit(Pointer address) {
			super(address);
		}
		public CXTranslationUnit() {
			super();
		}
	};
	public static class time_t extends PointerType {
		public time_t(Pointer address) {
			super(address);
		}
		public time_t() {
			super();
		}
	};
	public static class include_len extends PointerType {
		public include_len(Pointer address) {
			super(address);
		}
		public include_len() {
			super();
		}
	};
	public static class CXCursorSet extends PointerType {
		public CXCursorSet(Pointer address) {
			super(address);
		}
		public CXCursorSet() {
			super();
		}
	};
}
